diff --git a/fs/Kconfig b/fs/Kconfig
index 2fb08d05d..b5282e150 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -406,3 +406,137 @@ config IO_WQ
 	bool
 
 endmenu
+
+menu "HymoFS"
+
+config HYMOFS
+	bool "HymoFS Support"
+	default n
+	help
+	  HymoFS is a kernel-level path manipulation and hiding framework.
+	  It provides various file system virtualization capabilities for
+	  advanced users and security researchers.
+	  
+	  If unsure, say N.
+
+config HYMOFS_REVERSE_LOOKUP
+	bool "Enable reverse path lookup (d_path hooks)"
+	depends on HYMOFS
+	default y
+	help
+	  Allow converting real paths back to virtual paths when userspace
+	  queries file paths. This is the reverse operation of forward redirect.
+	  
+	  - Low performance overhead (~5% on path resolution)
+	  - Effective on all processes
+	  - Required for complete path hiding
+	  
+	  If unsure, say Y.
+
+config HYMOFS_FORWARD_REDIRECT
+	bool "Enable forward path redirection (namei hooks)"
+	depends on HYMOFS
+	default y
+	help
+	  Allow redirecting virtual paths to real paths during file opening.
+	  This is the forward operation complementary to reverse lookup.
+	  
+	  - Low performance overhead (~3% on file open)
+	  - Effective on all processes
+	  - Required for path redirection
+	  
+	  If unsure, say Y.
+
+config HYMOFS_HIDE_ENTRIES
+	bool "Enable directory entry hiding"
+	depends on HYMOFS
+	default y
+	help
+	  Allow hiding user-defined files and directories from directory listing.
+	  
+	  - Medium performance overhead (~10% on directory traversal)
+	  - Effective on all processes
+	  - Uses in-kernel filtering during readdir()
+	  
+	  If unsure, say Y.
+
+config HYMOFS_INJECT_ENTRIES
+	bool "Enable directory entry injection (experimental)"
+	depends on HYMOFS
+	default n
+	help
+	  Allow injecting virtual files/directories into directory listings.
+	  
+	  - Medium-high performance overhead (~15% on directory traversal)
+	  - Effective on all processes
+	  - Experimental feature, may cause stability issues
+	  
+	  Disable if you don't need virtual files or care about performance.
+	  If unsure, say N.
+
+config HYMOFS_STAT_SPOOF
+	bool "Enable stat/kstat spoofing"
+	depends on HYMOFS
+	default n
+	help
+	  Allow spoofing file metadata (size, timestamps, mode, etc.).
+	  
+	  - Low performance overhead (~2% on stat calls)
+	  - Effective only on zygote spawned user app processes
+	  
+	  Disable if you don't need metadata manipulation.
+	  If unsure, say N.
+
+config HYMOFS_XATTR_FILTER
+	bool "Enable extended attributes filtering"
+	depends on HYMOFS
+	default y
+	help
+	  Allow filtering/spoofing extended attributes (xattr).
+	  
+	  - Very low performance overhead (~1% on xattr operations)
+	  - Effective on all processes
+	  - Commonly used to hide SELinux contexts
+	  
+	  If unsure, say Y.
+
+config HYMOFS_UNAME_SPOOF
+	bool "Enable uname spoofing"
+	depends on HYMOFS
+	default n
+	help
+	  Allow spoofing the output of uname syscall.
+	  
+	  - Negligible performance overhead
+	  - Effective on all processes
+	  
+	  Disable if you don't need to hide kernel version.
+	  If unsure, say N.
+
+config HYMOFS_CMDLINE_SPOOF
+	bool "Enable cmdline/bootconfig spoofing"
+	depends on HYMOFS
+	default n
+	help
+	  Allow spoofing /proc/cmdline and /proc/bootconfig.
+	  
+	  - Negligible performance overhead
+	  - Effective on all processes
+	  
+	  Disable if you don't need to hide boot parameters.
+	  If unsure, say N.
+
+config HYMOFS_DEBUG
+	bool "Enable HymoFS debug logging"
+	depends on HYMOFS
+	default n
+	help
+	  Enable verbose debug logging for HymoFS operations.
+	  
+	  - High performance overhead (for debugging only)
+	  - Logs all hook invocations to kernel log
+	  
+	  MUST be disabled in production builds.
+	  If unsure, say N.
+
+endmenu
diff --git a/fs/Makefile b/fs/Makefile
index c6963a9a4..078dce1ef 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -22,6 +22,8 @@ obj-y :=	open.o read_write.o file_table.o super.o \
 		fs_types.o fs_context.o fs_parser.o fsopen.o init.o \
 		kernel_read_file.o mnt_idmapping.o remap_range.o
 
+obj-$(CONFIG_HYMOFS) += hymofs.o
+
 obj-$(CONFIG_BUFFER_HEAD)	+= buffer.o mpage.o
 obj-$(CONFIG_PROC_FS)		+= proc_namespace.o
 obj-$(CONFIG_LEGACY_DIRECT_IO)	+= direct-io.o
diff --git a/fs/d_path.c b/fs/d_path.c
index 5f4da5c8d..ebc740c70 100644
--- a/fs/d_path.c
+++ b/fs/d_path.c
@@ -8,6 +8,9 @@
 #include <linux/prefetch.h>
 #include "mount.h"
 #include "internal.h"
+#ifdef CONFIG_HYMOFS
+#include <linux/hymofs.h>
+#endif
 
 struct prepend_buffer {
 	char *buf;
@@ -235,6 +238,9 @@ char *d_absolute_path(const struct path *path,
 		return ERR_PTR(-EINVAL);
 	return extract_string(&b);
 }
+#ifdef CONFIG_HYMOFS
+EXPORT_SYMBOL(d_absolute_path);
+#endif
 
 static void get_fs_root_rcu(struct fs_struct *fs, struct path *root)
 {
@@ -291,7 +297,11 @@ char *d_path(const struct path *path, char *buf, int buflen)
 	prepend_path(path, &root, &b);
 	rcu_read_unlock();
 
+#ifdef CONFIG_HYMOFS_REVERSE_LOOKUP
+	return hymofs_process_d_path(extract_string(&b), buf, buflen);
+#else
 	return extract_string(&b);
+#endif
 }
 EXPORT_SYMBOL(d_path);
 
diff --git a/fs/hymofs.c b/fs/hymofs.c
new file mode 100644
index 000000000..d7dfd9996
--- /dev/null
+++ b/fs/hymofs.c
@@ -0,0 +1,2422 @@
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/file.h>
+#include <linux/fdtable.h>
+#include <linux/fsnotify.h>
+#include <linux/tty.h>
+#include <linux/namei.h>
+#include <linux/backing-dev.h>
+#include <linux/capability.h>
+#include <linux/securebits.h>
+#include <linux/security.h>
+#include <linux/mount.h>
+#include <linux/fcntl.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/dcache.h>
+#include <linux/path.h>
+#include <linux/hashtable.h>
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/dirent.h>
+#include <linux/cred.h>
+#include <linux/uidgid.h>
+#include <linux/vmalloc.h>
+#include <linux/spinlock.h>
+#include <linux/kernel.h>
+#include <linux/mnt_namespace.h>
+#include <linux/nsproxy.h>
+#include <linux/sched.h>
+#include <linux/fs_struct.h>
+#include <linux/sched/task.h>
+#include <linux/xattr.h>
+#include <linux/rcupdate.h>
+#include <linux/utsname.h>
+#include <linux/export.h>
+#include <linux/miscdevice.h>
+#include <linux/anon_inodes.h>
+#include <linux/jhash.h>
+#include "mount.h"
+
+#include <linux/hymofs.h>
+#include <linux/hymo_magic.h>
+
+#ifdef CONFIG_HYMOFS
+
+/* HymoFS - Advanced Path Manipulation and Hiding */
+/* Increased hash bits to reduce collisions with large number of rules */
+#define HYMO_HASH_BITS 12
+
+struct hymo_linux_dirent {
+	unsigned long	d_ino;
+	unsigned long	d_off;
+	unsigned short	d_reclen;
+	char		d_name[];
+};
+
+struct hymo_entry {
+    char *src;
+    char *target;
+    unsigned char type;
+    struct hlist_node node;
+    struct hlist_node target_node;
+    struct rcu_head rcu;
+};
+struct hymo_hide_entry {
+    char *path;
+    struct hlist_node node;
+    struct rcu_head rcu;
+};
+
+struct hymo_inject_entry {
+    char *dir;
+    struct hlist_node node;
+    struct rcu_head rcu;
+};
+
+struct hymo_xattr_sb_entry {
+    struct super_block *sb;
+    struct hlist_node node;
+    struct rcu_head rcu;
+};
+
+struct hymo_merge_entry {
+    char *src;
+    char *target;
+    struct hlist_node node;
+    struct rcu_head rcu;
+};
+
+static DEFINE_HASHTABLE(hymo_paths, HYMO_HASH_BITS);
+static DEFINE_HASHTABLE(hymo_targets, HYMO_HASH_BITS);
+static DEFINE_HASHTABLE(hymo_hide_paths, HYMO_HASH_BITS);
+static DEFINE_HASHTABLE(hymo_inject_dirs, HYMO_HASH_BITS);
+static DEFINE_HASHTABLE(hymo_xattr_sbs, HYMO_HASH_BITS);
+static DEFINE_HASHTABLE(hymo_merge_dirs, HYMO_HASH_BITS);
+static DEFINE_SPINLOCK(hymo_lock);
+bool hymofs_enabled = false;
+EXPORT_SYMBOL(hymofs_enabled);
+
+/* Use HYMO_BLOOM_BITS from hymofs.h to avoid redefinition */
+static DECLARE_BITMAP(hymo_path_bloom, HYMO_BLOOM_SIZE);
+static atomic_t hymo_rule_count = ATOMIC_INIT(0);
+
+static bool hymo_debug_enabled = false;
+module_param(hymo_debug_enabled, bool, 0644);
+MODULE_PARM_DESC(hymo_debug_enabled, "Enable debug logging");
+static bool hymo_stealth_enabled = true;
+
+static char hymo_mirror_path_buf[PATH_MAX] = HYMO_DEFAULT_MIRROR_PATH;
+static char hymo_mirror_name_buf[NAME_MAX] = HYMO_DEFAULT_MIRROR_NAME;
+static char *hymo_current_mirror_path = hymo_mirror_path_buf;
+static char *hymo_current_mirror_name = hymo_mirror_name_buf;
+
+#define hymo_log(fmt, ...) do { \
+    if (hymo_debug_enabled) \
+        printk(KERN_INFO "hymofs: " fmt, ##__VA_ARGS__); \
+} while(0)
+
+/* Performance statistics */
+struct hymofs_stats {
+    atomic64_t total_checks;
+    atomic64_t fast_path_skips;
+    atomic64_t bloom_rejects;
+    atomic64_t rule_hits;
+};
+
+static struct hymofs_stats hymo_stats = {
+    .total_checks = ATOMIC64_INIT(0),
+    .fast_path_skips = ATOMIC64_INIT(0),
+    .bloom_rejects = ATOMIC64_INIT(0),
+    .rule_hits = ATOMIC64_INIT(0),
+};
+
+static struct hymo_uname_info {
+	char sysname[65];
+	char nodename[65];
+	char release[65];
+	char version[65];
+	char machine[65];
+	char domainname[65];
+} hymo_uname_info = { 0 };
+
+static DEFINE_SPINLOCK(hymo_uname_lock);
+
+/* RCU callback functions for deferred free */
+static void hymo_entry_free_rcu(struct rcu_head *head)
+{
+    struct hymo_entry *e = container_of(head, struct hymo_entry, rcu);
+    kfree(e->src);
+    kfree(e->target);
+    kfree(e);
+}
+
+static void hymo_hide_entry_free_rcu(struct rcu_head *head)
+{
+    struct hymo_hide_entry *e = container_of(head, struct hymo_hide_entry, rcu);
+    kfree(e->path);
+    kfree(e);
+}
+
+static void hymo_inject_entry_free_rcu(struct rcu_head *head)
+{
+    struct hymo_inject_entry *e = container_of(head, struct hymo_inject_entry, rcu);
+    kfree(e->dir);
+    kfree(e);
+}
+
+static void hymo_xattr_sb_entry_free_rcu(struct rcu_head *head)
+{
+    struct hymo_xattr_sb_entry *e = container_of(head, struct hymo_xattr_sb_entry, rcu);
+    kfree(e);
+}
+
+static void hymo_merge_entry_free_rcu(struct rcu_head *head)
+{
+    struct hymo_merge_entry *e = container_of(head, struct hymo_merge_entry, rcu);
+    kfree(e->src);
+    kfree(e->target);
+    kfree(e);
+}
+
+static inline void hymofs_mark_inode_hidden(struct inode *inode)
+{
+    if (inode && inode->i_mapping) {
+        set_bit(AS_FLAGS_HYMO_HIDE, &inode->i_mapping->flags);
+    }
+}
+
+static inline void hymofs_unmark_inode_hidden(struct inode *inode)
+{
+    if (inode && inode->i_mapping) {
+        clear_bit(AS_FLAGS_HYMO_HIDE, &inode->i_mapping->flags);
+    }
+}
+
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+bool __hymofs_is_inode_hidden(struct inode *inode)
+{
+    return test_bit(AS_FLAGS_HYMO_HIDE, &inode->i_mapping->flags);
+}
+EXPORT_SYMBOL(__hymofs_is_inode_hidden);
+#endif
+
+static void hymo_cleanup_locked(void) {
+    struct hymo_entry *entry;
+    struct hymo_hide_entry *hide_entry;
+    struct hymo_inject_entry *inject_entry;
+    struct hymo_xattr_sb_entry *sb_entry;
+    struct hymo_merge_entry *merge_entry;
+    struct hlist_node *tmp;
+    int bkt;
+    
+    /* Mark entries for RCU deletion - actual freeing happens after grace period */
+    hash_for_each_safe(hymo_paths, bkt, tmp, entry, node) {
+        hlist_del_rcu(&entry->node);
+        hlist_del_rcu(&entry->target_node);
+        call_rcu(&entry->rcu, hymo_entry_free_rcu);
+    }
+    hash_for_each_safe(hymo_hide_paths, bkt, tmp, hide_entry, node) {
+        hlist_del_rcu(&hide_entry->node);
+        call_rcu(&hide_entry->rcu, hymo_hide_entry_free_rcu);
+    }
+    hash_for_each_safe(hymo_inject_dirs, bkt, tmp, inject_entry, node) {
+        hlist_del_rcu(&inject_entry->node);
+        call_rcu(&inject_entry->rcu, hymo_inject_entry_free_rcu);
+    }
+    hash_for_each_safe(hymo_xattr_sbs, bkt, tmp, sb_entry, node) {
+        hlist_del_rcu(&sb_entry->node);
+        call_rcu(&sb_entry->rcu, hymo_xattr_sb_entry_free_rcu);
+    }
+    hash_for_each_safe(hymo_merge_dirs, bkt, tmp, merge_entry, node) {
+        hlist_del_rcu(&merge_entry->node);
+        call_rcu(&merge_entry->rcu, hymo_merge_entry_free_rcu);
+    }
+    
+    bitmap_zero(hymo_path_bloom, HYMO_BLOOM_SIZE);
+    atomic_set(&hymo_rule_count, 0);
+}
+
+/* Forward declaration for ioctl handler */
+static long hymo_anon_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+
+/* Anonymous file operations for HymoFS fd */
+static const struct file_operations hymo_anon_fops = {
+    .owner          = THIS_MODULE,
+    .unlocked_ioctl = hymo_anon_ioctl,
+    .compat_ioctl   = hymo_anon_ioctl,
+    .llseek         = noop_llseek,
+};
+
+static void hymofs_add_inject_rule(char *dir)
+{
+    struct hymo_inject_entry *inject_entry;
+    u32 hash;
+    bool found = false;
+
+    if (!dir) return;
+
+    hash = full_name_hash(NULL, dir, strlen(dir));
+    hlist_for_each_entry(inject_entry, &hymo_inject_dirs[hash_min(hash, HYMO_HASH_BITS)], node) {
+        if (strcmp(inject_entry->dir, dir) == 0) {
+            found = true;
+            break;
+        }
+    }
+    if (!found) {
+        inject_entry = kmalloc(sizeof(*inject_entry), GFP_ATOMIC);
+        if (inject_entry) {
+            inject_entry->dir = dir;
+            hlist_add_head_rcu(&inject_entry->node, &hymo_inject_dirs[hash_min(hash, HYMO_HASH_BITS)]);
+            atomic_inc(&hymo_rule_count);
+            hymo_log("auto-inject parent: %s\n", dir);
+        } else {
+            kfree(dir);
+        }
+    } else {
+        kfree(dir);
+    }
+}
+
+static void hymofs_reorder_mnt_id(void)
+{
+    struct mnt_namespace *ns = current->nsproxy->mnt_ns;
+    struct mount *m;
+    int id = 1;
+    bool is_hymo_mount;
+    
+    // Try to find the starting ID from the first mount
+    if (ns && !list_empty(&ns->list)) {
+        struct mount *first = list_first_entry(&ns->list, struct mount, mnt_list);
+        if (first->mnt_id < 500000) id = first->mnt_id;
+    }
+
+    if (!ns) return;
+
+    list_for_each_entry(m, &ns->list, mnt_list) {
+        is_hymo_mount = false;
+        
+        if (m->mnt_devname && (
+            strcmp(m->mnt_devname, hymo_current_mirror_path) == 0 || 
+            strcmp(m->mnt_devname, hymo_current_mirror_name) == 0
+        )) {
+            is_hymo_mount = true;
+        }
+
+        if (is_hymo_mount && hymo_stealth_enabled) {
+            if (m->mnt_id < 500000) {
+                WRITE_ONCE(m->mnt_id, 500000 + (id % 1000));
+            }
+        } else {
+            if (m->mnt_id >= 500000) continue;
+            WRITE_ONCE(m->mnt_id, id++);
+        }
+    }
+}
+
+static void hymofs_spoof_mounts(void)
+{
+    struct mnt_namespace *ns = current->nsproxy->mnt_ns;
+    struct mount *m;
+    char *system_devname = NULL;
+    struct path sys_path;
+
+    if (!ns) return;
+    if (!hymo_stealth_enabled) return;
+
+    if (kern_path("/system", LOOKUP_FOLLOW, &sys_path) == 0) {
+        struct mount *sys_mnt = real_mount(sys_path.mnt);
+        if (sys_mnt && sys_mnt->mnt_devname) {
+            system_devname = kstrdup(sys_mnt->mnt_devname, GFP_KERNEL);
+        }
+        path_put(&sys_path);
+    }
+    
+    if (!system_devname) {
+        if (kern_path("/", LOOKUP_FOLLOW, &sys_path) == 0) {
+            struct mount *sys_mnt = real_mount(sys_path.mnt);
+            if (sys_mnt && sys_mnt->mnt_devname) {
+                system_devname = kstrdup(sys_mnt->mnt_devname, GFP_KERNEL);
+            }
+            path_put(&sys_path);
+        }
+    }
+
+    if (!system_devname) return;
+
+    list_for_each_entry(m, &ns->list, mnt_list) {
+        if (m->mnt_devname && (
+            strcmp(m->mnt_devname, hymo_current_mirror_path) == 0 || 
+            strcmp(m->mnt_devname, hymo_current_mirror_name) == 0
+        )) {
+            const char *old_name = m->mnt_devname;
+            m->mnt_devname = kstrdup(system_devname, GFP_KERNEL);
+            if (m->mnt_devname) {
+                kfree_const(old_name);
+            } else {
+                m->mnt_devname = old_name;
+            }
+        }
+    }
+    kfree(system_devname);
+}
+
+int hymo_dispatch_cmd(unsigned int cmd, void __user *arg) {
+    struct hymo_syscall_arg req;
+    struct hymo_entry *entry;
+    struct hymo_hide_entry *hide_entry;
+    struct hymo_inject_entry *inject_entry;
+    char *src = NULL, *target = NULL;
+    u32 hash;
+    bool found = false;
+    int ret = 0;
+
+    if (cmd == HYMO_CMD_CLEAR_ALL) {
+        spin_lock(&hymo_lock);
+        hymo_cleanup_locked();
+        strscpy(hymo_mirror_path_buf, HYMO_DEFAULT_MIRROR_PATH, PATH_MAX);
+        strscpy(hymo_mirror_name_buf, HYMO_DEFAULT_MIRROR_NAME, NAME_MAX);
+        hymo_current_mirror_path = hymo_mirror_path_buf;
+        hymo_current_mirror_name = hymo_mirror_name_buf;
+        hymofs_enabled = false;
+        spin_unlock(&hymo_lock);
+        rcu_barrier();
+        return 0;
+    }
+    
+    if (cmd == HYMO_CMD_GET_VERSION) {
+        return HYMO_PROTOCOL_VERSION;
+    }
+
+    if (cmd == HYMO_CMD_SET_DEBUG) {
+        int val;
+        if (copy_from_user(&val, arg, sizeof(val))) return -EFAULT;
+        hymo_debug_enabled = !!val;
+        hymo_log("debug mode %s\n", hymo_debug_enabled ? "enabled" : "disabled");
+        return 0;
+    }
+
+    if (cmd == HYMO_CMD_REORDER_MNT_ID) {
+        hymofs_spoof_mounts();
+        hymofs_reorder_mnt_id();
+        return 0;
+    }
+
+    if (cmd == HYMO_CMD_SET_STEALTH) {
+        int val;
+        if (copy_from_user(&val, arg, sizeof(val))) return -EFAULT;
+        hymo_stealth_enabled = !!val;
+        hymo_log("stealth mode %s\n", hymo_stealth_enabled ? "enabled" : "disabled");
+        if (hymo_stealth_enabled) {
+            hymofs_spoof_mounts();
+            hymofs_reorder_mnt_id();
+        }
+        return 0;
+    }
+
+    if (cmd == HYMO_CMD_SET_ENABLED) {
+        int val;
+        if (copy_from_user(&val, arg, sizeof(val))) return -EFAULT;
+        spin_lock(&hymo_lock);
+        hymofs_enabled = !!val;
+        spin_unlock(&hymo_lock);
+        hymo_log("HymoFS %s\n", hymofs_enabled ? "enabled" : "disabled");
+        return 0;
+    }
+
+    if (cmd == HYMO_CMD_GET_FD) {
+        /* Return anonymous fd - the ONLY way to access HymoFS */
+        int fd;
+        if (!uid_eq(current_uid(), GLOBAL_ROOT_UID)) {
+            return -EPERM;
+        }
+        fd = anon_inode_getfd("hymo", &hymo_anon_fops, NULL, O_RDWR | O_CLOEXEC);
+        if (fd < 0) {
+            return fd;
+        }
+        return fd;  /* Return fd directly */
+    }
+
+    /* LIST_RULES uses a different struct, handle it separately */
+    if (cmd == HYMO_CMD_LIST_RULES) {
+        struct hymo_syscall_list_arg list_arg;
+        char *kbuf;
+        size_t buf_size;
+        size_t written = 0;
+        int bkt;
+        struct hymo_xattr_sb_entry *sb_entry;
+        struct hymo_merge_entry *merge_entry;
+
+        if (copy_from_user(&list_arg, (void __user *)arg, sizeof(list_arg))) {
+            return -EFAULT;
+        }
+
+        buf_size = list_arg.size;
+        if (buf_size > 16 * 1024) buf_size = 16 * 1024;
+        
+        kbuf = kzalloc(buf_size, GFP_KERNEL);
+        if (!kbuf) {
+            return -ENOMEM;
+        }
+
+        rcu_read_lock();
+        
+        written += scnprintf(kbuf + written, buf_size - written, "HymoFS Protocol: %d\n", HYMO_PROTOCOL_VERSION);
+        written += scnprintf(kbuf + written, buf_size - written, "HymoFS Enabled: %d\n", hymofs_enabled ? 1 : 0);
+
+        hash_for_each_rcu(hymo_paths, bkt, entry, node) {
+            if (written >= buf_size) break;
+            written += scnprintf(kbuf + written, buf_size - written, "add %s %s %d\n", entry->src, entry->target, entry->type);
+        }
+        hash_for_each_rcu(hymo_hide_paths, bkt, hide_entry, node) {
+            if (written >= buf_size) break;
+            written += scnprintf(kbuf + written, buf_size - written, "hide %s\n", hide_entry->path);
+        }
+        hash_for_each_rcu(hymo_inject_dirs, bkt, inject_entry, node) {
+            if (written >= buf_size) break;
+            written += scnprintf(kbuf + written, buf_size - written, "inject %s\n", inject_entry->dir);
+        }
+        hash_for_each_rcu(hymo_merge_dirs, bkt, merge_entry, node) {
+            if (written >= buf_size) break;
+            written += scnprintf(kbuf + written, buf_size - written, "merge %s %s\n", merge_entry->src, merge_entry->target);
+        }
+        hash_for_each_rcu(hymo_xattr_sbs, bkt, sb_entry, node) {
+            if (written >= buf_size) break;
+            written += scnprintf(kbuf + written, buf_size - written, "hide_xattr_sb %p\n", sb_entry->sb);
+        }
+        rcu_read_unlock();
+
+        if (copy_to_user(list_arg.buf, kbuf, written)) {
+            kfree(kbuf);
+            return -EFAULT;
+        }
+        list_arg.size = written;
+        if (copy_to_user((void __user *)arg, &list_arg, sizeof(list_arg))) {
+            kfree(kbuf);
+            return -EFAULT;
+        }
+        
+        kfree(kbuf);
+        return 0;
+    }
+
+    if (cmd == HYMO_CMD_SET_UNAME) {
+#ifdef CONFIG_HYMOFS_UNAME_SPOOF
+        struct hymo_uname_info u_info;
+
+        if (copy_from_user(&u_info, arg, sizeof(u_info)))
+            return -EFAULT;
+
+        spin_lock(&hymo_uname_lock);
+        memcpy(&hymo_uname_info, &u_info, sizeof(u_info));
+        spin_unlock(&hymo_uname_lock);
+        return 0;
+#else
+        return -EOPNOTSUPP;
+#endif
+    }
+
+    if (copy_from_user(&req, arg, sizeof(req))) return -EFAULT;
+
+    if (cmd == HYMO_CMD_SET_MIRROR_PATH) {
+        char *new_path = NULL;
+        char *new_name = NULL;
+        
+        if (req.src) {
+            new_path = strndup_user(req.src, PATH_MAX);
+            if (IS_ERR(new_path)) return PTR_ERR(new_path);
+        } else {
+            return -EINVAL;
+        }
+
+        hymo_log("setting mirror path to: %s\n", new_path);
+
+        /* Strip trailing slash if present */
+        size_t len = strlen(new_path);
+        if (len > 1 && new_path[len - 1] == '/') {
+            new_path[len - 1] = '\0';
+        }
+
+        char *slash = strrchr(new_path, '/');
+        if (slash) {
+            new_name = kstrdup(slash + 1, GFP_KERNEL);
+        } else {
+            new_name = kstrdup(new_path, GFP_KERNEL);
+        }
+
+        if (!new_name) {
+            kfree(new_path);
+            return -ENOMEM;
+        }
+
+        spin_lock(&hymo_lock);
+        strscpy(hymo_mirror_path_buf, new_path, PATH_MAX);
+        strscpy(hymo_mirror_name_buf, new_name, NAME_MAX);
+        hymo_current_mirror_path = hymo_mirror_path_buf;
+        hymo_current_mirror_name = hymo_mirror_name_buf;
+        spin_unlock(&hymo_lock);
+
+        kfree(new_path);
+        kfree(new_name);
+        return 0;
+    }
+
+    if (req.src) {
+        src = strndup_user(req.src, PAGE_SIZE);
+        if (IS_ERR(src)) return PTR_ERR(src);
+    }
+    if (req.target) {
+        target = strndup_user(req.target, PAGE_SIZE);
+        if (IS_ERR(target)) {
+            kfree(src);
+            return PTR_ERR(target);
+        }
+    }
+
+    switch (cmd) {
+        case HYMO_CMD_ADD_MERGE_RULE: {
+            struct hymo_merge_entry *merge_entry;
+            if (!src || !target) { ret = -EINVAL; break; }
+            
+            hymo_log("add merge rule: src=%s, target=%s\n", src, target);
+            
+            hash = full_name_hash(NULL, src, strlen(src));
+            spin_lock(&hymo_lock);
+            
+            hlist_for_each_entry(merge_entry, &hymo_merge_dirs[hash_min(hash, HYMO_HASH_BITS)], node) {
+                if (strcmp(merge_entry->src, src) == 0 && strcmp(merge_entry->target, target) == 0) {
+                    found = true;
+                    break;
+                }
+            }
+            
+            if (!found) {
+                merge_entry = kmalloc(sizeof(*merge_entry), GFP_ATOMIC);
+                if (merge_entry) {
+                    merge_entry->src = src;
+                    merge_entry->target = target;
+                    hlist_add_head_rcu(&merge_entry->node, &hymo_merge_dirs[hash_min(hash, HYMO_HASH_BITS)]);
+                    
+                    {
+                        struct hymo_inject_entry *inj;
+                        bool inj_found = false;
+                        hlist_for_each_entry(inj, &hymo_inject_dirs[hash_min(hash, HYMO_HASH_BITS)], node) {
+                            if (strcmp(inj->dir, src) == 0) {
+                                inj_found = true;
+                                break;
+                            }
+                        }
+                        if (!inj_found) {
+                            inj = kmalloc(sizeof(*inj), GFP_ATOMIC);
+                            if (inj) {
+                                inj->dir = kstrdup(src, GFP_ATOMIC);
+                                if (inj->dir) hlist_add_head_rcu(&inj->node, &hymo_inject_dirs[hash_min(hash, HYMO_HASH_BITS)]);
+                                else kfree(inj);
+                            }
+                        }
+                    }
+                    
+                    src = NULL;
+                    target = NULL;
+                    hymofs_add_inject_rule(kstrdup(merge_entry->src, GFP_ATOMIC));
+                } else {
+                    ret = -ENOMEM;
+                }
+            } else {
+                ret = -EEXIST;
+            }
+            hymofs_enabled = true;
+            spin_unlock(&hymo_lock);
+            break;
+        }
+
+        case HYMO_CMD_ADD_RULE: {
+            char *parent_dir = NULL;
+            char *resolved_src = NULL;
+            struct path path;
+            struct inode *src_inode = NULL;
+            struct inode *parent_inode = NULL;
+            char *tmp_buf = kmalloc(PATH_MAX, GFP_KERNEL);
+            
+            if (!src || !target) { 
+                kfree(tmp_buf);
+                ret = -EINVAL; 
+                break; 
+            }
+            if (!tmp_buf) { ret = -ENOMEM; break; }
+
+            hymo_log("add rule: src=%s, target=%s, type=%d\n", src, target, req.type);
+            
+            // 1. Try to resolve full path (if file exists)
+            if (kern_path(src, LOOKUP_FOLLOW, &path) == 0) {
+                char *res = d_path(&path, tmp_buf, PATH_MAX);
+                if (!IS_ERR(res)) {
+                    resolved_src = kstrdup(res, GFP_KERNEL);
+                    
+                    /* Always extract parent directory for injection, even if file exists */
+                    {
+                        char *last_slash = strrchr(res, '/');
+                        if (last_slash) {
+                            if (last_slash == res) {
+                                parent_dir = kstrdup("/", GFP_KERNEL);
+                            } else {
+                                size_t len = last_slash - res;
+                                parent_dir = kmalloc(len + 1, GFP_KERNEL);
+                                if (parent_dir) {
+                                    memcpy(parent_dir, res, len);
+                                    parent_dir[len] = '\0';
+                                }
+                            }
+                        }
+                    }
+                }
+                /* Get inode reference for marking (hide source in filldir) */
+                if (d_inode(path.dentry)) {
+                    src_inode = d_inode(path.dentry);
+                    ihold(src_inode);
+                }
+                if (path.dentry->d_parent && d_inode(path.dentry->d_parent)) {
+                    parent_inode = d_inode(path.dentry->d_parent);
+                    ihold(parent_inode);
+                }
+                path_put(&path);
+            } else {
+                char *last_slash = strrchr(src, '/');
+                if (last_slash && last_slash != src) {
+                    size_t len = last_slash - src;
+                    char *p_str = kmalloc(len + 1, GFP_KERNEL);
+                    if (p_str) {
+                        memcpy(p_str, src, len);
+                        p_str[len] = '\0';
+                        
+                        if (kern_path(p_str, LOOKUP_FOLLOW, &path) == 0) {
+                            char *res = d_path(&path, tmp_buf, PATH_MAX);
+                            if (!IS_ERR(res)) {
+                                size_t res_len = strlen(res);
+                                size_t name_len = strlen(last_slash);
+                                resolved_src = kmalloc(res_len + name_len + 1, GFP_KERNEL);
+                                if (resolved_src) {
+                                    strcpy(resolved_src, res);
+                                    strcat(resolved_src, last_slash);
+                                }
+                                parent_dir = kstrdup(res, GFP_KERNEL);
+                            }
+                            path_put(&path);
+                        }
+                        kfree(p_str);
+                    }
+                }
+            }
+            
+            kfree(tmp_buf);
+
+            if (resolved_src) {
+                kfree(src);
+                src = resolved_src;
+            }
+
+            hash = full_name_hash(NULL, src, strlen(src));
+            spin_lock(&hymo_lock);
+
+            {
+                hlist_for_each_entry(entry, &hymo_paths[hash_min(hash, HYMO_HASH_BITS)], node) {
+                    if (strcmp(entry->src, src) == 0) {
+                        /* Update existing entry - need RCU-safe update */
+                        char *old_target = entry->target;
+                        char *new_target = kstrdup(target, GFP_ATOMIC);
+                        if (new_target) {
+                            hlist_del_rcu(&entry->target_node);
+                            rcu_assign_pointer(entry->target, new_target);
+                            entry->type = req.type;
+                            hlist_add_head_rcu(&entry->target_node, &hymo_targets[hash_min(full_name_hash(NULL, new_target, strlen(new_target)), HYMO_HASH_BITS)]);
+                            /* Free old target after grace period - use kfree_rcu if available, else synchronize */
+                            kfree(old_target);
+                        }
+                        found = true;
+                        break;
+                    }
+                }
+                if (!found) {
+                    entry = kmalloc(sizeof(*entry), GFP_ATOMIC);
+                    if (entry) {
+                        entry->src = kstrdup(src, GFP_ATOMIC);
+                        entry->target = kstrdup(target, GFP_ATOMIC);
+                        entry->type = req.type;
+                        if (entry->src && entry->target) {
+                            unsigned long h1, h2;
+                            hlist_add_head_rcu(&entry->node, &hymo_paths[hash_min(hash, HYMO_HASH_BITS)]);
+                            hlist_add_head_rcu(&entry->target_node, &hymo_targets[hash_min(full_name_hash(NULL, entry->target, strlen(entry->target)), HYMO_HASH_BITS)]);
+                            
+                            h1 = jhash(src, strlen(src), 0) & (HYMO_BLOOM_SIZE - 1);
+                            h2 = jhash(src, strlen(src), 1) & (HYMO_BLOOM_SIZE - 1);
+                            set_bit(h1, hymo_path_bloom);
+                            set_bit(h2, hymo_path_bloom);
+                            atomic_inc(&hymo_rule_count);
+                        } else {
+                            kfree(entry->src);
+                            kfree(entry->target);
+                            kfree(entry);
+                        }
+                    }
+                }
+            }
+
+            if (parent_dir) {
+                hymofs_add_inject_rule(parent_dir);
+            }
+
+            if (src_inode) {
+                hymofs_mark_inode_hidden(src_inode);
+                iput(src_inode);
+            }
+
+            if (parent_inode) {
+                if (parent_inode->i_mapping) {
+                    set_bit(AS_FLAGS_HYMO_DIR_HAS_HIDDEN, &parent_inode->i_mapping->flags);
+                }
+                iput(parent_inode);
+            }
+
+            hymofs_enabled = true;
+            spin_unlock(&hymo_lock);
+            break;
+        }
+
+        case HYMO_CMD_HIDE_RULE: {
+            char *resolved_src = NULL;
+            struct path path;
+            struct inode *target_inode = NULL;
+            struct inode *parent_inode = NULL;
+            char *tmp_buf = kmalloc(PATH_MAX, GFP_KERNEL);
+
+            if (!src) { 
+                kfree(tmp_buf);
+                ret = -EINVAL; 
+                break; 
+            }
+            if (!tmp_buf) { ret = -ENOMEM; break; }
+
+            hymo_log("hide rule: src=%s\n", src);
+
+            if (kern_path(src, LOOKUP_FOLLOW, &path) == 0) {
+                char *res = d_path(&path, tmp_buf, PATH_MAX);
+                if (!IS_ERR(res)) {
+                    resolved_src = kstrdup(res, GFP_KERNEL);
+                }
+                /* Get inode reference for marking */
+                if (d_inode(path.dentry)) {
+                    target_inode = d_inode(path.dentry);
+                    ihold(target_inode);  /* Hold reference */
+                }
+                /* Also get parent directory inode */
+                if (path.dentry->d_parent && d_inode(path.dentry->d_parent)) {
+                    parent_inode = d_inode(path.dentry->d_parent);
+                    ihold(parent_inode);
+                }
+                path_put(&path);
+            }
+            kfree(tmp_buf);
+
+            if (resolved_src) {
+                kfree(src);
+                src = resolved_src;
+            }
+
+            if (target_inode) {
+                hymofs_mark_inode_hidden(target_inode);
+                iput(target_inode);
+            }
+
+            if (parent_inode) {
+                if (parent_inode->i_mapping) {
+                    set_bit(AS_FLAGS_HYMO_DIR_HAS_HIDDEN, &parent_inode->i_mapping->flags);
+                }
+                iput(parent_inode);
+            }
+
+            hash = full_name_hash(NULL, src, strlen(src));
+            spin_lock(&hymo_lock);
+            hlist_for_each_entry(hide_entry, &hymo_hide_paths[hash_min(hash, HYMO_HASH_BITS)], node) {
+                if (strcmp(hide_entry->path, src) == 0) {
+                    found = true;
+                    break;
+                }
+            }
+            if (!found) {
+                hide_entry = kmalloc(sizeof(*hide_entry), GFP_ATOMIC);
+                if (hide_entry) {
+                    hide_entry->path = kstrdup(src, GFP_ATOMIC);
+                    if (hide_entry->path)
+                        hlist_add_head_rcu(&hide_entry->node, &hymo_hide_paths[hash_min(hash, HYMO_HASH_BITS)]);
+                    else
+                        kfree(hide_entry);
+                }
+            }
+            hymofs_enabled = true;
+            spin_unlock(&hymo_lock);
+            break;
+        }
+
+        case HYMO_CMD_HIDE_OVERLAY_XATTRS: {
+            struct path path;
+            struct hymo_xattr_sb_entry *sb_entry;
+            bool found = false;
+            
+            if (!src) { ret = -EINVAL; break; }
+            
+            if (kern_path(src, LOOKUP_FOLLOW, &path) == 0) {
+                struct super_block *sb = path.dentry->d_sb;
+                
+                spin_lock(&hymo_lock);
+                hlist_for_each_entry(sb_entry, &hymo_xattr_sbs[hash_min((unsigned long)sb, HYMO_HASH_BITS)], node) {
+                    if (sb_entry->sb == sb) {
+                        found = true;
+                        break;
+                    }
+                }
+                if (!found) {
+                    sb_entry = kmalloc(sizeof(*sb_entry), GFP_ATOMIC);
+                    if (sb_entry) {
+                        sb_entry->sb = sb;
+                        hlist_add_head_rcu(&sb_entry->node, &hymo_xattr_sbs[hash_min((unsigned long)sb, HYMO_HASH_BITS)]);
+                        hymo_log("hide xattrs for sb %p (path: %s)\n", sb, src);
+                    }
+                }
+                hymofs_enabled = true;
+                spin_unlock(&hymo_lock);
+                path_put(&path);
+            } else {
+                ret = -ENOENT;
+            }
+            break;
+        }
+
+        case HYMO_CMD_DEL_RULE:
+            if (!src) { ret = -EINVAL; break; }
+            hymo_log("del rule: src=%s\n", src);
+            hash = full_name_hash(NULL, src, strlen(src));
+            spin_lock(&hymo_lock);
+            
+            hlist_for_each_entry(entry, &hymo_paths[hash_min(hash, HYMO_HASH_BITS)], node) {
+                if (strcmp(entry->src, src) == 0) {
+                    hlist_del_rcu(&entry->node);
+                    hlist_del_rcu(&entry->target_node);
+                    call_rcu(&entry->rcu, hymo_entry_free_rcu);
+                    goto out_delete;
+                }
+            }
+            hlist_for_each_entry(hide_entry, &hymo_hide_paths[hash_min(hash, HYMO_HASH_BITS)], node) {
+                if (strcmp(hide_entry->path, src) == 0) {
+                    hlist_del_rcu(&hide_entry->node);
+                    call_rcu(&hide_entry->rcu, hymo_hide_entry_free_rcu);
+                    goto out_delete;
+                }
+            }
+            hlist_for_each_entry(inject_entry, &hymo_inject_dirs[hash_min(hash, HYMO_HASH_BITS)], node) {
+                if (strcmp(inject_entry->dir, src) == 0) {
+                    hlist_del_rcu(&inject_entry->node);
+                    call_rcu(&inject_entry->rcu, hymo_inject_entry_free_rcu);
+                    goto out_delete;
+                }
+            }
+    out_delete:
+            hymofs_enabled = true;
+            spin_unlock(&hymo_lock);
+            break;
+
+        case HYMO_CMD_REORDER_MNT_ID:
+            hymo_log("reordering mount IDs\n");
+            hymofs_reorder_mnt_id();
+            break;
+
+        default:
+            ret = -EINVAL;
+            break;
+    }
+
+    kfree(src);
+    kfree(target);
+    return ret;
+}
+
+static long hymo_anon_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+    /* All ioctl commands directly dispatch to hymo_dispatch_cmd */
+    if (cmd == HYMO_IOC_GET_VERSION) {
+        int version = HYMO_PROTOCOL_VERSION;
+        if (copy_to_user((void __user *)arg, &version, sizeof(version)))
+            return -EFAULT;
+        return 0;
+    }
+
+    if (cmd == HYMO_IOC_SET_ENABLED) {
+        int enabled;
+        if (copy_from_user(&enabled, (void __user *)arg, sizeof(enabled)))
+            return -EFAULT;
+        spin_lock(&hymo_lock);
+        hymofs_enabled = enabled ? true : false;
+        spin_unlock(&hymo_lock);
+        return 0;
+    }
+
+    /* Map ioctl to internal command and dispatch */
+    switch (cmd) {
+    case HYMO_IOC_ADD_RULE:
+        return hymo_dispatch_cmd(HYMO_CMD_ADD_RULE, (void __user *)arg);
+    case HYMO_IOC_DEL_RULE:
+        return hymo_dispatch_cmd(HYMO_CMD_DEL_RULE, (void __user *)arg);
+    case HYMO_IOC_HIDE_RULE:
+        return hymo_dispatch_cmd(HYMO_CMD_HIDE_RULE, (void __user *)arg);
+    case HYMO_IOC_CLEAR_ALL:
+        return hymo_dispatch_cmd(HYMO_CMD_CLEAR_ALL, (void __user *)arg);
+    case HYMO_IOC_LIST_RULES:
+        return hymo_dispatch_cmd(HYMO_CMD_LIST_RULES, (void __user *)arg);
+    case HYMO_IOC_SET_DEBUG:
+        return hymo_dispatch_cmd(HYMO_CMD_SET_DEBUG, (void __user *)arg);
+    case HYMO_IOC_REORDER_MNT_ID:
+        return hymo_dispatch_cmd(HYMO_CMD_REORDER_MNT_ID, (void __user *)arg);
+    case HYMO_IOC_SET_STEALTH:
+        return hymo_dispatch_cmd(HYMO_CMD_SET_STEALTH, (void __user *)arg);
+    case HYMO_IOC_HIDE_OVERLAY_XATTRS:
+        return hymo_dispatch_cmd(HYMO_CMD_HIDE_OVERLAY_XATTRS, (void __user *)arg);
+    case HYMO_IOC_ADD_MERGE_RULE:
+        return hymo_dispatch_cmd(HYMO_CMD_ADD_MERGE_RULE, (void __user *)arg);
+    case HYMO_IOC_SET_MIRROR_PATH:
+        return hymo_dispatch_cmd(HYMO_CMD_SET_MIRROR_PATH, (void __user *)arg);
+    case HYMO_IOC_SET_UNAME:
+        return hymo_dispatch_cmd(HYMO_CMD_SET_UNAME, (void __user *)arg);
+    default:
+        return -EINVAL;
+    }
+}
+
+static int __init hymofs_init(void)
+{
+    spin_lock_init(&hymo_lock);
+    hash_init(hymo_paths);
+    hash_init(hymo_targets);
+    hash_init(hymo_hide_paths);
+    hash_init(hymo_inject_dirs);
+    hash_init(hymo_xattr_sbs);
+    
+    if (hymo_dispatch_cmd_hook) {
+        pr_err("HymoFS: hook already set?\n");
+    } else {
+        hymo_dispatch_cmd_hook = hymo_dispatch_cmd;
+    }
+    
+    pr_info("HymoFS: initialized (Anonymous FD Mode Only)\n");
+    return 0;
+}
+fs_initcall(hymofs_init);
+
+#ifdef CONFIG_HYMOFS_FORWARD_REDIRECT
+char *__hymofs_resolve_target(const char *pathname)
+{
+    struct hymo_entry *entry;
+    struct hymo_merge_entry *merge_entry;
+    u32 hash;
+    char *target = NULL;
+    const char *p;
+    size_t path_len;
+    struct list_head candidates;
+    struct hymo_merge_target_node *cand, *tmp;
+
+    if (unlikely(!hymofs_enabled)) return NULL;
+    if (unlikely(!pathname)) return NULL;
+    
+    INIT_LIST_HEAD(&candidates);
+    path_len = strlen(pathname);
+    hash = full_name_hash(NULL, pathname, path_len);
+
+    rcu_read_lock();
+    hlist_for_each_entry_rcu(entry, &hymo_paths[hash_min(hash, HYMO_HASH_BITS)], node) {
+        if (unlikely(strcmp(entry->src, pathname) == 0)) {
+            target = kstrdup(entry->target, GFP_ATOMIC);
+            rcu_read_unlock();
+            return target;
+        }
+    }
+    
+    p = pathname + path_len;
+    while (p > pathname) {
+        while (p > pathname && *p != '/') p--;
+        if (p == pathname && *p != '/') break;
+        
+        size_t current_len = p - pathname;
+        if (current_len == 0) {
+            break;
+        }
+        
+        hash = full_name_hash(NULL, pathname, current_len);
+        hlist_for_each_entry_rcu(merge_entry, &hymo_merge_dirs[hash_min(hash, HYMO_HASH_BITS)], node) {
+            if (strlen(merge_entry->src) == current_len && 
+                strncmp(merge_entry->src, pathname, current_len) == 0) {
+                
+                const char *suffix = pathname + current_len;
+                if (suffix[0] == '\0' || strcmp(suffix, "/.") == 0 || strcmp(suffix, "/..") == 0) {
+                    continue;
+                }
+
+                size_t target_len = strlen(merge_entry->target);
+                size_t suffix_len = path_len - current_len;
+                
+                cand = kmalloc(sizeof(*cand), GFP_ATOMIC);
+                if (cand) {
+                    cand->target = kmalloc(target_len + suffix_len + 1, GFP_ATOMIC);
+                    if (cand->target) {
+                        strcpy(cand->target, merge_entry->target);
+                        strcat(cand->target, suffix);
+                        list_add_tail(&cand->list, &candidates);
+                    } else {
+                        kfree(cand);
+                    }
+                }
+            }
+        }
+
+        if (!list_empty(&candidates)) {
+            break;
+        }
+        
+        if (p > pathname) p--;
+    }
+    
+    rcu_read_unlock();
+    
+    list_for_each_entry_safe(cand, tmp, &candidates, list) {
+        if (!target) {
+            struct path p;
+            if (kern_path(cand->target, LOOKUP_FOLLOW, &p) == 0) {
+                path_put(&p);
+                target = cand->target; // Take ownership
+                cand->target = NULL;   // Prevent double free
+            }
+        }
+        
+        if (cand->target) kfree(cand->target);
+        kfree(cand);
+    }
+
+    return target;
+}
+EXPORT_SYMBOL(__hymofs_resolve_target);
+
+#endif /* CONFIG_HYMOFS_FORWARD_REDIRECT */
+
+#ifdef CONFIG_HYMOFS_REVERSE_LOOKUP
+/* Returns length of written string, or -1 if not found/error. Writes to buf. */
+int __hymofs_reverse_lookup(const char *pathname, char *buf, size_t buflen)
+{
+    struct hymo_entry *entry;
+    struct hymo_merge_entry *merge_entry;
+    u32 hash;
+    int bkt;
+    int ret = -1;
+
+    if (unlikely(!hymofs_enabled)) return -1;
+    if (unlikely(!pathname || !buf)) return -1;
+
+    hash = full_name_hash(NULL, pathname, strlen(pathname));
+
+    rcu_read_lock();
+    
+    /* Check 1-to-1 mappings */
+    hlist_for_each_entry_rcu(entry, &hymo_targets[hash_min(hash, HYMO_HASH_BITS)], target_node) {
+        if (strcmp(entry->target, pathname) == 0) {
+            if (strscpy(buf, entry->src, buflen) < 0) ret = -ENAMETOOLONG;
+            else ret = strlen(buf);
+            goto out;
+        }
+    }
+
+    hash_for_each_rcu(hymo_merge_dirs, bkt, merge_entry, node) {
+        size_t target_len = strlen(merge_entry->target);
+        if (strncmp(pathname, merge_entry->target, target_len) == 0) {
+            if (pathname[target_len] == '/' || pathname[target_len] == '\0') {
+                size_t src_len = strlen(merge_entry->src);
+                size_t suffix_len = strlen(pathname) - target_len;
+                
+                if (src_len + suffix_len + 1 > buflen) {
+                    ret = -ENAMETOOLONG;
+                } else {
+                    memcpy(buf, merge_entry->src, src_len);
+                    memcpy(buf + src_len, pathname + target_len, suffix_len);
+                    buf[src_len + suffix_len] = '\0';
+                    ret = src_len + suffix_len;
+        }
+                goto out;
+    }
+        }
+    }
+
+out:
+    rcu_read_unlock();
+    return ret;
+}
+EXPORT_SYMBOL(__hymofs_reverse_lookup);
+#endif /* CONFIG_HYMOFS_REVERSE_LOOKUP */
+
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+bool __hymofs_should_hide(const char *pathname, size_t len)
+{
+    struct hymo_hide_entry *hide_entry;
+    u32 hash;
+
+    if (unlikely(!hymofs_enabled)) return false;
+    if (unlikely(!pathname)) return false;
+
+    if (likely(hymo_stealth_enabled)) {
+        size_t name_len = strlen(hymo_current_mirror_name);
+        size_t path_len = strlen(hymo_current_mirror_path);
+
+        if ((len == name_len && strcmp(pathname, hymo_current_mirror_name) == 0) ||
+            (len == path_len && strcmp(pathname, hymo_current_mirror_path) == 0)) {
+            return true;
+        }
+    }
+
+    /* Check hash table for explicit hide rules (fallback for non-inode paths) */
+    hash = full_name_hash(NULL, pathname, len);
+    rcu_read_lock();
+    hlist_for_each_entry_rcu(hide_entry, &hymo_hide_paths[hash_min(hash, HYMO_HASH_BITS)], node) {
+        if (unlikely(strcmp(hide_entry->path, pathname) == 0)) {
+            rcu_read_unlock();
+            return true;
+        }
+    }
+    rcu_read_unlock();
+
+    return false;
+}
+EXPORT_SYMBOL(__hymofs_should_hide);
+#endif /* CONFIG_HYMOFS_HIDE_ENTRIES */
+
+bool __hymofs_should_spoof_mtime(const char *pathname)
+{
+    struct hymo_inject_entry *entry;
+    u32 hash;
+    bool found = false;
+
+    if (unlikely(!hymofs_enabled)) return false;
+    if (unlikely(!pathname)) return false;
+
+    hash = full_name_hash(NULL, pathname, strlen(pathname));
+
+    rcu_read_lock();
+    hlist_for_each_entry_rcu(entry, &hymo_inject_dirs[hash_min(hash, HYMO_HASH_BITS)], node) {
+        if (strcmp(entry->dir, pathname) == 0) {
+            found = true;
+            break;
+        }
+    }
+    rcu_read_unlock();
+    return found;
+}
+EXPORT_SYMBOL(__hymofs_should_spoof_mtime);
+
+static bool __hymofs_should_replace(const char *pathname)
+{
+    struct hymo_entry *entry;
+    u32 hash;
+    bool found = false;
+
+    if (unlikely(!hymofs_enabled)) return false;
+    if (unlikely(!pathname)) return false;
+
+    hash = full_name_hash(NULL, pathname, strlen(pathname));
+
+    rcu_read_lock();
+    hlist_for_each_entry_rcu(entry, &hymo_paths[hash_min(hash, HYMO_HASH_BITS)], node) {
+        if (unlikely(strcmp(entry->src, pathname) == 0)) {
+            found = true;
+            break;
+        }
+    }
+    rcu_read_unlock();
+    return found;
+}
+
+struct hymo_merge_ctx {
+    struct dir_context ctx;
+    struct list_head *head;
+    const char *dir_path;
+};
+
+static bool hymo_merge_filldir(struct dir_context *ctx, const char *name, int namlen,
+		      loff_t offset, u64 ino, unsigned int d_type)
+{
+    struct hymo_merge_ctx *mctx = container_of(ctx, struct hymo_merge_ctx, ctx);
+    struct hymo_name_list *item;
+
+    if (namlen == 1 && name[0] == '.') return true;
+    if (namlen == 2 && name[0] == '.' && name[1] == '.') return true;
+
+    /* Skip .replace marker */
+    if (namlen == 8 && strncmp(name, ".replace", 8) == 0) return true;
+
+    /* Check for whiteout (char dev 0:0) */
+    if (d_type == DT_CHR) {
+        char *path = kasprintf(GFP_KERNEL, "%s/%.*s", mctx->dir_path, namlen, name);
+        if (path) {
+            struct kstat stat;
+            struct path p;
+            if (kern_path(path, LOOKUP_FOLLOW, &p) == 0) {
+                if (vfs_getattr(&p, &stat, STATX_TYPE, AT_STATX_SYNC_AS_STAT) == 0) {
+                    if (S_ISCHR(stat.mode) && stat.rdev == 0) {
+                        /* It is a whiteout, skip injection */
+                        path_put(&p);
+                        kfree(path);
+                        return true;
+                    }
+                }
+                path_put(&p);
+            }
+            kfree(path);
+        }
+    }
+
+    /* Check for duplicates */
+    {
+        struct hymo_name_list *pos;
+        list_for_each_entry(pos, mctx->head, list) {
+            if (strlen(pos->name) == namlen && strncmp(pos->name, name, namlen) == 0) {
+                return true; // Already exists
+            }
+        }
+    }
+
+    item = kmalloc(sizeof(*item), GFP_KERNEL);
+    if (item) {
+        item->name = kstrndup(name, namlen, GFP_KERNEL);
+        item->type = d_type;
+        if (item->name) {
+            list_add(&item->list, mctx->head);
+        } else {
+            kfree(item);
+        }
+    }
+    return true;
+}
+
+int hymofs_populate_injected_list(const char *dir_path, struct dentry *parent, struct list_head *head)
+{
+    struct hymo_entry *entry;
+    struct hymo_inject_entry *inject_entry;
+    struct hymo_merge_entry *merge_entry;
+    struct hymo_name_list *item;
+    u32 hash;
+    int bkt;
+    bool should_inject = false;
+    struct list_head merge_targets;
+    struct hymo_merge_target_node *target_node, *tmp_node;
+    size_t dir_len;
+    
+    if (unlikely(!hymofs_enabled)) return 0;
+    if (unlikely(!dir_path)) return 0;
+
+    INIT_LIST_HEAD(&merge_targets);
+    dir_len = strlen(dir_path);
+    hash = full_name_hash(NULL, dir_path, dir_len);
+
+    rcu_read_lock();
+    
+    hlist_for_each_entry_rcu(inject_entry, &hymo_inject_dirs[hash_min(hash, HYMO_HASH_BITS)], node) {
+        if (strcmp(inject_entry->dir, dir_path) == 0) {
+            should_inject = true;
+            break;
+        }
+    }
+    
+    // Check for merge rule
+    hlist_for_each_entry_rcu(merge_entry, &hymo_merge_dirs[hash_min(hash, HYMO_HASH_BITS)], node) {
+        if (strcmp(merge_entry->src, dir_path) == 0) {
+            target_node = kmalloc(sizeof(*target_node), GFP_ATOMIC);
+            if (target_node) {
+                target_node->target = kstrdup(merge_entry->target, GFP_ATOMIC);
+                list_add_tail(&target_node->list, &merge_targets);
+             should_inject = true;
+        }
+        }
+    }
+
+    if (should_inject) {
+        // Static injections
+        hash_for_each_rcu(hymo_paths, bkt, entry, node) {
+            if (strncmp(entry->src, dir_path, dir_len) == 0) {
+                char *name = NULL;
+                if (dir_len == 1 && dir_path[0] == '/') {
+                    name = entry->src + 1;
+                } else if (entry->src[dir_len] == '/') {
+                    name = entry->src + dir_len + 1;
+                }
+
+                if (name && *name && strchr(name, '/') == NULL) {
+                    /* Check for duplicates */
+                    bool exists = false;
+                    struct hymo_name_list *pos;
+                    list_for_each_entry(pos, head, list) {
+                        if (strcmp(pos->name, name) == 0) {
+                            exists = true;
+                            break;
+                        }
+                    }
+
+                    if (!exists) {
+                    item = kmalloc(sizeof(*item), GFP_ATOMIC);
+                    if (item) {
+                        item->name = kstrdup(name, GFP_ATOMIC);
+                        item->type = entry->type;
+                        if (item->name) {
+                            list_add(&item->list, head);
+                        }
+                        else kfree(item);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    rcu_read_unlock();
+
+    // Dynamic merge (outside RCU lock, kern_path/iterate_dir may sleep)
+    list_for_each_entry_safe(target_node, tmp_node, &merge_targets, list) {
+        if (target_node->target) {
+            struct path path;
+            if (kern_path(target_node->target, LOOKUP_FOLLOW, &path) == 0) {
+                /* Use init_cred (root) to ensure we can read the module directory 
+                   regardless of the calling process's permissions */
+                const struct cred *cred = get_task_cred(&init_task);
+                struct file *f = dentry_open(&path, O_RDONLY | O_DIRECTORY, cred);
+                if (!IS_ERR(f)) {
+                    struct hymo_merge_ctx mctx = {
+                        .ctx.actor = hymo_merge_filldir,
+                        .head = head,
+                        .dir_path = target_node->target
+                    };
+                    iterate_dir(f, &mctx.ctx);
+                    fput(f);
+                }
+                put_cred(cred);
+                path_put(&path);
+            }
+            kfree(target_node->target);
+        }
+        kfree(target_node);
+    }
+
+    return 0;
+}
+EXPORT_SYMBOL(hymofs_populate_injected_list);
+
+struct filename *hymofs_handle_getname(struct filename *result)
+{
+    char *target = NULL;
+    bool is_absolute;
+
+    if (unlikely(IS_ERR(result))) return result;
+
+    if (unlikely(!hymofs_enabled))
+        return result;
+
+    if (likely(hash_empty(hymo_paths) && 
+               hash_empty(hymo_hide_paths) && 
+               hash_empty(hymo_merge_dirs)))
+        return result;
+
+    is_absolute = (result->name[0] == '/');
+
+    if (unlikely(hymofs_should_hide(result->name))) {
+        putname(result);
+        return ERR_PTR(-ENOENT);
+    }
+
+    if (likely(is_absolute)) {
+        target = hymofs_resolve_target(result->name);
+        if (unlikely(target)) {
+            putname(result);
+            result = getname_kernel(target);
+            kfree(target);
+        }
+        return result;
+    }
+
+    /* Handle relative paths - optimized slow path */
+    {
+        char *buf = NULL;
+        struct path pwd;
+        char *cwd;
+        int cwd_len, name_len;
+        const char *name = result->name;
+
+        /* Skip ./ prefix */
+        if (name[0] == '.' && name[1] == '/') {
+            name += 2;
+        }
+
+        /* Get current directory without spin_lock - use RCU */
+        rcu_read_lock();
+        pwd = current->fs->pwd;
+        path_get(&pwd);
+        rcu_read_unlock();
+
+        /* Allocate buffer only after we have pwd */
+        buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+        if (!buf) {
+            path_put(&pwd);
+            goto fallback_absolute;
+        }
+
+        /* Use d_path (hooked) to get the virtual path of CWD */
+        cwd = d_path(&pwd, buf, PAGE_SIZE);
+        path_put(&pwd);
+
+        if (IS_ERR(cwd)) {
+            kfree(buf);
+            goto fallback_absolute;
+        }
+
+        cwd_len = strlen(cwd);
+        name_len = strlen(name);
+
+        /* Move to beginning of buffer to allow appending */
+        if (cwd != buf) {
+            memmove(buf, cwd, cwd_len + 1);
+            cwd = buf;
+        }
+
+        if (cwd_len + 1 + name_len < PAGE_SIZE) {
+            /* Construct absolute path: cwd + / + name */
+            if (cwd_len > 0 && cwd[cwd_len - 1] != '/') {
+                cwd[cwd_len++] = '/';
+                cwd[cwd_len] = '\0';
+            }
+            memcpy(cwd + cwd_len, name, name_len + 1);
+
+            /* Try to resolve the constructed absolute path */
+            target = hymofs_resolve_target(cwd);
+        }
+
+        kfree(buf);
+    }
+
+fallback_absolute:
+    /* If relative path resolution failed, try the original name */
+    if (!target) {
+        target = hymofs_resolve_target(result->name);
+    }
+
+    if (target) {
+        putname(result);
+        result = getname_kernel(target);
+        kfree(target);
+    }
+
+    return result;
+}
+EXPORT_SYMBOL(hymofs_handle_getname);
+
+/* Resolve relative path with dirfd for fstatat() merge support */
+struct filename *hymofs_resolve_relative(int dfd, const char *name)
+{
+    struct fd f;
+    struct filename *result = NULL;
+    char *buf, *dir_path, *target;
+    size_t dir_len, name_len;
+
+    f = fdget(dfd);
+    if (!f.file)
+        return NULL;
+
+    buf = kmalloc(PATH_MAX, GFP_KERNEL);
+    if (!buf)
+        goto out_fdput;
+
+    dir_path = d_path(&f.file->f_path, buf, PATH_MAX);
+    if (IS_ERR(dir_path))
+        goto out_free;
+
+    dir_len = strlen(dir_path);
+    name_len = strlen(name);
+    if (dir_len + 1 + name_len >= PATH_MAX)
+        goto out_free;
+
+    /* Build full path in-place */
+    if (dir_path != buf)
+        memmove(buf, dir_path, dir_len);
+    if (dir_len > 0 && buf[dir_len - 1] != '/')
+        buf[dir_len++] = '/';
+    memcpy(buf + dir_len, name, name_len + 1);
+
+    target = __hymofs_resolve_target(buf);
+    if (target) {
+        result = getname_kernel(target);
+        if (IS_ERR(result))
+            result = NULL;
+        kfree(target);
+    }
+
+out_free:
+    kfree(buf);
+out_fdput:
+    fdput(f);
+    return result;
+}
+EXPORT_SYMBOL(hymofs_resolve_relative);
+
+/* Bloom filter helper - add a filename */
+static __always_inline void bloom_add(unsigned long *filter, const char *name, int namlen)
+{
+    u32 h1 = full_name_hash(NULL, name, namlen);
+    __set_bit(h1 & HYMO_BLOOM_MASK, filter);  /* Non-atomic, faster */
+    __set_bit((h1 >> 16) & HYMO_BLOOM_MASK, filter);
+}
+
+/* Bloom filter helper - test if filename might exist */
+static __always_inline bool bloom_test(const unsigned long *filter, const char *name, int namlen)
+{
+    u32 h1 = full_name_hash(NULL, name, namlen);
+    /* Use logical AND for boolean result */
+    return test_bit(h1 & HYMO_BLOOM_MASK, filter) && 
+           test_bit((h1 >> 16) & HYMO_BLOOM_MASK, filter);
+}
+
+/* Callback context for enumerating merge target directory */
+struct bloom_fill_ctx {
+    struct dir_context ctx;
+    unsigned long *filter;
+};
+
+/* Callback to add each filename to bloom filter */
+static bool bloom_filldir(struct dir_context *ctx, const char *name, int namlen,
+                          loff_t offset, u64 ino, unsigned int d_type)
+{
+    struct bloom_fill_ctx *bctx = container_of(ctx, struct bloom_fill_ctx, ctx);
+    /* Skip . and .. */
+    if (namlen == 1 && name[0] == '.')
+        return true;
+    if (namlen == 2 && name[0] == '.' && name[1] == '.')
+        return true;
+    bloom_add(bctx->filter, name, namlen);
+    return true;
+}
+
+void __hymofs_prepare_readdir(struct hymo_readdir_context *ctx, struct file *file)
+{
+    struct inode *dir_inode;
+    int i;
+    
+    ctx->file = file;
+    ctx->path_buf = NULL;
+    ctx->dir_path = NULL;
+    ctx->dir_path_len = 0;
+    INIT_LIST_HEAD(&ctx->merge_targets);
+    ctx->is_replace_mode = false;
+    ctx->dir_has_hidden = false;
+    ctx->has_merge_files = false;
+    
+    /* Initialize bloom filter */
+    memset(ctx->bloom_filter, 0, sizeof(ctx->bloom_filter));
+    
+    /* Initialize merge files hash table */
+    for (i = 0; i < HYMO_MERGE_HASH_SIZE; i++)
+        INIT_HLIST_HEAD(&ctx->merge_files[i]);
+
+    /* Fast path: Check if this directory has any hidden entries */
+    if (file && file->f_path.dentry) {
+        dir_inode = d_inode(file->f_path.dentry);
+        if (dir_inode && dir_inode->i_mapping) {
+            ctx->dir_has_hidden = test_bit(AS_FLAGS_HYMO_DIR_HAS_HIDDEN, 
+                                           &dir_inode->i_mapping->flags);
+        }
+    }
+
+    ctx->path_buf = (char *)__get_free_page(GFP_KERNEL);
+    if (ctx->path_buf && file && file->f_path.dentry) {
+        char *p = d_path(&file->f_path, ctx->path_buf, PAGE_SIZE);
+        if (!IS_ERR(p)) {
+            int len = strlen(p);
+            memmove(ctx->path_buf, p, len + 1);
+            ctx->dir_path = ctx->path_buf;
+            ctx->dir_path_len = len;
+            // hymo_log("readdir prepare: %s\n", ctx->dir_path);
+
+            /* Check for merge rule */
+            {
+                struct hymo_merge_entry *entry;
+                u32 hash = full_name_hash(NULL, ctx->dir_path, ctx->dir_path_len);
+                
+                rcu_read_lock();
+                hlist_for_each_entry_rcu(entry, &hymo_merge_dirs[hash_min(hash, HYMO_HASH_BITS)], node) {
+                    if (strcmp(entry->src, ctx->dir_path) == 0) {
+                        struct hymo_merge_target_node *node = kmalloc(sizeof(*node), GFP_ATOMIC);
+                        if (node) {
+                            struct path target_path;
+                            node->target = kstrdup(entry->target, GFP_ATOMIC);
+                            node->target_dentry = NULL;
+                            /* Cache the target dentry for fast lookup */
+                            if (kern_path(entry->target, LOOKUP_FOLLOW, &target_path) == 0) {
+                                node->target_dentry = dget(target_path.dentry);
+                                path_put(&target_path);
+                            }
+                            list_add_tail(&node->list, &ctx->merge_targets);
+                        }
+                    }
+                }
+                rcu_read_unlock();
+
+                /* Check for .replace marker in merge targets */
+                if (!list_empty(&ctx->merge_targets)) {
+                    struct hymo_merge_target_node *node;
+                    list_for_each_entry(node, &ctx->merge_targets, list) {
+                        char *replace_path = kasprintf(GFP_KERNEL, "%s/.replace", node->target);
+                        if (replace_path) {
+                            struct path path;
+                            if (kern_path(replace_path, LOOKUP_FOLLOW, &path) == 0) {
+                                ctx->is_replace_mode = true;
+                                hymo_log("replace mode enabled for %s (found %s)\n", ctx->dir_path, replace_path);
+                                path_put(&path);
+                            }
+                            kfree(replace_path);
+                            if (ctx->is_replace_mode) break;
+                        }
+                    }
+                    
+                    /* Mark that we have merge files to check */
+                    if (!ctx->is_replace_mode) {
+                        ctx->has_merge_files = true;
+                        
+                        /* Build bloom filter by enumerating merge target directories */
+                        list_for_each_entry(node, &ctx->merge_targets, list) {
+                            if (node->target_dentry) {
+                                struct file *target_file;
+                                struct path target_path = {
+                                    .mnt = file->f_path.mnt,
+                                    .dentry = node->target_dentry
+                                };
+                                target_file = dentry_open(&target_path, O_RDONLY | O_DIRECTORY, current_cred());
+                                if (!IS_ERR(target_file)) {
+                                    struct bloom_fill_ctx bctx = {
+                                        .ctx.actor = bloom_filldir,
+                                        .filter = ctx->bloom_filter
+                                    };
+                                    iterate_dir(target_file, &bctx.ctx);
+                                    fput(target_file);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        } else {
+            free_page((unsigned long)ctx->path_buf);
+            ctx->path_buf = NULL;
+        }
+    }
+}
+EXPORT_SYMBOL(__hymofs_prepare_readdir);
+
+void __hymofs_cleanup_readdir(struct hymo_readdir_context *ctx)
+{
+    struct hymo_merge_target_node *node, *tmp;
+    
+    if (ctx->path_buf) free_page((unsigned long)ctx->path_buf);
+    list_for_each_entry_safe(node, tmp, &ctx->merge_targets, list) {
+        if (node->target_dentry)
+            dput(node->target_dentry);
+        kfree(node->target);
+        kfree(node);
+    }
+}
+EXPORT_SYMBOL(__hymofs_cleanup_readdir);
+
+bool __hymofs_check_filldir(struct hymo_readdir_context *ctx, const char *name, int namlen)
+{
+    struct dentry *child;
+    struct inode *inode;
+
+    /* Fast path: If directory has no hidden entries and no merge files, skip all checks */
+    if (likely(!ctx->dir_has_hidden && !ctx->has_merge_files))
+        return false;  /* O(1) skip! */
+
+    /* Root sees everything */
+    if (uid_eq(current_uid(), GLOBAL_ROOT_UID))
+        return false;
+
+    /* Skip . and .. - use single comparison where possible */
+    if (unlikely(namlen <= 2 && name[0] == '.')) {
+        if (namlen == 1 || (namlen == 2 && name[1] == '.'))
+            return false;
+    }
+
+    /* Stealth mode: Hide hymo devices in /dev directory */
+    if (hymo_stealth_enabled && ctx->dir_path) {
+        /* Check if we're listing /dev directory */
+        if (ctx->dir_path_len == 4 && strcmp(ctx->dir_path, "/dev") == 0) {
+            /* Hide hymo and hymo_mirror */
+            if ((namlen == 4 && memcmp(name, "hymo", 4) == 0) ||
+                (namlen == 11 && memcmp(name, "hymo_mirror", 11) == 0)) {
+                return true;  /* Hide it! */
+            }
+            /* Also check against current mirror name */
+            size_t mirror_name_len = strlen(hymo_current_mirror_name);
+            if (namlen == mirror_name_len && 
+                memcmp(name, hymo_current_mirror_name, namlen) == 0) {
+                return true;
+            }
+        }
+    }
+
+    /* If we are in replace mode, hide all original entries */
+    if (unlikely(ctx->is_replace_mode))
+        return true;
+
+    /* Fast path: Use inode marking (O(1) bit test) */
+    if (ctx->dir_has_hidden && ctx->file && ctx->file->f_path.dentry) {
+        child = d_hash_and_lookup(ctx->file->f_path.dentry, 
+                                  &(struct qstr)QSTR_INIT(name, namlen));
+        if (child) {
+            inode = d_inode(child);
+            if (inode && inode->i_mapping &&
+                test_bit(AS_FLAGS_HYMO_HIDE, &inode->i_mapping->flags)) {
+                dput(child);
+                return true;
+            }
+            dput(child);
+        }
+    }
+
+    /* Merge target check - files that exist in merge target should be hidden */
+    if (ctx->has_merge_files) {
+        /* Ultra fast path: Bloom filter says definitely not in merge target */
+        if (!bloom_test(ctx->bloom_filter, name, namlen)) {
+            return false;  /* O(1) skip - bloom filter negative */
+        }
+        
+        /* Bloom filter positive - need to confirm with d_hash_and_lookup */
+        struct hymo_merge_target_node *node;
+        list_for_each_entry(node, &ctx->merge_targets, list) {
+            /* Fast path: use cached dentry + d_hash_and_lookup */
+            if (node->target_dentry) {
+                struct dentry *child = d_hash_and_lookup(node->target_dentry,
+                                           &(struct qstr)QSTR_INIT(name, namlen));
+                if (child) {
+                    dput(child);
+                    return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
+EXPORT_SYMBOL(__hymofs_check_filldir);
+
+struct linux_dirent {
+	unsigned long	d_ino;
+	unsigned long	d_off;
+	unsigned short	d_reclen;
+	char		d_name[];
+};
+
+#ifdef CONFIG_HYMOFS_INJECT_ENTRIES
+/* Inject virtual entries into getdents system call */
+int hymofs_inject_entries(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos)
+{
+    struct linux_dirent __user *current_dir = *dir_ptr;
+    struct list_head head;
+    struct hymo_name_list *item, *tmp;
+    loff_t current_idx = 0;
+    loff_t start_idx;
+    int injected = 0;
+    int error = 0;
+    int initial_count = *count;
+    bool is_transition = (*pos < HYMO_MAGIC_POS);
+    struct dentry *parent;
+
+    if (!ctx->file) return 0;
+    parent = ctx->file->f_path.dentry;
+
+    if (is_transition) {
+        start_idx = 0;
+    } else {
+        start_idx = *pos - HYMO_MAGIC_POS;
+    }
+
+    INIT_LIST_HEAD(&head);
+    hymofs_populate_injected_list(ctx->dir_path, parent, &head);
+
+    list_for_each_entry_safe(item, tmp, &head, list) {
+        if (current_idx >= start_idx) {
+            int name_len = strlen(item->name);
+            int reclen = ALIGN(offsetof(struct linux_dirent, d_name) + name_len + 2, sizeof(long));
+            if (*count >= reclen) {
+                struct linux_dirent d;
+                d.d_ino = 1;
+                d.d_off = HYMO_MAGIC_POS + current_idx + 1;
+                d.d_reclen = reclen;
+                if (copy_to_user(current_dir, &d, offsetof(struct linux_dirent, d_name)) ||
+                    copy_to_user(current_dir->d_name, item->name, name_len) ||
+                    put_user(0, current_dir->d_name + name_len) ||
+                    put_user(item->type, (char __user *)current_dir + reclen - 1)) {
+                        error = -EFAULT;
+                        break;
+                }
+                current_dir = (struct linux_dirent __user *)((char __user *)current_dir + reclen);
+                *count -= reclen;
+                injected++;
+            } else {
+                break;
+            }
+        }
+        current_idx++;
+        list_del(&item->list);
+        kfree(item->name);
+        kfree(item);
+    }
+    
+    list_for_each_entry_safe(item, tmp, &head, list) {
+        list_del(&item->list);
+        kfree(item->name);
+        kfree(item);
+    }
+
+    if (error == 0) {
+        if (injected > 0) {
+            if (is_transition) {
+                *pos = HYMO_MAGIC_POS + injected;
+            } else {
+                *pos += injected;
+            }
+        }
+        error = initial_count - *count;
+    }
+    
+    *dir_ptr = current_dir;
+    return error;
+}
+EXPORT_SYMBOL(hymofs_inject_entries);
+
+/* Inject virtual entries into getdents64 system call */
+int hymofs_inject_entries64(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos)
+{
+    struct linux_dirent64 __user *current_dir = *dir_ptr;
+    struct list_head head;
+    struct hymo_name_list *item, *tmp;
+    loff_t current_idx = 0;
+    loff_t start_idx;
+    int injected = 0;
+    int error = 0;
+    int initial_count = *count;
+    bool is_transition = (*pos < HYMO_MAGIC_POS);
+    struct dentry *parent;
+
+    if (!ctx->file) return 0;
+    parent = ctx->file->f_path.dentry;
+
+    if (is_transition) {
+        start_idx = 0;
+    } else {
+        start_idx = *pos - HYMO_MAGIC_POS;
+    }
+
+    INIT_LIST_HEAD(&head);
+    hymofs_populate_injected_list(ctx->dir_path, parent, &head);
+
+    list_for_each_entry_safe(item, tmp, &head, list) {
+        if (current_idx >= start_idx) {
+            int name_len = strlen(item->name);
+            int reclen = ALIGN(offsetof(struct linux_dirent64, d_name) + name_len + 1, sizeof(u64));
+            if (*count >= reclen) {
+                struct linux_dirent64 d;
+                d.d_ino = 1;
+                d.d_off = HYMO_MAGIC_POS + current_idx + 1;
+                d.d_reclen = reclen;
+                d.d_type = item->type;
+                if (copy_to_user(current_dir, &d, offsetof(struct linux_dirent64, d_name)) ||
+                    copy_to_user(current_dir->d_name, item->name, name_len) ||
+                    put_user(0, current_dir->d_name + name_len)) {
+                        error = -EFAULT;
+                        break;
+                }
+                current_dir = (struct linux_dirent64 __user *)((char __user *)current_dir + reclen);
+                *count -= reclen;
+                injected++;
+            } else {
+                break;
+            }
+        }
+        current_idx++;
+        list_del(&item->list);
+        kfree(item->name);
+        kfree(item);
+    }
+    
+    list_for_each_entry_safe(item, tmp, &head, list) {
+        list_del(&item->list);
+        kfree(item->name);
+        kfree(item);
+    }
+
+    if (error == 0) {
+        if (injected > 0) {
+            if (is_transition) {
+                *pos = HYMO_MAGIC_POS + injected;
+            } else {
+                *pos += injected;
+            }
+        }
+        error = initial_count - *count;
+    }
+    
+    *dir_ptr = current_dir;
+    return error;
+}
+EXPORT_SYMBOL(hymofs_inject_entries64);
+#endif /* CONFIG_HYMOFS_INJECT_ENTRIES */
+
+#ifdef CONFIG_HYMOFS_STAT_SPOOF
+static dev_t __attribute__((unused)) get_dev_for_path(const char *path_str) {
+    struct path path;
+    dev_t dev = 0;
+    if (kern_path(path_str, LOOKUP_FOLLOW, &path) == 0) {
+        if (path.dentry && path.dentry->d_sb) {
+            dev = path.dentry->d_sb->s_dev;
+        }
+        path_put(&path);
+    }
+    return dev;
+}
+
+/* Update timestamps for injected directories to appear current */
+extern char *d_absolute_path(const struct path *, char *, int);
+
+/* Fast path check: determine if path might need HymoFS processing */
+static inline bool hymofs_needs_check(const struct path *path)
+{
+    const struct dentry *dentry;
+    const char *name;
+    
+    if (!path || !path->dentry)
+        return false;
+    
+    dentry = path->dentry;
+    name = dentry->d_name.name;
+    
+    /* Skip common system paths that never have HymoFS rules */
+    if (name[0] == 'd' && !strncmp(name, "dev", 3))
+        return false;
+    if (name[0] == 'p' && !strncmp(name, "proc", 4))
+        return false;
+    if (name[0] == 's' && !strncmp(name, "sys", 3))
+        return false;
+    
+    /* If no rules exist, skip all processing */
+    if (atomic_read(&hymo_rule_count) == 0)
+        return false;
+    
+    return true;
+}
+
+void hymofs_spoof_stat(const struct path *path, struct kstat *stat)
+{
+    char *buf, *virtual_buf = NULL;
+    char *p;
+    bool is_injected = false;
+    gfp_t gfp = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+
+    /* Fast path checks - avoid all overhead if not needed */
+    if (!hymofs_enabled) {
+        atomic64_inc(&hymo_stats.fast_path_skips);
+        return;
+    }
+    if (!hymo_stealth_enabled) {
+        atomic64_inc(&hymo_stats.fast_path_skips);
+        return;
+    }
+    
+    /* Quick path validation */
+    if (!hymofs_needs_check(path)) {
+        atomic64_inc(&hymo_stats.fast_path_skips);
+        return;
+    }
+    
+    /* Check if rules tables are empty - ultimate fast path */
+    if (likely(hash_empty(hymo_paths) && hash_empty(hymo_targets) && 
+               hash_empty(hymo_inject_dirs))) {
+        atomic64_inc(&hymo_stats.fast_path_skips);
+        return;
+    }
+    
+    atomic64_inc(&hymo_stats.total_checks);
+
+    buf = kmalloc(PAGE_SIZE, gfp);
+    if (!buf || !path || !path->dentry) {
+        if (buf) kfree(buf);
+        return;
+    }
+
+    /* Use d_absolute_path to bypass our own d_path hook and get the real physical path */
+    p = d_absolute_path(path, buf, PAGE_SIZE);
+    if (!IS_ERR(p)) {
+        /* HymoFS: Check if this path is a merge target (physical path) and map back to virtual */
+        virtual_buf = kmalloc(PAGE_SIZE, gfp);
+        
+        if (virtual_buf) {
+            if (__hymofs_reverse_lookup(p, virtual_buf, PAGE_SIZE) > 0) {
+                p = virtual_buf; /* Switch to virtual path */
+                is_injected = true;
+            }
+        }
+
+        /* Only spoof attributes for files we injected */
+        if (is_injected) {
+            /* Always look up parent to get correct fs attributes (dev, uid, gid) */
+                char *last_slash = strrchr(p, '/');
+                if (last_slash) {
+                    if (last_slash == p) {
+                        /* Parent is root */
+                        struct path parent_path;
+                        if (kern_path("/", LOOKUP_FOLLOW, &parent_path) == 0) {
+                            struct inode *inode = d_backing_inode(parent_path.dentry);
+                            stat->uid = inode->i_uid;
+                            stat->gid = inode->i_gid;
+                            stat->dev = inode->i_sb->s_dev;
+                            path_put(&parent_path);
+                        }
+                    } else {
+                        *last_slash = '\0';
+                        struct path parent_path;
+                        if (kern_path(p, LOOKUP_FOLLOW, &parent_path) == 0) {
+                            struct inode *inode = d_backing_inode(parent_path.dentry);
+                            stat->uid = inode->i_uid;
+                            stat->gid = inode->i_gid;
+                            stat->dev = inode->i_sb->s_dev;
+                            path_put(&parent_path);
+                        } else {
+                            /* Fallback if parent lookup fails (rare) */
+                            if (strncmp(p, "/system/", 8) == 0 || 
+                                strncmp(p, "/vendor/", 8) == 0 ||
+                                strncmp(p, "/product/", 9) == 0 ||
+                                strncmp(p, "/odm/", 5) == 0 ||
+                                strncmp(p, "/apex/", 6) == 0) {
+                                stat->uid = KUIDT_INIT(0);
+                                stat->gid = KGIDT_INIT(0);
+                            }
+                        }
+                        *last_slash = '/';
+                    }
+                }
+                /* Obfuscate inode for injected files too */
+                stat->ino ^= 0x48594D4F;
+            }
+
+        if (hymofs_should_spoof_mtime(p)) {
+            ktime_get_real_ts64(&stat->mtime);
+            stat->ctime = stat->mtime;
+        }
+        /* HymoFS: Inode obfuscation for redirected paths */
+        if (__hymofs_should_replace(p)) {
+            /* XOR with a magic number to make inode look different from target */
+            stat->ino ^= 0x48594D4F;
+            
+            /* Fixup permissions for /system paths to ensure they look like root-owned */
+            if (strncmp(p, "/system/", 8) == 0) {
+                stat->uid = KUIDT_INIT(0);
+                stat->gid = KGIDT_INIT(0);
+            }
+        }
+        if (virtual_buf) kfree(virtual_buf);
+    }
+    kfree(buf);
+}
+EXPORT_SYMBOL(hymofs_spoof_stat);
+
+/*
+ * ==================== kstat Spoofing Implementation ====================
+ * Allows full stat() result manipulation for specific inodes
+ */
+
+struct hymo_kstat_entry {
+    unsigned long target_ino;
+    struct {
+        dev_t spoofed_dev;
+        unsigned long spoofed_ino;
+        unsigned int spoofed_nlink;
+        loff_t spoofed_size;
+        long spoofed_atime_sec;
+        long spoofed_atime_nsec;
+        long spoofed_mtime_sec;
+        long spoofed_mtime_nsec;
+        long spoofed_ctime_sec;
+        long spoofed_ctime_nsec;
+        unsigned long spoofed_blksize;
+        unsigned long long spoofed_blocks;
+    } info;
+    struct hlist_node node;
+    struct rcu_head rcu;
+};
+
+static DEFINE_HASHTABLE(hymo_kstat_entries, 8);
+
+bool hymofs_is_kstat_spoofed(struct inode *inode)
+{
+    struct hymo_kstat_entry *entry;
+    bool found = false;
+
+    /* Early boot protection */
+    if (system_state < SYSTEM_RUNNING) return false;
+    if (!inode) return false;
+    if (!hymofs_enabled) return false;
+
+    rcu_read_lock();
+    hash_for_each_possible_rcu(hymo_kstat_entries, entry, node, inode->i_ino) {
+        if (entry->target_ino == inode->i_ino) {
+            found = true;
+            break;
+        }
+    }
+    rcu_read_unlock();
+    return found;
+}
+EXPORT_SYMBOL(hymofs_is_kstat_spoofed);
+
+void hymofs_spoof_kstat_by_ino(unsigned long ino, struct kstat *stat)
+{
+    struct hymo_kstat_entry *entry;
+
+    /* Early boot protection */
+    if (system_state < SYSTEM_RUNNING) return;
+    if (!stat) return;
+    if (!hymofs_enabled) return;
+
+    /* Root sees real values */
+    if (uid_eq(current_uid(), GLOBAL_ROOT_UID))
+        return;
+
+    rcu_read_lock();
+    hash_for_each_possible_rcu(hymo_kstat_entries, entry, node, ino) {
+        if (entry->target_ino == ino) {
+            stat->dev = entry->info.spoofed_dev;
+            stat->ino = entry->info.spoofed_ino;
+            stat->nlink = entry->info.spoofed_nlink;
+            stat->size = entry->info.spoofed_size;
+            stat->atime.tv_sec = entry->info.spoofed_atime_sec;
+            stat->atime.tv_nsec = entry->info.spoofed_atime_nsec;
+            stat->mtime.tv_sec = entry->info.spoofed_mtime_sec;
+            stat->mtime.tv_nsec = entry->info.spoofed_mtime_nsec;
+            stat->ctime.tv_sec = entry->info.spoofed_ctime_sec;
+            stat->ctime.tv_nsec = entry->info.spoofed_ctime_nsec;
+            stat->blksize = entry->info.spoofed_blksize;
+            stat->blocks = entry->info.spoofed_blocks;
+            hymo_log("kstat: spoofed ino %lu\n", ino);
+            break;
+        }
+    }
+    rcu_read_unlock();
+}
+EXPORT_SYMBOL(hymofs_spoof_kstat_by_ino);
+
+/* Get performance statistics */
+void hymofs_get_perf_stats(struct hymofs_perf_info *info)
+{
+    if (!info)
+        return;
+    
+    info->total_checks = atomic64_read(&hymo_stats.total_checks);
+    info->fast_path_skips = atomic64_read(&hymo_stats.fast_path_skips);
+    info->bloom_rejects = atomic64_read(&hymo_stats.bloom_rejects);
+    info->rule_hits = atomic64_read(&hymo_stats.rule_hits);
+}
+EXPORT_SYMBOL(hymofs_get_perf_stats);
+#endif /* CONFIG_HYMOFS_STAT_SPOOF */
+
+#ifdef CONFIG_HYMOFS_STAT_SPOOF
+/* Post-process getattr results for stat spoofing */
+void hymofs_post_getattr(const struct path *path, struct inode *inode, 
+                         struct kstat *stat, int ret)
+{
+    if (ret != 0)
+        return;
+
+    /* HymoFS: Spoof timestamps if needed */
+    hymofs_spoof_stat(path, stat);
+    
+    /* Apply full kstat spoofing if configured for this inode */
+    if (hymofs_is_kstat_spoofed(inode)) {
+        hymofs_spoof_kstat_by_ino(inode->i_ino, stat);
+    }
+}
+EXPORT_SYMBOL(hymofs_post_getattr);
+#endif /* CONFIG_HYMOFS_STAT_SPOOF */
+
+#ifdef CONFIG_HYMOFS_REVERSE_LOOKUP
+/* Process d_path output for reverse lookup */
+char *hymofs_process_d_path(char *res, char *buf, int buflen)
+{
+	char *temp = NULL;
+	int len;
+
+	if (unlikely(!hymofs_enabled))
+		return res;
+
+	if (likely(hash_empty(hymo_targets)))
+		return res;
+
+	if (IS_ERR(res))
+		return res;
+
+	/* Allocate temporary buffer for reverse lookup */
+	temp = kmalloc(buflen, GFP_KERNEL);
+	if (!temp)
+		return res;
+
+	/* Try reverse lookup */
+	if (__hymofs_reverse_lookup(res, temp, buflen) == 0) {
+		len = strlen(temp);
+		/* Safety check: ensure we don't overflow the output buffer */
+		if (len < buflen) {
+			memcpy(buf, temp, len + 1); /* Copy including null terminator */
+			res = buf;
+		}
+	}
+	kfree(temp);
+	return res;
+}
+EXPORT_SYMBOL(hymofs_process_d_path);
+#endif /* CONFIG_HYMOFS_REVERSE_LOOKUP */
+
+#ifdef CONFIG_HYMOFS_UNAME_SPOOF
+
+/*
+ * ==================== uname Spoofing Implementation ====================
+ * Allows spoofing kernel version reported by uname()
+ */
+
+void hymofs_spoof_uname(struct new_utsname *name)
+{
+	if (!name)
+		return;
+
+    /* Root sees real values */
+    if (uid_eq(current_uid(), GLOBAL_ROOT_UID))
+        return;
+
+	spin_lock(&hymo_uname_lock);
+	if (hymo_uname_info.sysname[0])
+		strscpy(name->sysname, hymo_uname_info.sysname, sizeof(name->sysname));
+	if (hymo_uname_info.nodename[0])
+		strscpy(name->nodename, hymo_uname_info.nodename, sizeof(name->nodename));
+	if (hymo_uname_info.release[0])
+		strscpy(name->release, hymo_uname_info.release, sizeof(name->release));
+	if (hymo_uname_info.version[0])
+		strscpy(name->version, hymo_uname_info.version, sizeof(name->version));
+	if (hymo_uname_info.machine[0])
+		strscpy(name->machine, hymo_uname_info.machine, sizeof(name->machine));
+	if (hymo_uname_info.domainname[0])
+		strscpy(name->domainname, hymo_uname_info.domainname, sizeof(name->domainname));
+	spin_unlock(&hymo_uname_lock);
+}
+EXPORT_SYMBOL(hymofs_spoof_uname);
+#endif /* CONFIG_HYMOFS_UNAME_SPOOF */
+
+#ifdef CONFIG_HYMOFS_CMDLINE_SPOOF
+
+/*
+ * ==================== cmdline Spoofing Implementation ====================
+ * Allows spoofing /proc/cmdline content
+ */
+
+static bool hymo_cmdline_spoofed = false;
+static char *hymo_fake_cmdline = NULL;
+
+bool hymofs_is_cmdline_spoofed(void)
+{
+    return hymo_cmdline_spoofed && hymo_fake_cmdline != NULL;
+}
+
+int hymofs_spoof_cmdline(struct seq_file *m)
+{
+    if (!hymo_cmdline_spoofed || !hymo_fake_cmdline)
+        return 1;  /* Return 1 to indicate "not spoofed, use original" */
+
+    /* Root sees real cmdline */
+    if (uid_eq(current_uid(), GLOBAL_ROOT_UID))
+        return 1;
+
+    seq_puts(m, hymo_fake_cmdline);
+    seq_putc(m, '\n');
+    hymo_log("cmdline: spoofed\n");
+    return 0;  /* Return 0 to indicate "spoofed successfully" */
+}
+EXPORT_SYMBOL(hymofs_spoof_cmdline);
+#endif /* CONFIG_HYMOFS_CMDLINE_SPOOF */
+
+#ifdef CONFIG_HYMOFS_XATTR_FILTER
+
+
+bool hymofs_is_overlay_xattr(struct dentry *dentry, const char *name)
+{
+    struct hymo_xattr_sb_entry *sb_entry;
+    bool found = false;
+
+    if (!name) return false;
+    if (strncmp(name, "trusted.overlay.", 16) != 0) return false;
+    
+    if (!dentry) return false;
+
+    rcu_read_lock();
+    hlist_for_each_entry_rcu(sb_entry, &hymo_xattr_sbs[hash_min((unsigned long)dentry->d_sb, HYMO_HASH_BITS)], node) {
+        if (sb_entry->sb == dentry->d_sb) {
+            found = true;
+            break;
+        }
+    }
+    rcu_read_unlock();
+    
+    return found;
+}
+EXPORT_SYMBOL(hymofs_is_overlay_xattr);
+
+ssize_t hymofs_filter_xattrs(struct dentry *dentry, char *klist, ssize_t len)
+{
+    struct hymo_xattr_sb_entry *sb_entry;
+    bool should_filter = false;
+    char *p = klist;
+    char *end = klist + len;
+    char *out = klist;
+    ssize_t new_len = 0;
+    
+    if (!dentry) return len;
+
+    rcu_read_lock();
+    hlist_for_each_entry_rcu(sb_entry, &hymo_xattr_sbs[hash_min((unsigned long)dentry->d_sb, HYMO_HASH_BITS)], node) {
+        if (sb_entry->sb == dentry->d_sb) {
+            should_filter = true;
+            break;
+        }
+    }
+    rcu_read_unlock();
+
+    if (!should_filter) return len;
+
+    while (p < end) {
+        size_t slen = strlen(p);
+        if (strncmp(p, "trusted.overlay.", 16) != 0) {
+            if (out != p)
+                memmove(out, p, slen + 1);
+            out += slen + 1;
+            new_len += slen + 1;
+        }
+        p += slen + 1;
+    }
+#endif /* CONFIG_HYMOFS_XATTR_FILTER */
+    return new_len;
+}
+EXPORT_SYMBOL(hymofs_filter_xattrs);
+
+#endif /* CONFIG_HYMOFS */
diff --git a/fs/namei.c b/fs/namei.c
index b31b583f1..0f3d4b81c 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -45,6 +45,10 @@
 #include "internal.h"
 #include "mount.h"
 
+#ifdef CONFIG_HYMOFS
+#include <linux/hymofs.h>
+#endif
+
 /* [Feb-1997 T. Schoebel-Theuer]
  * Fundamental changes in the pathname lookup mechanisms (namei)
  * were necessary because of omirr.  The reason is that omirr needs
@@ -126,8 +130,26 @@
 
 #define EMBEDDED_NAME_MAX	(PATH_MAX - offsetof(struct filename, iname))
 
+#ifdef CONFIG_HYMOFS
+struct filename *__original_getname_flags(const char __user *filename, int flags, int *empty);
+
+/* Hook getname_flags to intercept path lookups */
+struct filename *getname_flags(const char __user *filename, int flags, int *empty)
+{
+	struct filename *result = __original_getname_flags(filename, flags, empty);
+#ifdef CONFIG_HYMOFS_FORWARD_REDIRECT
+	return hymofs_handle_getname(result);
+#else
+	return result;
+#endif
+}
+#endif
 struct filename *
+#ifdef CONFIG_HYMOFS
+__original_getname_flags(const char __user *filename, int flags, int *empty)
+#else
 getname_flags(const char __user *filename, int flags, int *empty)
+#endif
 {
 	struct filename *result;
 	char *kname;
@@ -3813,6 +3835,7 @@ static struct file *path_openat(struct nameidata *nd,
 	return ERR_PTR(error);
 }
 
+
 struct file *do_filp_open(int dfd, struct filename *pathname,
 		const struct open_flags *op)
 {
diff --git a/fs/namei.c.orig b/fs/namei.c.orig
new file mode 100644
index 000000000..b31b583f1
--- /dev/null
+++ b/fs/namei.c.orig
@@ -0,0 +1,5263 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *  linux/fs/namei.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+/*
+ * Some corrections by tytso.
+ */
+
+/* [Feb 1997 T. Schoebel-Theuer] Complete rewrite of the pathname
+ * lookup logic.
+ */
+/* [Feb-Apr 2000, AV] Rewrite to the new namespace architecture.
+ */
+
+#include <linux/init.h>
+#include <linux/export.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/filelock.h>
+#include <linux/namei.h>
+#include <linux/pagemap.h>
+#include <linux/sched/mm.h>
+#include <linux/fsnotify.h>
+#include <linux/personality.h>
+#include <linux/security.h>
+#include <linux/ima.h>
+#include <linux/syscalls.h>
+#include <linux/mount.h>
+#include <linux/audit.h>
+#include <linux/capability.h>
+#include <linux/file.h>
+#include <linux/fcntl.h>
+#include <linux/device_cgroup.h>
+#include <linux/fs_struct.h>
+#include <linux/posix_acl.h>
+#include <linux/hash.h>
+#include <linux/bitops.h>
+#include <linux/init_task.h>
+#include <linux/uaccess.h>
+
+#include "internal.h"
+#include "mount.h"
+
+/* [Feb-1997 T. Schoebel-Theuer]
+ * Fundamental changes in the pathname lookup mechanisms (namei)
+ * were necessary because of omirr.  The reason is that omirr needs
+ * to know the _real_ pathname, not the user-supplied one, in case
+ * of symlinks (and also when transname replacements occur).
+ *
+ * The new code replaces the old recursive symlink resolution with
+ * an iterative one (in case of non-nested symlink chains).  It does
+ * this with calls to <fs>_follow_link().
+ * As a side effect, dir_namei(), _namei() and follow_link() are now 
+ * replaced with a single function lookup_dentry() that can handle all 
+ * the special cases of the former code.
+ *
+ * With the new dcache, the pathname is stored at each inode, at least as
+ * long as the refcount of the inode is positive.  As a side effect, the
+ * size of the dcache depends on the inode cache and thus is dynamic.
+ *
+ * [29-Apr-1998 C. Scott Ananian] Updated above description of symlink
+ * resolution to correspond with current state of the code.
+ *
+ * Note that the symlink resolution is not *completely* iterative.
+ * There is still a significant amount of tail- and mid- recursion in
+ * the algorithm.  Also, note that <fs>_readlink() is not used in
+ * lookup_dentry(): lookup_dentry() on the result of <fs>_readlink()
+ * may return different results than <fs>_follow_link().  Many virtual
+ * filesystems (including /proc) exhibit this behavior.
+ */
+
+/* [24-Feb-97 T. Schoebel-Theuer] Side effects caused by new implementation:
+ * New symlink semantics: when open() is called with flags O_CREAT | O_EXCL
+ * and the name already exists in form of a symlink, try to create the new
+ * name indicated by the symlink. The old code always complained that the
+ * name already exists, due to not following the symlink even if its target
+ * is nonexistent.  The new semantics affects also mknod() and link() when
+ * the name is a symlink pointing to a non-existent name.
+ *
+ * I don't know which semantics is the right one, since I have no access
+ * to standards. But I found by trial that HP-UX 9.0 has the full "new"
+ * semantics implemented, while SunOS 4.1.1 and Solaris (SunOS 5.4) have the
+ * "old" one. Personally, I think the new semantics is much more logical.
+ * Note that "ln old new" where "new" is a symlink pointing to a non-existing
+ * file does succeed in both HP-UX and SunOs, but not in Solaris
+ * and in the old Linux semantics.
+ */
+
+/* [16-Dec-97 Kevin Buhr] For security reasons, we change some symlink
+ * semantics.  See the comments in "open_namei" and "do_link" below.
+ *
+ * [10-Sep-98 Alan Modra] Another symlink change.
+ */
+
+/* [Feb-Apr 2000 AV] Complete rewrite. Rules for symlinks:
+ *	inside the path - always follow.
+ *	in the last component in creation/removal/renaming - never follow.
+ *	if LOOKUP_FOLLOW passed - follow.
+ *	if the pathname has trailing slashes - follow.
+ *	otherwise - don't follow.
+ * (applied in that order).
+ *
+ * [Jun 2000 AV] Inconsistent behaviour of open() in case if flags==O_CREAT
+ * restored for 2.4. This is the last surviving part of old 4.2BSD bug.
+ * During the 2.4 we need to fix the userland stuff depending on it -
+ * hopefully we will be able to get rid of that wart in 2.5. So far only
+ * XEmacs seems to be relying on it...
+ */
+/*
+ * [Sep 2001 AV] Single-semaphore locking scheme (kudos to David Holland)
+ * implemented.  Let's see if raised priority of ->s_vfs_rename_mutex gives
+ * any extra contention...
+ */
+
+/* In order to reduce some races, while at the same time doing additional
+ * checking and hopefully speeding things up, we copy filenames to the
+ * kernel data space before using them..
+ *
+ * POSIX.1 2.4: an empty pathname is invalid (ENOENT).
+ * PATH_MAX includes the nul terminator --RR.
+ */
+
+#define EMBEDDED_NAME_MAX	(PATH_MAX - offsetof(struct filename, iname))
+
+struct filename *
+getname_flags(const char __user *filename, int flags, int *empty)
+{
+	struct filename *result;
+	char *kname;
+	int len;
+
+	result = audit_reusename(filename);
+	if (result)
+		return result;
+
+	result = __getname();
+	if (unlikely(!result))
+		return ERR_PTR(-ENOMEM);
+
+	/*
+	 * First, try to embed the struct filename inside the names_cache
+	 * allocation
+	 */
+	kname = (char *)result->iname;
+	result->name = kname;
+
+	len = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX);
+	if (unlikely(len < 0)) {
+		__putname(result);
+		return ERR_PTR(len);
+	}
+
+	/*
+	 * Uh-oh. We have a name that's approaching PATH_MAX. Allocate a
+	 * separate struct filename so we can dedicate the entire
+	 * names_cache allocation for the pathname, and re-do the copy from
+	 * userland.
+	 */
+	if (unlikely(len == EMBEDDED_NAME_MAX)) {
+		const size_t size = offsetof(struct filename, iname[1]);
+		kname = (char *)result;
+
+		/*
+		 * size is chosen that way we to guarantee that
+		 * result->iname[0] is within the same object and that
+		 * kname can't be equal to result->iname, no matter what.
+		 */
+		result = kzalloc(size, GFP_KERNEL);
+		if (unlikely(!result)) {
+			__putname(kname);
+			return ERR_PTR(-ENOMEM);
+		}
+		result->name = kname;
+		len = strncpy_from_user(kname, filename, PATH_MAX);
+		if (unlikely(len < 0)) {
+			__putname(kname);
+			kfree(result);
+			return ERR_PTR(len);
+		}
+		if (unlikely(len == PATH_MAX)) {
+			__putname(kname);
+			kfree(result);
+			return ERR_PTR(-ENAMETOOLONG);
+		}
+	}
+
+	atomic_set(&result->refcnt, 1);
+	/* The empty path is special. */
+	if (unlikely(!len)) {
+		if (empty)
+			*empty = 1;
+		if (!(flags & LOOKUP_EMPTY)) {
+			putname(result);
+			return ERR_PTR(-ENOENT);
+		}
+	}
+
+	result->uptr = filename;
+	result->aname = NULL;
+	audit_getname(result);
+	return result;
+}
+
+struct filename *
+getname_uflags(const char __user *filename, int uflags)
+{
+	int flags = (uflags & AT_EMPTY_PATH) ? LOOKUP_EMPTY : 0;
+
+	return getname_flags(filename, flags, NULL);
+}
+
+struct filename *
+getname(const char __user * filename)
+{
+	return getname_flags(filename, 0, NULL);
+}
+
+struct filename *
+getname_kernel(const char * filename)
+{
+	struct filename *result;
+	int len = strlen(filename) + 1;
+
+	result = __getname();
+	if (unlikely(!result))
+		return ERR_PTR(-ENOMEM);
+
+	if (len <= EMBEDDED_NAME_MAX) {
+		result->name = (char *)result->iname;
+	} else if (len <= PATH_MAX) {
+		const size_t size = offsetof(struct filename, iname[1]);
+		struct filename *tmp;
+
+		tmp = kmalloc(size, GFP_KERNEL);
+		if (unlikely(!tmp)) {
+			__putname(result);
+			return ERR_PTR(-ENOMEM);
+		}
+		tmp->name = (char *)result;
+		result = tmp;
+	} else {
+		__putname(result);
+		return ERR_PTR(-ENAMETOOLONG);
+	}
+	memcpy((char *)result->name, filename, len);
+	result->uptr = NULL;
+	result->aname = NULL;
+	atomic_set(&result->refcnt, 1);
+	audit_getname(result);
+
+	return result;
+}
+EXPORT_SYMBOL(getname_kernel);
+
+void putname(struct filename *name)
+{
+	if (IS_ERR(name))
+		return;
+
+	if (WARN_ON_ONCE(!atomic_read(&name->refcnt)))
+		return;
+
+	if (!atomic_dec_and_test(&name->refcnt))
+		return;
+
+	if (name->name != name->iname) {
+		__putname(name->name);
+		kfree(name);
+	} else
+		__putname(name);
+}
+EXPORT_SYMBOL(putname);
+
+/**
+ * check_acl - perform ACL permission checking
+ * @idmap:	idmap of the mount the inode was found from
+ * @inode:	inode to check permissions on
+ * @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...)
+ *
+ * This function performs the ACL permission checking. Since this function
+ * retrieve POSIX acls it needs to know whether it is called from a blocking or
+ * non-blocking context and thus cares about the MAY_NOT_BLOCK bit.
+ *
+ * If the inode has been found through an idmapped mount the idmap of
+ * the vfsmount must be passed through @idmap. This function will then take
+ * care to map the inode according to @idmap before checking permissions.
+ * On non-idmapped mounts or if permission checking is to be performed on the
+ * raw inode simply passs @nop_mnt_idmap.
+ */
+static int check_acl(struct mnt_idmap *idmap,
+		     struct inode *inode, int mask)
+{
+#ifdef CONFIG_FS_POSIX_ACL
+	struct posix_acl *acl;
+
+	if (mask & MAY_NOT_BLOCK) {
+		acl = get_cached_acl_rcu(inode, ACL_TYPE_ACCESS);
+	        if (!acl)
+	                return -EAGAIN;
+		/* no ->get_inode_acl() calls in RCU mode... */
+		if (is_uncached_acl(acl))
+			return -ECHILD;
+	        return posix_acl_permission(idmap, inode, acl, mask);
+	}
+
+	acl = get_inode_acl(inode, ACL_TYPE_ACCESS);
+	if (IS_ERR(acl))
+		return PTR_ERR(acl);
+	if (acl) {
+	        int error = posix_acl_permission(idmap, inode, acl, mask);
+	        posix_acl_release(acl);
+	        return error;
+	}
+#endif
+
+	return -EAGAIN;
+}
+
+/**
+ * acl_permission_check - perform basic UNIX permission checking
+ * @idmap:	idmap of the mount the inode was found from
+ * @inode:	inode to check permissions on
+ * @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...)
+ *
+ * This function performs the basic UNIX permission checking. Since this
+ * function may retrieve POSIX acls it needs to know whether it is called from a
+ * blocking or non-blocking context and thus cares about the MAY_NOT_BLOCK bit.
+ *
+ * If the inode has been found through an idmapped mount the idmap of
+ * the vfsmount must be passed through @idmap. This function will then take
+ * care to map the inode according to @idmap before checking permissions.
+ * On non-idmapped mounts or if permission checking is to be performed on the
+ * raw inode simply passs @nop_mnt_idmap.
+ */
+static int acl_permission_check(struct mnt_idmap *idmap,
+				struct inode *inode, int mask)
+{
+	unsigned int mode = inode->i_mode;
+	vfsuid_t vfsuid;
+
+	/* Are we the owner? If so, ACL's don't matter */
+	vfsuid = i_uid_into_vfsuid(idmap, inode);
+	if (likely(vfsuid_eq_kuid(vfsuid, current_fsuid()))) {
+		mask &= 7;
+		mode >>= 6;
+		return (mask & ~mode) ? -EACCES : 0;
+	}
+
+	/* Do we have ACL's? */
+	if (IS_POSIXACL(inode) && (mode & S_IRWXG)) {
+		int error = check_acl(idmap, inode, mask);
+		if (error != -EAGAIN)
+			return error;
+	}
+
+	/* Only RWX matters for group/other mode bits */
+	mask &= 7;
+
+	/*
+	 * Are the group permissions different from
+	 * the other permissions in the bits we care
+	 * about? Need to check group ownership if so.
+	 */
+	if (mask & (mode ^ (mode >> 3))) {
+		vfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode);
+		if (vfsgid_in_group_p(vfsgid))
+			mode >>= 3;
+	}
+
+	/* Bits in 'mode' clear that we require? */
+	return (mask & ~mode) ? -EACCES : 0;
+}
+
+/**
+ * generic_permission -  check for access rights on a Posix-like filesystem
+ * @idmap:	idmap of the mount the inode was found from
+ * @inode:	inode to check access rights for
+ * @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC,
+ *		%MAY_NOT_BLOCK ...)
+ *
+ * Used to check for read/write/execute permissions on a file.
+ * We use "fsuid" for this, letting us set arbitrary permissions
+ * for filesystem access without changing the "normal" uids which
+ * are used for other things.
+ *
+ * generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk
+ * request cannot be satisfied (eg. requires blocking or too much complexity).
+ * It would then be called again in ref-walk mode.
+ *
+ * If the inode has been found through an idmapped mount the idmap of
+ * the vfsmount must be passed through @idmap. This function will then take
+ * care to map the inode according to @idmap before checking permissions.
+ * On non-idmapped mounts or if permission checking is to be performed on the
+ * raw inode simply passs @nop_mnt_idmap.
+ */
+int generic_permission(struct mnt_idmap *idmap, struct inode *inode,
+		       int mask)
+{
+	int ret;
+
+	/*
+	 * Do the basic permission checks.
+	 */
+	ret = acl_permission_check(idmap, inode, mask);
+	if (ret != -EACCES)
+		return ret;
+
+	if (S_ISDIR(inode->i_mode)) {
+		/* DACs are overridable for directories */
+		if (!(mask & MAY_WRITE))
+			if (capable_wrt_inode_uidgid(idmap, inode,
+						     CAP_DAC_READ_SEARCH))
+				return 0;
+		if (capable_wrt_inode_uidgid(idmap, inode,
+					     CAP_DAC_OVERRIDE))
+			return 0;
+		return -EACCES;
+	}
+
+	/*
+	 * Searching includes executable on directories, else just read.
+	 */
+	mask &= MAY_READ | MAY_WRITE | MAY_EXEC;
+	if (mask == MAY_READ)
+		if (capable_wrt_inode_uidgid(idmap, inode,
+					     CAP_DAC_READ_SEARCH))
+			return 0;
+	/*
+	 * Read/write DACs are always overridable.
+	 * Executable DACs are overridable when there is
+	 * at least one exec bit set.
+	 */
+	if (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))
+		if (capable_wrt_inode_uidgid(idmap, inode,
+					     CAP_DAC_OVERRIDE))
+			return 0;
+
+	return -EACCES;
+}
+EXPORT_SYMBOL(generic_permission);
+
+/**
+ * do_inode_permission - UNIX permission checking
+ * @idmap:	idmap of the mount the inode was found from
+ * @inode:	inode to check permissions on
+ * @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...)
+ *
+ * We _really_ want to just do "generic_permission()" without
+ * even looking at the inode->i_op values. So we keep a cache
+ * flag in inode->i_opflags, that says "this has not special
+ * permission function, use the fast case".
+ */
+static inline int do_inode_permission(struct mnt_idmap *idmap,
+				      struct inode *inode, int mask)
+{
+	if (unlikely(!(inode->i_opflags & IOP_FASTPERM))) {
+		if (likely(inode->i_op->permission))
+			return inode->i_op->permission(idmap, inode, mask);
+
+		/* This gets set once for the inode lifetime */
+		spin_lock(&inode->i_lock);
+		inode->i_opflags |= IOP_FASTPERM;
+		spin_unlock(&inode->i_lock);
+	}
+	return generic_permission(idmap, inode, mask);
+}
+
+/**
+ * sb_permission - Check superblock-level permissions
+ * @sb: Superblock of inode to check permission on
+ * @inode: Inode to check permission on
+ * @mask: Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)
+ *
+ * Separate out file-system wide checks from inode-specific permission checks.
+ */
+static int sb_permission(struct super_block *sb, struct inode *inode, int mask)
+{
+	if (unlikely(mask & MAY_WRITE)) {
+		umode_t mode = inode->i_mode;
+
+		/* Nobody gets write access to a read-only fs. */
+		if (sb_rdonly(sb) && (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
+			return -EROFS;
+	}
+	return 0;
+}
+
+/**
+ * inode_permission - Check for access rights to a given inode
+ * @idmap:	idmap of the mount the inode was found from
+ * @inode:	Inode to check permission on
+ * @mask:	Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)
+ *
+ * Check for read/write/execute permissions on an inode.  We use fs[ug]id for
+ * this, letting us set arbitrary permissions for filesystem access without
+ * changing the "normal" UIDs which are used for other things.
+ *
+ * When checking for MAY_APPEND, MAY_WRITE must also be set in @mask.
+ */
+int inode_permission(struct mnt_idmap *idmap,
+		     struct inode *inode, int mask)
+{
+	int retval;
+
+	retval = sb_permission(inode->i_sb, inode, mask);
+	if (retval)
+		return retval;
+
+	if (unlikely(mask & MAY_WRITE)) {
+		/*
+		 * Nobody gets write access to an immutable file.
+		 */
+		if (IS_IMMUTABLE(inode))
+			return -EPERM;
+
+		/*
+		 * Updating mtime will likely cause i_uid and i_gid to be
+		 * written back improperly if their true value is unknown
+		 * to the vfs.
+		 */
+		if (HAS_UNMAPPED_ID(idmap, inode))
+			return -EACCES;
+	}
+
+	retval = do_inode_permission(idmap, inode, mask);
+	if (retval)
+		return retval;
+
+	retval = devcgroup_inode_permission(inode, mask);
+	if (retval)
+		return retval;
+
+	return security_inode_permission(inode, mask);
+}
+EXPORT_SYMBOL(inode_permission);
+
+/**
+ * path_get - get a reference to a path
+ * @path: path to get the reference to
+ *
+ * Given a path increment the reference count to the dentry and the vfsmount.
+ */
+void path_get(const struct path *path)
+{
+	mntget(path->mnt);
+	dget(path->dentry);
+}
+EXPORT_SYMBOL_NS(path_get, ANDROID_GKI_VFS_EXPORT_ONLY);
+
+/**
+ * path_put - put a reference to a path
+ * @path: path to put the reference to
+ *
+ * Given a path decrement the reference count to the dentry and the vfsmount.
+ */
+void path_put(const struct path *path)
+{
+	dput(path->dentry);
+	mntput(path->mnt);
+}
+EXPORT_SYMBOL(path_put);
+
+#define EMBEDDED_LEVELS 2
+struct nameidata {
+	struct path	path;
+	struct qstr	last;
+	struct path	root;
+	struct inode	*inode; /* path.dentry.d_inode */
+	unsigned int	flags, state;
+	unsigned	seq, next_seq, m_seq, r_seq;
+	int		last_type;
+	unsigned	depth;
+	int		total_link_count;
+	struct saved {
+		struct path link;
+		struct delayed_call done;
+		const char *name;
+		unsigned seq;
+	} *stack, internal[EMBEDDED_LEVELS];
+	struct filename	*name;
+	struct nameidata *saved;
+	unsigned	root_seq;
+	int		dfd;
+	vfsuid_t	dir_vfsuid;
+	umode_t		dir_mode;
+} __randomize_layout;
+
+#define ND_ROOT_PRESET 1
+#define ND_ROOT_GRABBED 2
+#define ND_JUMPED 4
+
+static void __set_nameidata(struct nameidata *p, int dfd, struct filename *name)
+{
+	struct nameidata *old = current->nameidata;
+	p->stack = p->internal;
+	p->depth = 0;
+	p->dfd = dfd;
+	p->name = name;
+	p->path.mnt = NULL;
+	p->path.dentry = NULL;
+	p->total_link_count = old ? old->total_link_count : 0;
+	p->saved = old;
+	current->nameidata = p;
+}
+
+static inline void set_nameidata(struct nameidata *p, int dfd, struct filename *name,
+			  const struct path *root)
+{
+	__set_nameidata(p, dfd, name);
+	p->state = 0;
+	if (unlikely(root)) {
+		p->state = ND_ROOT_PRESET;
+		p->root = *root;
+	}
+}
+
+static void restore_nameidata(void)
+{
+	struct nameidata *now = current->nameidata, *old = now->saved;
+
+	current->nameidata = old;
+	if (old)
+		old->total_link_count = now->total_link_count;
+	if (now->stack != now->internal)
+		kfree(now->stack);
+}
+
+static bool nd_alloc_stack(struct nameidata *nd)
+{
+	struct saved *p;
+
+	p= kmalloc_array(MAXSYMLINKS, sizeof(struct saved),
+			 nd->flags & LOOKUP_RCU ? GFP_ATOMIC : GFP_KERNEL);
+	if (unlikely(!p))
+		return false;
+	memcpy(p, nd->internal, sizeof(nd->internal));
+	nd->stack = p;
+	return true;
+}
+
+/**
+ * path_connected - Verify that a dentry is below mnt.mnt_root
+ * @mnt: The mountpoint to check.
+ * @dentry: The dentry to check.
+ *
+ * Rename can sometimes move a file or directory outside of a bind
+ * mount, path_connected allows those cases to be detected.
+ */
+static bool path_connected(struct vfsmount *mnt, struct dentry *dentry)
+{
+	struct super_block *sb = mnt->mnt_sb;
+
+	/* Bind mounts can have disconnected paths */
+	if (mnt->mnt_root == sb->s_root)
+		return true;
+
+	return is_subdir(dentry, mnt->mnt_root);
+}
+
+static void drop_links(struct nameidata *nd)
+{
+	int i = nd->depth;
+	while (i--) {
+		struct saved *last = nd->stack + i;
+		do_delayed_call(&last->done);
+		clear_delayed_call(&last->done);
+	}
+}
+
+static void leave_rcu(struct nameidata *nd)
+{
+	nd->flags &= ~LOOKUP_RCU;
+	nd->seq = nd->next_seq = 0;
+	rcu_read_unlock();
+}
+
+static void terminate_walk(struct nameidata *nd)
+{
+	drop_links(nd);
+	if (!(nd->flags & LOOKUP_RCU)) {
+		int i;
+		path_put(&nd->path);
+		for (i = 0; i < nd->depth; i++)
+			path_put(&nd->stack[i].link);
+		if (nd->state & ND_ROOT_GRABBED) {
+			path_put(&nd->root);
+			nd->state &= ~ND_ROOT_GRABBED;
+		}
+	} else {
+		leave_rcu(nd);
+	}
+	nd->depth = 0;
+	nd->path.mnt = NULL;
+	nd->path.dentry = NULL;
+}
+
+/* path_put is needed afterwards regardless of success or failure */
+static bool __legitimize_path(struct path *path, unsigned seq, unsigned mseq)
+{
+	int res = __legitimize_mnt(path->mnt, mseq);
+	if (unlikely(res)) {
+		if (res > 0)
+			path->mnt = NULL;
+		path->dentry = NULL;
+		return false;
+	}
+	if (unlikely(!lockref_get_not_dead(&path->dentry->d_lockref))) {
+		path->dentry = NULL;
+		return false;
+	}
+	return !read_seqcount_retry(&path->dentry->d_seq, seq);
+}
+
+static inline bool legitimize_path(struct nameidata *nd,
+			    struct path *path, unsigned seq)
+{
+	return __legitimize_path(path, seq, nd->m_seq);
+}
+
+static bool legitimize_links(struct nameidata *nd)
+{
+	int i;
+	if (unlikely(nd->flags & LOOKUP_CACHED)) {
+		drop_links(nd);
+		nd->depth = 0;
+		return false;
+	}
+	for (i = 0; i < nd->depth; i++) {
+		struct saved *last = nd->stack + i;
+		if (unlikely(!legitimize_path(nd, &last->link, last->seq))) {
+			drop_links(nd);
+			nd->depth = i + 1;
+			return false;
+		}
+	}
+	return true;
+}
+
+static bool legitimize_root(struct nameidata *nd)
+{
+	/* Nothing to do if nd->root is zero or is managed by the VFS user. */
+	if (!nd->root.mnt || (nd->state & ND_ROOT_PRESET))
+		return true;
+	nd->state |= ND_ROOT_GRABBED;
+	return legitimize_path(nd, &nd->root, nd->root_seq);
+}
+
+/*
+ * Path walking has 2 modes, rcu-walk and ref-walk (see
+ * Documentation/filesystems/path-lookup.txt).  In situations when we can't
+ * continue in RCU mode, we attempt to drop out of rcu-walk mode and grab
+ * normal reference counts on dentries and vfsmounts to transition to ref-walk
+ * mode.  Refcounts are grabbed at the last known good point before rcu-walk
+ * got stuck, so ref-walk may continue from there. If this is not successful
+ * (eg. a seqcount has changed), then failure is returned and it's up to caller
+ * to restart the path walk from the beginning in ref-walk mode.
+ */
+
+/**
+ * try_to_unlazy - try to switch to ref-walk mode.
+ * @nd: nameidata pathwalk data
+ * Returns: true on success, false on failure
+ *
+ * try_to_unlazy attempts to legitimize the current nd->path and nd->root
+ * for ref-walk mode.
+ * Must be called from rcu-walk context.
+ * Nothing should touch nameidata between try_to_unlazy() failure and
+ * terminate_walk().
+ */
+static bool try_to_unlazy(struct nameidata *nd)
+{
+	struct dentry *parent = nd->path.dentry;
+
+	BUG_ON(!(nd->flags & LOOKUP_RCU));
+
+	if (unlikely(!legitimize_links(nd)))
+		goto out1;
+	if (unlikely(!legitimize_path(nd, &nd->path, nd->seq)))
+		goto out;
+	if (unlikely(!legitimize_root(nd)))
+		goto out;
+	leave_rcu(nd);
+	BUG_ON(nd->inode != parent->d_inode);
+	return true;
+
+out1:
+	nd->path.mnt = NULL;
+	nd->path.dentry = NULL;
+out:
+	leave_rcu(nd);
+	return false;
+}
+
+/**
+ * try_to_unlazy_next - try to switch to ref-walk mode.
+ * @nd: nameidata pathwalk data
+ * @dentry: next dentry to step into
+ * Returns: true on success, false on failure
+ *
+ * Similar to try_to_unlazy(), but here we have the next dentry already
+ * picked by rcu-walk and want to legitimize that in addition to the current
+ * nd->path and nd->root for ref-walk mode.  Must be called from rcu-walk context.
+ * Nothing should touch nameidata between try_to_unlazy_next() failure and
+ * terminate_walk().
+ */
+static bool try_to_unlazy_next(struct nameidata *nd, struct dentry *dentry)
+{
+	int res;
+	BUG_ON(!(nd->flags & LOOKUP_RCU));
+
+	if (unlikely(!legitimize_links(nd)))
+		goto out2;
+	res = __legitimize_mnt(nd->path.mnt, nd->m_seq);
+	if (unlikely(res)) {
+		if (res > 0)
+			goto out2;
+		goto out1;
+	}
+	if (unlikely(!lockref_get_not_dead(&nd->path.dentry->d_lockref)))
+		goto out1;
+
+	/*
+	 * We need to move both the parent and the dentry from the RCU domain
+	 * to be properly refcounted. And the sequence number in the dentry
+	 * validates *both* dentry counters, since we checked the sequence
+	 * number of the parent after we got the child sequence number. So we
+	 * know the parent must still be valid if the child sequence number is
+	 */
+	if (unlikely(!lockref_get_not_dead(&dentry->d_lockref)))
+		goto out;
+	if (read_seqcount_retry(&dentry->d_seq, nd->next_seq))
+		goto out_dput;
+	/*
+	 * Sequence counts matched. Now make sure that the root is
+	 * still valid and get it if required.
+	 */
+	if (unlikely(!legitimize_root(nd)))
+		goto out_dput;
+	leave_rcu(nd);
+	return true;
+
+out2:
+	nd->path.mnt = NULL;
+out1:
+	nd->path.dentry = NULL;
+out:
+	leave_rcu(nd);
+	return false;
+out_dput:
+	leave_rcu(nd);
+	dput(dentry);
+	return false;
+}
+
+static inline int d_revalidate(struct dentry *dentry, unsigned int flags)
+{
+	if (unlikely(dentry->d_flags & DCACHE_OP_REVALIDATE))
+		return dentry->d_op->d_revalidate(dentry, flags);
+	else
+		return 1;
+}
+
+/**
+ * complete_walk - successful completion of path walk
+ * @nd:  pointer nameidata
+ *
+ * If we had been in RCU mode, drop out of it and legitimize nd->path.
+ * Revalidate the final result, unless we'd already done that during
+ * the path walk or the filesystem doesn't ask for it.  Return 0 on
+ * success, -error on failure.  In case of failure caller does not
+ * need to drop nd->path.
+ */
+static int complete_walk(struct nameidata *nd)
+{
+	struct dentry *dentry = nd->path.dentry;
+	int status;
+
+	if (nd->flags & LOOKUP_RCU) {
+		/*
+		 * We don't want to zero nd->root for scoped-lookups or
+		 * externally-managed nd->root.
+		 */
+		if (!(nd->state & ND_ROOT_PRESET))
+			if (!(nd->flags & LOOKUP_IS_SCOPED))
+				nd->root.mnt = NULL;
+		nd->flags &= ~LOOKUP_CACHED;
+		if (!try_to_unlazy(nd))
+			return -ECHILD;
+	}
+
+	if (unlikely(nd->flags & LOOKUP_IS_SCOPED)) {
+		/*
+		 * While the guarantee of LOOKUP_IS_SCOPED is (roughly) "don't
+		 * ever step outside the root during lookup" and should already
+		 * be guaranteed by the rest of namei, we want to avoid a namei
+		 * BUG resulting in userspace being given a path that was not
+		 * scoped within the root at some point during the lookup.
+		 *
+		 * So, do a final sanity-check to make sure that in the
+		 * worst-case scenario (a complete bypass of LOOKUP_IS_SCOPED)
+		 * we won't silently return an fd completely outside of the
+		 * requested root to userspace.
+		 *
+		 * Userspace could move the path outside the root after this
+		 * check, but as discussed elsewhere this is not a concern (the
+		 * resolved file was inside the root at some point).
+		 */
+		if (!path_is_under(&nd->path, &nd->root))
+			return -EXDEV;
+	}
+
+	if (likely(!(nd->state & ND_JUMPED)))
+		return 0;
+
+	if (likely(!(dentry->d_flags & DCACHE_OP_WEAK_REVALIDATE)))
+		return 0;
+
+	status = dentry->d_op->d_weak_revalidate(dentry, nd->flags);
+	if (status > 0)
+		return 0;
+
+	if (!status)
+		status = -ESTALE;
+
+	return status;
+}
+
+static int set_root(struct nameidata *nd)
+{
+	struct fs_struct *fs = current->fs;
+
+	/*
+	 * Jumping to the real root in a scoped-lookup is a BUG in namei, but we
+	 * still have to ensure it doesn't happen because it will cause a breakout
+	 * from the dirfd.
+	 */
+	if (WARN_ON(nd->flags & LOOKUP_IS_SCOPED))
+		return -ENOTRECOVERABLE;
+
+	if (nd->flags & LOOKUP_RCU) {
+		unsigned seq;
+
+		do {
+			seq = read_seqcount_begin(&fs->seq);
+			nd->root = fs->root;
+			nd->root_seq = __read_seqcount_begin(&nd->root.dentry->d_seq);
+		} while (read_seqcount_retry(&fs->seq, seq));
+	} else {
+		get_fs_root(fs, &nd->root);
+		nd->state |= ND_ROOT_GRABBED;
+	}
+	return 0;
+}
+
+static int nd_jump_root(struct nameidata *nd)
+{
+	if (unlikely(nd->flags & LOOKUP_BENEATH))
+		return -EXDEV;
+	if (unlikely(nd->flags & LOOKUP_NO_XDEV)) {
+		/* Absolute path arguments to path_init() are allowed. */
+		if (nd->path.mnt != NULL && nd->path.mnt != nd->root.mnt)
+			return -EXDEV;
+	}
+	if (!nd->root.mnt) {
+		int error = set_root(nd);
+		if (error)
+			return error;
+	}
+	if (nd->flags & LOOKUP_RCU) {
+		struct dentry *d;
+		nd->path = nd->root;
+		d = nd->path.dentry;
+		nd->inode = d->d_inode;
+		nd->seq = nd->root_seq;
+		if (read_seqcount_retry(&d->d_seq, nd->seq))
+			return -ECHILD;
+	} else {
+		path_put(&nd->path);
+		nd->path = nd->root;
+		path_get(&nd->path);
+		nd->inode = nd->path.dentry->d_inode;
+	}
+	nd->state |= ND_JUMPED;
+	return 0;
+}
+
+/*
+ * Helper to directly jump to a known parsed path from ->get_link,
+ * caller must have taken a reference to path beforehand.
+ */
+int nd_jump_link(const struct path *path)
+{
+	int error = -ELOOP;
+	struct nameidata *nd = current->nameidata;
+
+	if (unlikely(nd->flags & LOOKUP_NO_MAGICLINKS))
+		goto err;
+
+	error = -EXDEV;
+	if (unlikely(nd->flags & LOOKUP_NO_XDEV)) {
+		if (nd->path.mnt != path->mnt)
+			goto err;
+	}
+	/* Not currently safe for scoped-lookups. */
+	if (unlikely(nd->flags & LOOKUP_IS_SCOPED))
+		goto err;
+
+	path_put(&nd->path);
+	nd->path = *path;
+	nd->inode = nd->path.dentry->d_inode;
+	nd->state |= ND_JUMPED;
+	return 0;
+
+err:
+	path_put(path);
+	return error;
+}
+
+static inline void put_link(struct nameidata *nd)
+{
+	struct saved *last = nd->stack + --nd->depth;
+	do_delayed_call(&last->done);
+	if (!(nd->flags & LOOKUP_RCU))
+		path_put(&last->link);
+}
+
+static int sysctl_protected_symlinks __read_mostly;
+static int sysctl_protected_hardlinks __read_mostly;
+static int sysctl_protected_fifos __read_mostly;
+static int sysctl_protected_regular __read_mostly;
+
+#ifdef CONFIG_SYSCTL
+static struct ctl_table namei_sysctls[] = {
+	{
+		.procname	= "protected_symlinks",
+		.data		= &sysctl_protected_symlinks,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_ONE,
+	},
+	{
+		.procname	= "protected_hardlinks",
+		.data		= &sysctl_protected_hardlinks,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_ONE,
+	},
+	{
+		.procname	= "protected_fifos",
+		.data		= &sysctl_protected_fifos,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_TWO,
+	},
+	{
+		.procname	= "protected_regular",
+		.data		= &sysctl_protected_regular,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_TWO,
+	},
+	{ }
+};
+
+static int __init init_fs_namei_sysctls(void)
+{
+	register_sysctl_init("fs", namei_sysctls);
+	return 0;
+}
+fs_initcall(init_fs_namei_sysctls);
+
+#endif /* CONFIG_SYSCTL */
+
+/**
+ * may_follow_link - Check symlink following for unsafe situations
+ * @nd: nameidata pathwalk data
+ * @inode: Used for idmapping.
+ *
+ * In the case of the sysctl_protected_symlinks sysctl being enabled,
+ * CAP_DAC_OVERRIDE needs to be specifically ignored if the symlink is
+ * in a sticky world-writable directory. This is to protect privileged
+ * processes from failing races against path names that may change out
+ * from under them by way of other users creating malicious symlinks.
+ * It will permit symlinks to be followed only when outside a sticky
+ * world-writable directory, or when the uid of the symlink and follower
+ * match, or when the directory owner matches the symlink's owner.
+ *
+ * Returns 0 if following the symlink is allowed, -ve on error.
+ */
+static inline int may_follow_link(struct nameidata *nd, const struct inode *inode)
+{
+	struct mnt_idmap *idmap;
+	vfsuid_t vfsuid;
+
+	if (!sysctl_protected_symlinks)
+		return 0;
+
+	idmap = mnt_idmap(nd->path.mnt);
+	vfsuid = i_uid_into_vfsuid(idmap, inode);
+	/* Allowed if owner and follower match. */
+	if (vfsuid_eq_kuid(vfsuid, current_fsuid()))
+		return 0;
+
+	/* Allowed if parent directory not sticky and world-writable. */
+	if ((nd->dir_mode & (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH))
+		return 0;
+
+	/* Allowed if parent directory and link owner match. */
+	if (vfsuid_valid(nd->dir_vfsuid) && vfsuid_eq(nd->dir_vfsuid, vfsuid))
+		return 0;
+
+	if (nd->flags & LOOKUP_RCU)
+		return -ECHILD;
+
+	audit_inode(nd->name, nd->stack[0].link.dentry, 0);
+	audit_log_path_denied(AUDIT_ANOM_LINK, "follow_link");
+	return -EACCES;
+}
+
+/**
+ * safe_hardlink_source - Check for safe hardlink conditions
+ * @idmap: idmap of the mount the inode was found from
+ * @inode: the source inode to hardlink from
+ *
+ * Return false if at least one of the following conditions:
+ *    - inode is not a regular file
+ *    - inode is setuid
+ *    - inode is setgid and group-exec
+ *    - access failure for read and write
+ *
+ * Otherwise returns true.
+ */
+static bool safe_hardlink_source(struct mnt_idmap *idmap,
+				 struct inode *inode)
+{
+	umode_t mode = inode->i_mode;
+
+	/* Special files should not get pinned to the filesystem. */
+	if (!S_ISREG(mode))
+		return false;
+
+	/* Setuid files should not get pinned to the filesystem. */
+	if (mode & S_ISUID)
+		return false;
+
+	/* Executable setgid files should not get pinned to the filesystem. */
+	if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))
+		return false;
+
+	/* Hardlinking to unreadable or unwritable sources is dangerous. */
+	if (inode_permission(idmap, inode, MAY_READ | MAY_WRITE))
+		return false;
+
+	return true;
+}
+
+/**
+ * may_linkat - Check permissions for creating a hardlink
+ * @idmap: idmap of the mount the inode was found from
+ * @link:  the source to hardlink from
+ *
+ * Block hardlink when all of:
+ *  - sysctl_protected_hardlinks enabled
+ *  - fsuid does not match inode
+ *  - hardlink source is unsafe (see safe_hardlink_source() above)
+ *  - not CAP_FOWNER in a namespace with the inode owner uid mapped
+ *
+ * If the inode has been found through an idmapped mount the idmap of
+ * the vfsmount must be passed through @idmap. This function will then take
+ * care to map the inode according to @idmap before checking permissions.
+ * On non-idmapped mounts or if permission checking is to be performed on the
+ * raw inode simply pass @nop_mnt_idmap.
+ *
+ * Returns 0 if successful, -ve on error.
+ */
+int may_linkat(struct mnt_idmap *idmap, const struct path *link)
+{
+	struct inode *inode = link->dentry->d_inode;
+
+	/* Inode writeback is not safe when the uid or gid are invalid. */
+	if (!vfsuid_valid(i_uid_into_vfsuid(idmap, inode)) ||
+	    !vfsgid_valid(i_gid_into_vfsgid(idmap, inode)))
+		return -EOVERFLOW;
+
+	if (!sysctl_protected_hardlinks)
+		return 0;
+
+	/* Source inode owner (or CAP_FOWNER) can hardlink all they like,
+	 * otherwise, it must be a safe source.
+	 */
+	if (safe_hardlink_source(idmap, inode) ||
+	    inode_owner_or_capable(idmap, inode))
+		return 0;
+
+	audit_log_path_denied(AUDIT_ANOM_LINK, "linkat");
+	return -EPERM;
+}
+
+/**
+ * may_create_in_sticky - Check whether an O_CREAT open in a sticky directory
+ *			  should be allowed, or not, on files that already
+ *			  exist.
+ * @idmap: idmap of the mount the inode was found from
+ * @nd: nameidata pathwalk data
+ * @inode: the inode of the file to open
+ *
+ * Block an O_CREAT open of a FIFO (or a regular file) when:
+ *   - sysctl_protected_fifos (or sysctl_protected_regular) is enabled
+ *   - the file already exists
+ *   - we are in a sticky directory
+ *   - we don't own the file
+ *   - the owner of the directory doesn't own the file
+ *   - the directory is world writable
+ * If the sysctl_protected_fifos (or sysctl_protected_regular) is set to 2
+ * the directory doesn't have to be world writable: being group writable will
+ * be enough.
+ *
+ * If the inode has been found through an idmapped mount the idmap of
+ * the vfsmount must be passed through @idmap. This function will then take
+ * care to map the inode according to @idmap before checking permissions.
+ * On non-idmapped mounts or if permission checking is to be performed on the
+ * raw inode simply pass @nop_mnt_idmap.
+ *
+ * Returns 0 if the open is allowed, -ve on error.
+ */
+static int may_create_in_sticky(struct mnt_idmap *idmap,
+				struct nameidata *nd, struct inode *const inode)
+{
+	umode_t dir_mode = nd->dir_mode;
+	vfsuid_t dir_vfsuid = nd->dir_vfsuid;
+
+	if ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||
+	    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||
+	    likely(!(dir_mode & S_ISVTX)) ||
+	    vfsuid_eq(i_uid_into_vfsuid(idmap, inode), dir_vfsuid) ||
+	    vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, inode), current_fsuid()))
+		return 0;
+
+	if (likely(dir_mode & 0002) ||
+	    (dir_mode & 0020 &&
+	     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||
+	      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {
+		const char *operation = S_ISFIFO(inode->i_mode) ?
+					"sticky_create_fifo" :
+					"sticky_create_regular";
+		audit_log_path_denied(AUDIT_ANOM_CREAT, operation);
+		return -EACCES;
+	}
+	return 0;
+}
+
+/*
+ * follow_up - Find the mountpoint of path's vfsmount
+ *
+ * Given a path, find the mountpoint of its source file system.
+ * Replace @path with the path of the mountpoint in the parent mount.
+ * Up is towards /.
+ *
+ * Return 1 if we went up a level and 0 if we were already at the
+ * root.
+ */
+int follow_up(struct path *path)
+{
+	struct mount *mnt = real_mount(path->mnt);
+	struct mount *parent;
+	struct dentry *mountpoint;
+
+	read_seqlock_excl(&mount_lock);
+	parent = mnt->mnt_parent;
+	if (parent == mnt) {
+		read_sequnlock_excl(&mount_lock);
+		return 0;
+	}
+	mntget(&parent->mnt);
+	mountpoint = dget(mnt->mnt_mountpoint);
+	read_sequnlock_excl(&mount_lock);
+	dput(path->dentry);
+	path->dentry = mountpoint;
+	mntput(path->mnt);
+	path->mnt = &parent->mnt;
+	return 1;
+}
+EXPORT_SYMBOL(follow_up);
+
+static bool choose_mountpoint_rcu(struct mount *m, const struct path *root,
+				  struct path *path, unsigned *seqp)
+{
+	while (mnt_has_parent(m)) {
+		struct dentry *mountpoint = m->mnt_mountpoint;
+
+		m = m->mnt_parent;
+		if (unlikely(root->dentry == mountpoint &&
+			     root->mnt == &m->mnt))
+			break;
+		if (mountpoint != m->mnt.mnt_root) {
+			path->mnt = &m->mnt;
+			path->dentry = mountpoint;
+			*seqp = read_seqcount_begin(&mountpoint->d_seq);
+			return true;
+		}
+	}
+	return false;
+}
+
+static bool choose_mountpoint(struct mount *m, const struct path *root,
+			      struct path *path)
+{
+	bool found;
+
+	rcu_read_lock();
+	while (1) {
+		unsigned seq, mseq = read_seqbegin(&mount_lock);
+
+		found = choose_mountpoint_rcu(m, root, path, &seq);
+		if (unlikely(!found)) {
+			if (!read_seqretry(&mount_lock, mseq))
+				break;
+		} else {
+			if (likely(__legitimize_path(path, seq, mseq)))
+				break;
+			rcu_read_unlock();
+			path_put(path);
+			rcu_read_lock();
+		}
+	}
+	rcu_read_unlock();
+	return found;
+}
+
+/*
+ * Perform an automount
+ * - return -EISDIR to tell follow_managed() to stop and return the path we
+ *   were called with.
+ */
+static int follow_automount(struct path *path, int *count, unsigned lookup_flags)
+{
+	struct dentry *dentry = path->dentry;
+
+	/* We don't want to mount if someone's just doing a stat -
+	 * unless they're stat'ing a directory and appended a '/' to
+	 * the name.
+	 *
+	 * We do, however, want to mount if someone wants to open or
+	 * create a file of any type under the mountpoint, wants to
+	 * traverse through the mountpoint or wants to open the
+	 * mounted directory.  Also, autofs may mark negative dentries
+	 * as being automount points.  These will need the attentions
+	 * of the daemon to instantiate them before they can be used.
+	 */
+	if (!(lookup_flags & (LOOKUP_PARENT | LOOKUP_DIRECTORY |
+			   LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_AUTOMOUNT)) &&
+	    dentry->d_inode)
+		return -EISDIR;
+
+	/* No need to trigger automounts if mountpoint crossing is disabled. */
+	if (lookup_flags & LOOKUP_NO_XDEV)
+		return -EXDEV;
+
+	if (count && (*count)++ >= MAXSYMLINKS)
+		return -ELOOP;
+
+	return finish_automount(dentry->d_op->d_automount(path), path);
+}
+
+/*
+ * mount traversal - out-of-line part.  One note on ->d_flags accesses -
+ * dentries are pinned but not locked here, so negative dentry can go
+ * positive right under us.  Use of smp_load_acquire() provides a barrier
+ * sufficient for ->d_inode and ->d_flags consistency.
+ */
+static int __traverse_mounts(struct path *path, unsigned flags, bool *jumped,
+			     int *count, unsigned lookup_flags)
+{
+	struct vfsmount *mnt = path->mnt;
+	bool need_mntput = false;
+	int ret = 0;
+
+	while (flags & DCACHE_MANAGED_DENTRY) {
+		/* Allow the filesystem to manage the transit without i_mutex
+		 * being held. */
+		if (flags & DCACHE_MANAGE_TRANSIT) {
+			if (lookup_flags & LOOKUP_NO_XDEV) {
+				ret = -EXDEV;
+				break;
+			}
+			ret = path->dentry->d_op->d_manage(path, false);
+			flags = smp_load_acquire(&path->dentry->d_flags);
+			if (ret < 0)
+				break;
+		}
+
+		if (flags & DCACHE_MOUNTED) {	// something's mounted on it..
+			struct vfsmount *mounted = lookup_mnt(path);
+			if (mounted) {		// ... in our namespace
+				dput(path->dentry);
+				if (need_mntput)
+					mntput(path->mnt);
+				path->mnt = mounted;
+				path->dentry = dget(mounted->mnt_root);
+				// here we know it's positive
+				flags = path->dentry->d_flags;
+				need_mntput = true;
+				continue;
+			}
+		}
+
+		if (!(flags & DCACHE_NEED_AUTOMOUNT))
+			break;
+
+		// uncovered automount point
+		ret = follow_automount(path, count, lookup_flags);
+		flags = smp_load_acquire(&path->dentry->d_flags);
+		if (ret < 0)
+			break;
+	}
+
+	if (ret == -EISDIR)
+		ret = 0;
+	// possible if you race with several mount --move
+	if (need_mntput && path->mnt == mnt)
+		mntput(path->mnt);
+	if (!ret && unlikely(d_flags_negative(flags)))
+		ret = -ENOENT;
+	*jumped = need_mntput;
+	return ret;
+}
+
+static inline int traverse_mounts(struct path *path, bool *jumped,
+				  int *count, unsigned lookup_flags)
+{
+	unsigned flags = smp_load_acquire(&path->dentry->d_flags);
+
+	/* fastpath */
+	if (likely(!(flags & DCACHE_MANAGED_DENTRY))) {
+		*jumped = false;
+		if (unlikely(d_flags_negative(flags)))
+			return -ENOENT;
+		return 0;
+	}
+	return __traverse_mounts(path, flags, jumped, count, lookup_flags);
+}
+
+int follow_down_one(struct path *path)
+{
+	struct vfsmount *mounted;
+
+	mounted = lookup_mnt(path);
+	if (mounted) {
+		dput(path->dentry);
+		mntput(path->mnt);
+		path->mnt = mounted;
+		path->dentry = dget(mounted->mnt_root);
+		return 1;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(follow_down_one);
+
+/*
+ * Follow down to the covering mount currently visible to userspace.  At each
+ * point, the filesystem owning that dentry may be queried as to whether the
+ * caller is permitted to proceed or not.
+ */
+int follow_down(struct path *path, unsigned int flags)
+{
+	struct vfsmount *mnt = path->mnt;
+	bool jumped;
+	int ret = traverse_mounts(path, &jumped, NULL, flags);
+
+	if (path->mnt != mnt)
+		mntput(mnt);
+	return ret;
+}
+EXPORT_SYMBOL(follow_down);
+
+/*
+ * Try to skip to top of mountpoint pile in rcuwalk mode.  Fail if
+ * we meet a managed dentry that would need blocking.
+ */
+static bool __follow_mount_rcu(struct nameidata *nd, struct path *path)
+{
+	struct dentry *dentry = path->dentry;
+	unsigned int flags = dentry->d_flags;
+
+	if (likely(!(flags & DCACHE_MANAGED_DENTRY)))
+		return true;
+
+	if (unlikely(nd->flags & LOOKUP_NO_XDEV))
+		return false;
+
+	for (;;) {
+		/*
+		 * Don't forget we might have a non-mountpoint managed dentry
+		 * that wants to block transit.
+		 */
+		if (unlikely(flags & DCACHE_MANAGE_TRANSIT)) {
+			int res = dentry->d_op->d_manage(path, true);
+			if (res)
+				return res == -EISDIR;
+			flags = dentry->d_flags;
+		}
+
+		if (flags & DCACHE_MOUNTED) {
+			struct mount *mounted = __lookup_mnt(path->mnt, dentry);
+			if (mounted) {
+				path->mnt = &mounted->mnt;
+				dentry = path->dentry = mounted->mnt.mnt_root;
+				nd->state |= ND_JUMPED;
+				nd->next_seq = read_seqcount_begin(&dentry->d_seq);
+				flags = dentry->d_flags;
+				// makes sure that non-RCU pathwalk could reach
+				// this state.
+				if (read_seqretry(&mount_lock, nd->m_seq))
+					return false;
+				continue;
+			}
+			if (read_seqretry(&mount_lock, nd->m_seq))
+				return false;
+		}
+		return !(flags & DCACHE_NEED_AUTOMOUNT);
+	}
+}
+
+static inline int handle_mounts(struct nameidata *nd, struct dentry *dentry,
+			  struct path *path)
+{
+	bool jumped;
+	int ret;
+
+	path->mnt = nd->path.mnt;
+	path->dentry = dentry;
+	if (nd->flags & LOOKUP_RCU) {
+		unsigned int seq = nd->next_seq;
+		if (likely(__follow_mount_rcu(nd, path)))
+			return 0;
+		// *path and nd->next_seq might've been clobbered
+		path->mnt = nd->path.mnt;
+		path->dentry = dentry;
+		nd->next_seq = seq;
+		if (!try_to_unlazy_next(nd, dentry))
+			return -ECHILD;
+	}
+	ret = traverse_mounts(path, &jumped, &nd->total_link_count, nd->flags);
+	if (jumped) {
+		if (unlikely(nd->flags & LOOKUP_NO_XDEV))
+			ret = -EXDEV;
+		else
+			nd->state |= ND_JUMPED;
+	}
+	if (unlikely(ret)) {
+		dput(path->dentry);
+		if (path->mnt != nd->path.mnt)
+			mntput(path->mnt);
+	}
+	return ret;
+}
+
+/*
+ * This looks up the name in dcache and possibly revalidates the found dentry.
+ * NULL is returned if the dentry does not exist in the cache.
+ */
+static struct dentry *lookup_dcache(const struct qstr *name,
+				    struct dentry *dir,
+				    unsigned int flags)
+{
+	struct dentry *dentry = d_lookup(dir, name);
+	if (dentry) {
+		int error = d_revalidate(dentry, flags);
+		if (unlikely(error <= 0)) {
+			if (!error)
+				d_invalidate(dentry);
+			dput(dentry);
+			return ERR_PTR(error);
+		}
+	}
+	return dentry;
+}
+
+/*
+ * Parent directory has inode locked exclusive.  This is one
+ * and only case when ->lookup() gets called on non in-lookup
+ * dentries - as the matter of fact, this only gets called
+ * when directory is guaranteed to have no in-lookup children
+ * at all.
+ */
+struct dentry *lookup_one_qstr_excl(const struct qstr *name,
+				    struct dentry *base,
+				    unsigned int flags)
+{
+	struct dentry *dentry = lookup_dcache(name, base, flags);
+	struct dentry *old;
+	struct inode *dir = base->d_inode;
+
+	if (dentry)
+		return dentry;
+
+	/* Don't create child dentry for a dead directory. */
+	if (unlikely(IS_DEADDIR(dir)))
+		return ERR_PTR(-ENOENT);
+
+	dentry = d_alloc(base, name);
+	if (unlikely(!dentry))
+		return ERR_PTR(-ENOMEM);
+
+	old = dir->i_op->lookup(dir, dentry, flags);
+	if (unlikely(old)) {
+		dput(dentry);
+		dentry = old;
+	}
+	return dentry;
+}
+EXPORT_SYMBOL(lookup_one_qstr_excl);
+
+static struct dentry *lookup_fast(struct nameidata *nd)
+{
+	struct dentry *dentry, *parent = nd->path.dentry;
+	int status = 1;
+
+	/*
+	 * Rename seqlock is not required here because in the off chance
+	 * of a false negative due to a concurrent rename, the caller is
+	 * going to fall back to non-racy lookup.
+	 */
+	if (nd->flags & LOOKUP_RCU) {
+		dentry = __d_lookup_rcu(parent, &nd->last, &nd->next_seq);
+		if (unlikely(!dentry)) {
+			if (!try_to_unlazy(nd))
+				return ERR_PTR(-ECHILD);
+			return NULL;
+		}
+
+		/*
+		 * This sequence count validates that the parent had no
+		 * changes while we did the lookup of the dentry above.
+		 */
+		if (read_seqcount_retry(&parent->d_seq, nd->seq))
+			return ERR_PTR(-ECHILD);
+
+		status = d_revalidate(dentry, nd->flags);
+		if (likely(status > 0))
+			return dentry;
+		if (!try_to_unlazy_next(nd, dentry))
+			return ERR_PTR(-ECHILD);
+		if (status == -ECHILD)
+			/* we'd been told to redo it in non-rcu mode */
+			status = d_revalidate(dentry, nd->flags);
+	} else {
+		dentry = __d_lookup(parent, &nd->last);
+		if (unlikely(!dentry))
+			return NULL;
+		status = d_revalidate(dentry, nd->flags);
+	}
+	if (unlikely(status <= 0)) {
+		if (!status)
+			d_invalidate(dentry);
+		dput(dentry);
+		return ERR_PTR(status);
+	}
+	return dentry;
+}
+
+/* Fast lookup failed, do it the slow way */
+static struct dentry *__lookup_slow(const struct qstr *name,
+				    struct dentry *dir,
+				    unsigned int flags)
+{
+	struct dentry *dentry, *old;
+	struct inode *inode = dir->d_inode;
+	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);
+
+	/* Don't go there if it's already dead */
+	if (unlikely(IS_DEADDIR(inode)))
+		return ERR_PTR(-ENOENT);
+again:
+	dentry = d_alloc_parallel(dir, name, &wq);
+	if (IS_ERR(dentry))
+		return dentry;
+	if (unlikely(!d_in_lookup(dentry))) {
+		int error = d_revalidate(dentry, flags);
+		if (unlikely(error <= 0)) {
+			if (!error) {
+				d_invalidate(dentry);
+				dput(dentry);
+				goto again;
+			}
+			dput(dentry);
+			dentry = ERR_PTR(error);
+		}
+	} else {
+		old = inode->i_op->lookup(inode, dentry, flags);
+		d_lookup_done(dentry);
+		if (unlikely(old)) {
+			dput(dentry);
+			dentry = old;
+		}
+	}
+	return dentry;
+}
+
+static struct dentry *lookup_slow(const struct qstr *name,
+				  struct dentry *dir,
+				  unsigned int flags)
+{
+	struct inode *inode = dir->d_inode;
+	struct dentry *res;
+	inode_lock_shared(inode);
+	res = __lookup_slow(name, dir, flags);
+	inode_unlock_shared(inode);
+	return res;
+}
+
+static inline int may_lookup(struct mnt_idmap *idmap,
+			     struct nameidata *nd)
+{
+	if (nd->flags & LOOKUP_RCU) {
+		int err = inode_permission(idmap, nd->inode, MAY_EXEC|MAY_NOT_BLOCK);
+		if (err != -ECHILD || !try_to_unlazy(nd))
+			return err;
+	}
+	return inode_permission(idmap, nd->inode, MAY_EXEC);
+}
+
+static int reserve_stack(struct nameidata *nd, struct path *link)
+{
+	if (unlikely(nd->total_link_count++ >= MAXSYMLINKS))
+		return -ELOOP;
+
+	if (likely(nd->depth != EMBEDDED_LEVELS))
+		return 0;
+	if (likely(nd->stack != nd->internal))
+		return 0;
+	if (likely(nd_alloc_stack(nd)))
+		return 0;
+
+	if (nd->flags & LOOKUP_RCU) {
+		// we need to grab link before we do unlazy.  And we can't skip
+		// unlazy even if we fail to grab the link - cleanup needs it
+		bool grabbed_link = legitimize_path(nd, link, nd->next_seq);
+
+		if (!try_to_unlazy(nd) || !grabbed_link)
+			return -ECHILD;
+
+		if (nd_alloc_stack(nd))
+			return 0;
+	}
+	return -ENOMEM;
+}
+
+enum {WALK_TRAILING = 1, WALK_MORE = 2, WALK_NOFOLLOW = 4};
+
+static const char *pick_link(struct nameidata *nd, struct path *link,
+		     struct inode *inode, int flags)
+{
+	struct saved *last;
+	const char *res;
+	int error = reserve_stack(nd, link);
+
+	if (unlikely(error)) {
+		if (!(nd->flags & LOOKUP_RCU))
+			path_put(link);
+		return ERR_PTR(error);
+	}
+	last = nd->stack + nd->depth++;
+	last->link = *link;
+	clear_delayed_call(&last->done);
+	last->seq = nd->next_seq;
+
+	if (flags & WALK_TRAILING) {
+		error = may_follow_link(nd, inode);
+		if (unlikely(error))
+			return ERR_PTR(error);
+	}
+
+	if (unlikely(nd->flags & LOOKUP_NO_SYMLINKS) ||
+			unlikely(link->mnt->mnt_flags & MNT_NOSYMFOLLOW))
+		return ERR_PTR(-ELOOP);
+
+	if (!(nd->flags & LOOKUP_RCU)) {
+		touch_atime(&last->link);
+		cond_resched();
+	} else if (atime_needs_update(&last->link, inode)) {
+		if (!try_to_unlazy(nd))
+			return ERR_PTR(-ECHILD);
+		touch_atime(&last->link);
+	}
+
+	error = security_inode_follow_link(link->dentry, inode,
+					   nd->flags & LOOKUP_RCU);
+	if (unlikely(error))
+		return ERR_PTR(error);
+
+	res = READ_ONCE(inode->i_link);
+	if (!res) {
+		const char * (*get)(struct dentry *, struct inode *,
+				struct delayed_call *);
+		get = inode->i_op->get_link;
+		if (nd->flags & LOOKUP_RCU) {
+			res = get(NULL, inode, &last->done);
+			if (res == ERR_PTR(-ECHILD) && try_to_unlazy(nd))
+				res = get(link->dentry, inode, &last->done);
+		} else {
+			res = get(link->dentry, inode, &last->done);
+		}
+		if (!res)
+			goto all_done;
+		if (IS_ERR(res))
+			return res;
+	}
+	if (*res == '/') {
+		error = nd_jump_root(nd);
+		if (unlikely(error))
+			return ERR_PTR(error);
+		while (unlikely(*++res == '/'))
+			;
+	}
+	if (*res)
+		return res;
+all_done: // pure jump
+	put_link(nd);
+	return NULL;
+}
+
+/*
+ * Do we need to follow links? We _really_ want to be able
+ * to do this check without having to look at inode->i_op,
+ * so we keep a cache of "no, this doesn't need follow_link"
+ * for the common case.
+ *
+ * NOTE: dentry must be what nd->next_seq had been sampled from.
+ */
+static const char *step_into(struct nameidata *nd, int flags,
+		     struct dentry *dentry)
+{
+	struct path path;
+	struct inode *inode;
+	int err = handle_mounts(nd, dentry, &path);
+
+	if (err < 0)
+		return ERR_PTR(err);
+	inode = path.dentry->d_inode;
+	if (likely(!d_is_symlink(path.dentry)) ||
+	   ((flags & WALK_TRAILING) && !(nd->flags & LOOKUP_FOLLOW)) ||
+	   (flags & WALK_NOFOLLOW)) {
+		/* not a symlink or should not follow */
+		if (nd->flags & LOOKUP_RCU) {
+			if (read_seqcount_retry(&path.dentry->d_seq, nd->next_seq))
+				return ERR_PTR(-ECHILD);
+			if (unlikely(!inode))
+				return ERR_PTR(-ENOENT);
+		} else {
+			dput(nd->path.dentry);
+			if (nd->path.mnt != path.mnt)
+				mntput(nd->path.mnt);
+		}
+		nd->path = path;
+		nd->inode = inode;
+		nd->seq = nd->next_seq;
+		return NULL;
+	}
+	if (nd->flags & LOOKUP_RCU) {
+		/* make sure that d_is_symlink above matches inode */
+		if (read_seqcount_retry(&path.dentry->d_seq, nd->next_seq))
+			return ERR_PTR(-ECHILD);
+	} else {
+		if (path.mnt == nd->path.mnt)
+			mntget(path.mnt);
+	}
+	return pick_link(nd, &path, inode, flags);
+}
+
+static struct dentry *follow_dotdot_rcu(struct nameidata *nd)
+{
+	struct dentry *parent, *old;
+
+	if (path_equal(&nd->path, &nd->root))
+		goto in_root;
+	if (unlikely(nd->path.dentry == nd->path.mnt->mnt_root)) {
+		struct path path;
+		unsigned seq;
+		if (!choose_mountpoint_rcu(real_mount(nd->path.mnt),
+					   &nd->root, &path, &seq))
+			goto in_root;
+		if (unlikely(nd->flags & LOOKUP_NO_XDEV))
+			return ERR_PTR(-ECHILD);
+		nd->path = path;
+		nd->inode = path.dentry->d_inode;
+		nd->seq = seq;
+		// makes sure that non-RCU pathwalk could reach this state
+		if (read_seqretry(&mount_lock, nd->m_seq))
+			return ERR_PTR(-ECHILD);
+		/* we know that mountpoint was pinned */
+	}
+	old = nd->path.dentry;
+	parent = old->d_parent;
+	nd->next_seq = read_seqcount_begin(&parent->d_seq);
+	// makes sure that non-RCU pathwalk could reach this state
+	if (read_seqcount_retry(&old->d_seq, nd->seq))
+		return ERR_PTR(-ECHILD);
+	if (unlikely(!path_connected(nd->path.mnt, parent)))
+		return ERR_PTR(-ECHILD);
+	return parent;
+in_root:
+	if (read_seqretry(&mount_lock, nd->m_seq))
+		return ERR_PTR(-ECHILD);
+	if (unlikely(nd->flags & LOOKUP_BENEATH))
+		return ERR_PTR(-ECHILD);
+	nd->next_seq = nd->seq;
+	return nd->path.dentry;
+}
+
+static struct dentry *follow_dotdot(struct nameidata *nd)
+{
+	struct dentry *parent;
+
+	if (path_equal(&nd->path, &nd->root))
+		goto in_root;
+	if (unlikely(nd->path.dentry == nd->path.mnt->mnt_root)) {
+		struct path path;
+
+		if (!choose_mountpoint(real_mount(nd->path.mnt),
+				       &nd->root, &path))
+			goto in_root;
+		path_put(&nd->path);
+		nd->path = path;
+		nd->inode = path.dentry->d_inode;
+		if (unlikely(nd->flags & LOOKUP_NO_XDEV))
+			return ERR_PTR(-EXDEV);
+	}
+	/* rare case of legitimate dget_parent()... */
+	parent = dget_parent(nd->path.dentry);
+	if (unlikely(!path_connected(nd->path.mnt, parent))) {
+		dput(parent);
+		return ERR_PTR(-ENOENT);
+	}
+	return parent;
+
+in_root:
+	if (unlikely(nd->flags & LOOKUP_BENEATH))
+		return ERR_PTR(-EXDEV);
+	return dget(nd->path.dentry);
+}
+
+static const char *handle_dots(struct nameidata *nd, int type)
+{
+	if (type == LAST_DOTDOT) {
+		const char *error = NULL;
+		struct dentry *parent;
+
+		if (!nd->root.mnt) {
+			error = ERR_PTR(set_root(nd));
+			if (error)
+				return error;
+		}
+		if (nd->flags & LOOKUP_RCU)
+			parent = follow_dotdot_rcu(nd);
+		else
+			parent = follow_dotdot(nd);
+		if (IS_ERR(parent))
+			return ERR_CAST(parent);
+		error = step_into(nd, WALK_NOFOLLOW, parent);
+		if (unlikely(error))
+			return error;
+
+		if (unlikely(nd->flags & LOOKUP_IS_SCOPED)) {
+			/*
+			 * If there was a racing rename or mount along our
+			 * path, then we can't be sure that ".." hasn't jumped
+			 * above nd->root (and so userspace should retry or use
+			 * some fallback).
+			 */
+			smp_rmb();
+			if (__read_seqcount_retry(&mount_lock.seqcount, nd->m_seq))
+				return ERR_PTR(-EAGAIN);
+			if (__read_seqcount_retry(&rename_lock.seqcount, nd->r_seq))
+				return ERR_PTR(-EAGAIN);
+		}
+	}
+	return NULL;
+}
+
+static const char *walk_component(struct nameidata *nd, int flags)
+{
+	struct dentry *dentry;
+	/*
+	 * "." and ".." are special - ".." especially so because it has
+	 * to be able to know about the current root directory and
+	 * parent relationships.
+	 */
+	if (unlikely(nd->last_type != LAST_NORM)) {
+		if (!(flags & WALK_MORE) && nd->depth)
+			put_link(nd);
+		return handle_dots(nd, nd->last_type);
+	}
+	dentry = lookup_fast(nd);
+	if (IS_ERR(dentry))
+		return ERR_CAST(dentry);
+	if (unlikely(!dentry)) {
+		dentry = lookup_slow(&nd->last, nd->path.dentry, nd->flags);
+		if (IS_ERR(dentry))
+			return ERR_CAST(dentry);
+	}
+	if (!(flags & WALK_MORE) && nd->depth)
+		put_link(nd);
+	return step_into(nd, flags, dentry);
+}
+
+/*
+ * We can do the critical dentry name comparison and hashing
+ * operations one word at a time, but we are limited to:
+ *
+ * - Architectures with fast unaligned word accesses. We could
+ *   do a "get_unaligned()" if this helps and is sufficiently
+ *   fast.
+ *
+ * - non-CONFIG_DEBUG_PAGEALLOC configurations (so that we
+ *   do not trap on the (extremely unlikely) case of a page
+ *   crossing operation.
+ *
+ * - Furthermore, we need an efficient 64-bit compile for the
+ *   64-bit case in order to generate the "number of bytes in
+ *   the final mask". Again, that could be replaced with a
+ *   efficient population count instruction or similar.
+ */
+#ifdef CONFIG_DCACHE_WORD_ACCESS
+
+#include <asm/word-at-a-time.h>
+
+#ifdef HASH_MIX
+
+/* Architecture provides HASH_MIX and fold_hash() in <asm/hash.h> */
+
+#elif defined(CONFIG_64BIT)
+/*
+ * Register pressure in the mixing function is an issue, particularly
+ * on 32-bit x86, but almost any function requires one state value and
+ * one temporary.  Instead, use a function designed for two state values
+ * and no temporaries.
+ *
+ * This function cannot create a collision in only two iterations, so
+ * we have two iterations to achieve avalanche.  In those two iterations,
+ * we have six layers of mixing, which is enough to spread one bit's
+ * influence out to 2^6 = 64 state bits.
+ *
+ * Rotate constants are scored by considering either 64 one-bit input
+ * deltas or 64*63/2 = 2016 two-bit input deltas, and finding the
+ * probability of that delta causing a change to each of the 128 output
+ * bits, using a sample of random initial states.
+ *
+ * The Shannon entropy of the computed probabilities is then summed
+ * to produce a score.  Ideally, any input change has a 50% chance of
+ * toggling any given output bit.
+ *
+ * Mixing scores (in bits) for (12,45):
+ * Input delta: 1-bit      2-bit
+ * 1 round:     713.3    42542.6
+ * 2 rounds:   2753.7   140389.8
+ * 3 rounds:   5954.1   233458.2
+ * 4 rounds:   7862.6   256672.2
+ * Perfect:    8192     258048
+ *            (64*128) (64*63/2 * 128)
+ */
+#define HASH_MIX(x, y, a)	\
+	(	x ^= (a),	\
+	y ^= x,	x = rol64(x,12),\
+	x += y,	y = rol64(y,45),\
+	y *= 9			)
+
+/*
+ * Fold two longs into one 32-bit hash value.  This must be fast, but
+ * latency isn't quite as critical, as there is a fair bit of additional
+ * work done before the hash value is used.
+ */
+static inline unsigned int fold_hash(unsigned long x, unsigned long y)
+{
+	y ^= x * GOLDEN_RATIO_64;
+	y *= GOLDEN_RATIO_64;
+	return y >> 32;
+}
+
+#else	/* 32-bit case */
+
+/*
+ * Mixing scores (in bits) for (7,20):
+ * Input delta: 1-bit      2-bit
+ * 1 round:     330.3     9201.6
+ * 2 rounds:   1246.4    25475.4
+ * 3 rounds:   1907.1    31295.1
+ * 4 rounds:   2042.3    31718.6
+ * Perfect:    2048      31744
+ *            (32*64)   (32*31/2 * 64)
+ */
+#define HASH_MIX(x, y, a)	\
+	(	x ^= (a),	\
+	y ^= x,	x = rol32(x, 7),\
+	x += y,	y = rol32(y,20),\
+	y *= 9			)
+
+static inline unsigned int fold_hash(unsigned long x, unsigned long y)
+{
+	/* Use arch-optimized multiply if one exists */
+	return __hash_32(y ^ __hash_32(x));
+}
+
+#endif
+
+/*
+ * Return the hash of a string of known length.  This is carfully
+ * designed to match hash_name(), which is the more critical function.
+ * In particular, we must end by hashing a final word containing 0..7
+ * payload bytes, to match the way that hash_name() iterates until it
+ * finds the delimiter after the name.
+ */
+unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)
+{
+	unsigned long a, x = 0, y = (unsigned long)salt;
+
+	for (;;) {
+		if (!len)
+			goto done;
+		a = load_unaligned_zeropad(name);
+		if (len < sizeof(unsigned long))
+			break;
+		HASH_MIX(x, y, a);
+		name += sizeof(unsigned long);
+		len -= sizeof(unsigned long);
+	}
+	x ^= a & bytemask_from_count(len);
+done:
+	return fold_hash(x, y);
+}
+EXPORT_SYMBOL(full_name_hash);
+
+/* Return the "hash_len" (hash and length) of a null-terminated string */
+u64 hashlen_string(const void *salt, const char *name)
+{
+	unsigned long a = 0, x = 0, y = (unsigned long)salt;
+	unsigned long adata, mask, len;
+	const struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;
+
+	len = 0;
+	goto inside;
+
+	do {
+		HASH_MIX(x, y, a);
+		len += sizeof(unsigned long);
+inside:
+		a = load_unaligned_zeropad(name+len);
+	} while (!has_zero(a, &adata, &constants));
+
+	adata = prep_zero_mask(a, adata, &constants);
+	mask = create_zero_mask(adata);
+	x ^= a & zero_bytemask(mask);
+
+	return hashlen_create(fold_hash(x, y), len + find_zero(mask));
+}
+EXPORT_SYMBOL(hashlen_string);
+
+/*
+ * Calculate the length and hash of the path component, and
+ * return the "hash_len" as the result.
+ */
+static inline u64 hash_name(const void *salt, const char *name)
+{
+	unsigned long a = 0, b, x = 0, y = (unsigned long)salt;
+	unsigned long adata, bdata, mask, len;
+	const struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;
+
+	len = 0;
+	goto inside;
+
+	do {
+		HASH_MIX(x, y, a);
+		len += sizeof(unsigned long);
+inside:
+		a = load_unaligned_zeropad(name+len);
+		b = a ^ REPEAT_BYTE('/');
+	} while (!(has_zero(a, &adata, &constants) | has_zero(b, &bdata, &constants)));
+
+	adata = prep_zero_mask(a, adata, &constants);
+	bdata = prep_zero_mask(b, bdata, &constants);
+	mask = create_zero_mask(adata | bdata);
+	x ^= a & zero_bytemask(mask);
+
+	return hashlen_create(fold_hash(x, y), len + find_zero(mask));
+}
+
+#else	/* !CONFIG_DCACHE_WORD_ACCESS: Slow, byte-at-a-time version */
+
+/* Return the hash of a string of known length */
+unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)
+{
+	unsigned long hash = init_name_hash(salt);
+	while (len--)
+		hash = partial_name_hash((unsigned char)*name++, hash);
+	return end_name_hash(hash);
+}
+EXPORT_SYMBOL(full_name_hash);
+
+/* Return the "hash_len" (hash and length) of a null-terminated string */
+u64 hashlen_string(const void *salt, const char *name)
+{
+	unsigned long hash = init_name_hash(salt);
+	unsigned long len = 0, c;
+
+	c = (unsigned char)*name;
+	while (c) {
+		len++;
+		hash = partial_name_hash(c, hash);
+		c = (unsigned char)name[len];
+	}
+	return hashlen_create(end_name_hash(hash), len);
+}
+EXPORT_SYMBOL(hashlen_string);
+
+/*
+ * We know there's a real path component here of at least
+ * one character.
+ */
+static inline u64 hash_name(const void *salt, const char *name)
+{
+	unsigned long hash = init_name_hash(salt);
+	unsigned long len = 0, c;
+
+	c = (unsigned char)*name;
+	do {
+		len++;
+		hash = partial_name_hash(c, hash);
+		c = (unsigned char)name[len];
+	} while (c && c != '/');
+	return hashlen_create(end_name_hash(hash), len);
+}
+
+#endif
+
+/*
+ * Name resolution.
+ * This is the basic name resolution function, turning a pathname into
+ * the final dentry. We expect 'base' to be positive and a directory.
+ *
+ * Returns 0 and nd will have valid dentry and mnt on success.
+ * Returns error and drops reference to input namei data on failure.
+ */
+static int link_path_walk(const char *name, struct nameidata *nd)
+{
+	int depth = 0; // depth <= nd->depth
+	int err;
+
+	nd->last_type = LAST_ROOT;
+	nd->flags |= LOOKUP_PARENT;
+	if (IS_ERR(name))
+		return PTR_ERR(name);
+	while (*name=='/')
+		name++;
+	if (!*name) {
+		nd->dir_mode = 0; // short-circuit the 'hardening' idiocy
+		return 0;
+	}
+
+	/* At this point we know we have a real path component. */
+	for(;;) {
+		struct mnt_idmap *idmap;
+		const char *link;
+		u64 hash_len;
+		int type;
+
+		idmap = mnt_idmap(nd->path.mnt);
+		err = may_lookup(idmap, nd);
+		if (err)
+			return err;
+
+		hash_len = hash_name(nd->path.dentry, name);
+
+		type = LAST_NORM;
+		if (name[0] == '.') switch (hashlen_len(hash_len)) {
+			case 2:
+				if (name[1] == '.') {
+					type = LAST_DOTDOT;
+					nd->state |= ND_JUMPED;
+				}
+				break;
+			case 1:
+				type = LAST_DOT;
+		}
+		if (likely(type == LAST_NORM)) {
+			struct dentry *parent = nd->path.dentry;
+			nd->state &= ~ND_JUMPED;
+			if (unlikely(parent->d_flags & DCACHE_OP_HASH)) {
+				struct qstr this = { { .hash_len = hash_len }, .name = name };
+				err = parent->d_op->d_hash(parent, &this);
+				if (err < 0)
+					return err;
+				hash_len = this.hash_len;
+				name = this.name;
+			}
+		}
+
+		nd->last.hash_len = hash_len;
+		nd->last.name = name;
+		nd->last_type = type;
+
+		name += hashlen_len(hash_len);
+		if (!*name)
+			goto OK;
+		/*
+		 * If it wasn't NUL, we know it was '/'. Skip that
+		 * slash, and continue until no more slashes.
+		 */
+		do {
+			name++;
+		} while (unlikely(*name == '/'));
+		if (unlikely(!*name)) {
+OK:
+			/* pathname or trailing symlink, done */
+			if (!depth) {
+				nd->dir_vfsuid = i_uid_into_vfsuid(idmap, nd->inode);
+				nd->dir_mode = nd->inode->i_mode;
+				nd->flags &= ~LOOKUP_PARENT;
+				return 0;
+			}
+			/* last component of nested symlink */
+			name = nd->stack[--depth].name;
+			link = walk_component(nd, 0);
+		} else {
+			/* not the last component */
+			link = walk_component(nd, WALK_MORE);
+		}
+		if (unlikely(link)) {
+			if (IS_ERR(link))
+				return PTR_ERR(link);
+			/* a symlink to follow */
+			nd->stack[depth++].name = name;
+			name = link;
+			continue;
+		}
+		if (unlikely(!d_can_lookup(nd->path.dentry))) {
+			if (nd->flags & LOOKUP_RCU) {
+				if (!try_to_unlazy(nd))
+					return -ECHILD;
+			}
+			return -ENOTDIR;
+		}
+	}
+}
+
+/* must be paired with terminate_walk() */
+static const char *path_init(struct nameidata *nd, unsigned flags)
+{
+	int error;
+	const char *s = nd->name->name;
+
+	/* LOOKUP_CACHED requires RCU, ask caller to retry */
+	if ((flags & (LOOKUP_RCU | LOOKUP_CACHED)) == LOOKUP_CACHED)
+		return ERR_PTR(-EAGAIN);
+
+	if (!*s)
+		flags &= ~LOOKUP_RCU;
+	if (flags & LOOKUP_RCU)
+		rcu_read_lock();
+	else
+		nd->seq = nd->next_seq = 0;
+
+	nd->flags = flags;
+	nd->state |= ND_JUMPED;
+
+	nd->m_seq = __read_seqcount_begin(&mount_lock.seqcount);
+	nd->r_seq = __read_seqcount_begin(&rename_lock.seqcount);
+	smp_rmb();
+
+	if (nd->state & ND_ROOT_PRESET) {
+		struct dentry *root = nd->root.dentry;
+		struct inode *inode = root->d_inode;
+		if (*s && unlikely(!d_can_lookup(root)))
+			return ERR_PTR(-ENOTDIR);
+		nd->path = nd->root;
+		nd->inode = inode;
+		if (flags & LOOKUP_RCU) {
+			nd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);
+			nd->root_seq = nd->seq;
+		} else {
+			path_get(&nd->path);
+		}
+		return s;
+	}
+
+	nd->root.mnt = NULL;
+
+	/* Absolute pathname -- fetch the root (LOOKUP_IN_ROOT uses nd->dfd). */
+	if (*s == '/' && !(flags & LOOKUP_IN_ROOT)) {
+		error = nd_jump_root(nd);
+		if (unlikely(error))
+			return ERR_PTR(error);
+		return s;
+	}
+
+	/* Relative pathname -- get the starting-point it is relative to. */
+	if (nd->dfd == AT_FDCWD) {
+		if (flags & LOOKUP_RCU) {
+			struct fs_struct *fs = current->fs;
+			unsigned seq;
+
+			do {
+				seq = read_seqcount_begin(&fs->seq);
+				nd->path = fs->pwd;
+				nd->inode = nd->path.dentry->d_inode;
+				nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
+			} while (read_seqcount_retry(&fs->seq, seq));
+		} else {
+			get_fs_pwd(current->fs, &nd->path);
+			nd->inode = nd->path.dentry->d_inode;
+		}
+	} else {
+		/* Caller must check execute permissions on the starting path component */
+		struct fd f = fdget_raw(nd->dfd);
+		struct dentry *dentry;
+
+		if (!f.file)
+			return ERR_PTR(-EBADF);
+
+		dentry = f.file->f_path.dentry;
+
+		if (*s && unlikely(!d_can_lookup(dentry))) {
+			fdput(f);
+			return ERR_PTR(-ENOTDIR);
+		}
+
+		nd->path = f.file->f_path;
+		if (flags & LOOKUP_RCU) {
+			nd->inode = nd->path.dentry->d_inode;
+			nd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);
+		} else {
+			path_get(&nd->path);
+			nd->inode = nd->path.dentry->d_inode;
+		}
+		fdput(f);
+	}
+
+	/* For scoped-lookups we need to set the root to the dirfd as well. */
+	if (flags & LOOKUP_IS_SCOPED) {
+		nd->root = nd->path;
+		if (flags & LOOKUP_RCU) {
+			nd->root_seq = nd->seq;
+		} else {
+			path_get(&nd->root);
+			nd->state |= ND_ROOT_GRABBED;
+		}
+	}
+	return s;
+}
+
+static inline const char *lookup_last(struct nameidata *nd)
+{
+	if (nd->last_type == LAST_NORM && nd->last.name[nd->last.len])
+		nd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;
+
+	return walk_component(nd, WALK_TRAILING);
+}
+
+static int handle_lookup_down(struct nameidata *nd)
+{
+	if (!(nd->flags & LOOKUP_RCU))
+		dget(nd->path.dentry);
+	nd->next_seq = nd->seq;
+	return PTR_ERR(step_into(nd, WALK_NOFOLLOW, nd->path.dentry));
+}
+
+/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */
+static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
+{
+	const char *s = path_init(nd, flags);
+	int err;
+
+	if (unlikely(flags & LOOKUP_DOWN) && !IS_ERR(s)) {
+		err = handle_lookup_down(nd);
+		if (unlikely(err < 0))
+			s = ERR_PTR(err);
+	}
+
+	while (!(err = link_path_walk(s, nd)) &&
+	       (s = lookup_last(nd)) != NULL)
+		;
+	if (!err && unlikely(nd->flags & LOOKUP_MOUNTPOINT)) {
+		err = handle_lookup_down(nd);
+		nd->state &= ~ND_JUMPED; // no d_weak_revalidate(), please...
+	}
+	if (!err)
+		err = complete_walk(nd);
+
+	if (!err && nd->flags & LOOKUP_DIRECTORY)
+		if (!d_can_lookup(nd->path.dentry))
+			err = -ENOTDIR;
+	if (!err) {
+		*path = nd->path;
+		nd->path.mnt = NULL;
+		nd->path.dentry = NULL;
+	}
+	terminate_walk(nd);
+	return err;
+}
+
+int filename_lookup(int dfd, struct filename *name, unsigned flags,
+		    struct path *path, struct path *root)
+{
+	int retval;
+	struct nameidata nd;
+	if (IS_ERR(name))
+		return PTR_ERR(name);
+	set_nameidata(&nd, dfd, name, root);
+	retval = path_lookupat(&nd, flags | LOOKUP_RCU, path);
+	if (unlikely(retval == -ECHILD))
+		retval = path_lookupat(&nd, flags, path);
+	if (unlikely(retval == -ESTALE))
+		retval = path_lookupat(&nd, flags | LOOKUP_REVAL, path);
+
+	if (likely(!retval))
+		audit_inode(name, path->dentry,
+			    flags & LOOKUP_MOUNTPOINT ? AUDIT_INODE_NOEVAL : 0);
+	restore_nameidata();
+	return retval;
+}
+
+/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */
+static int path_parentat(struct nameidata *nd, unsigned flags,
+				struct path *parent)
+{
+	const char *s = path_init(nd, flags);
+	int err = link_path_walk(s, nd);
+	if (!err)
+		err = complete_walk(nd);
+	if (!err) {
+		*parent = nd->path;
+		nd->path.mnt = NULL;
+		nd->path.dentry = NULL;
+	}
+	terminate_walk(nd);
+	return err;
+}
+
+/* Note: this does not consume "name" */
+static int __filename_parentat(int dfd, struct filename *name,
+			       unsigned int flags, struct path *parent,
+			       struct qstr *last, int *type,
+			       const struct path *root)
+{
+	int retval;
+	struct nameidata nd;
+
+	if (IS_ERR(name))
+		return PTR_ERR(name);
+	set_nameidata(&nd, dfd, name, root);
+	retval = path_parentat(&nd, flags | LOOKUP_RCU, parent);
+	if (unlikely(retval == -ECHILD))
+		retval = path_parentat(&nd, flags, parent);
+	if (unlikely(retval == -ESTALE))
+		retval = path_parentat(&nd, flags | LOOKUP_REVAL, parent);
+	if (likely(!retval)) {
+		*last = nd.last;
+		*type = nd.last_type;
+		audit_inode(name, parent->dentry, AUDIT_INODE_PARENT);
+	}
+	restore_nameidata();
+	return retval;
+}
+
+static int filename_parentat(int dfd, struct filename *name,
+			     unsigned int flags, struct path *parent,
+			     struct qstr *last, int *type)
+{
+	return __filename_parentat(dfd, name, flags, parent, last, type, NULL);
+}
+
+/* does lookup, returns the object with parent locked */
+static struct dentry *__kern_path_locked(struct filename *name, struct path *path)
+{
+	struct dentry *d;
+	struct qstr last;
+	int type, error;
+
+	error = filename_parentat(AT_FDCWD, name, 0, path, &last, &type);
+	if (error)
+		return ERR_PTR(error);
+	if (unlikely(type != LAST_NORM)) {
+		path_put(path);
+		return ERR_PTR(-EINVAL);
+	}
+	inode_lock_nested(path->dentry->d_inode, I_MUTEX_PARENT);
+	d = lookup_one_qstr_excl(&last, path->dentry, 0);
+	if (IS_ERR(d)) {
+		inode_unlock(path->dentry->d_inode);
+		path_put(path);
+	}
+	return d;
+}
+
+struct dentry *kern_path_locked(const char *name, struct path *path)
+{
+	struct filename *filename = getname_kernel(name);
+	struct dentry *res = __kern_path_locked(filename, path);
+
+	putname(filename);
+	return res;
+}
+
+int kern_path(const char *name, unsigned int flags, struct path *path)
+{
+	struct filename *filename = getname_kernel(name);
+	int ret = filename_lookup(AT_FDCWD, filename, flags, path, NULL);
+
+	putname(filename);
+	return ret;
+
+}
+EXPORT_SYMBOL_NS(kern_path, ANDROID_GKI_VFS_EXPORT_ONLY);
+
+/**
+ * vfs_path_parent_lookup - lookup a parent path relative to a dentry-vfsmount pair
+ * @filename: filename structure
+ * @flags: lookup flags
+ * @parent: pointer to struct path to fill
+ * @last: last component
+ * @type: type of the last component
+ * @root: pointer to struct path of the base directory
+ */
+int vfs_path_parent_lookup(struct filename *filename, unsigned int flags,
+			   struct path *parent, struct qstr *last, int *type,
+			   const struct path *root)
+{
+	return  __filename_parentat(AT_FDCWD, filename, flags, parent, last,
+				    type, root);
+}
+EXPORT_SYMBOL(vfs_path_parent_lookup);
+
+/**
+ * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair
+ * @dentry:  pointer to dentry of the base directory
+ * @mnt: pointer to vfs mount of the base directory
+ * @name: pointer to file name
+ * @flags: lookup flags
+ * @path: pointer to struct path to fill
+ */
+int vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt,
+		    const char *name, unsigned int flags,
+		    struct path *path)
+{
+	struct filename *filename;
+	struct path root = {.mnt = mnt, .dentry = dentry};
+	int ret;
+
+	filename = getname_kernel(name);
+	/* the first argument of filename_lookup() is ignored with root */
+	ret = filename_lookup(AT_FDCWD, filename, flags, path, &root);
+	putname(filename);
+	return ret;
+}
+EXPORT_SYMBOL_NS(vfs_path_lookup, ANDROID_GKI_VFS_EXPORT_ONLY);
+
+static int lookup_one_common(struct mnt_idmap *idmap,
+			     const char *name, struct dentry *base, int len,
+			     struct qstr *this)
+{
+	this->name = name;
+	this->len = len;
+	this->hash = full_name_hash(base, name, len);
+	if (!len)
+		return -EACCES;
+
+	if (is_dot_dotdot(name, len))
+		return -EACCES;
+
+	while (len--) {
+		unsigned int c = *(const unsigned char *)name++;
+		if (c == '/' || c == '\0')
+			return -EACCES;
+	}
+	/*
+	 * See if the low-level filesystem might want
+	 * to use its own hash..
+	 */
+	if (base->d_flags & DCACHE_OP_HASH) {
+		int err = base->d_op->d_hash(base, this);
+		if (err < 0)
+			return err;
+	}
+
+	return inode_permission(idmap, base->d_inode, MAY_EXEC);
+}
+
+/**
+ * try_lookup_one_len - filesystem helper to lookup single pathname component
+ * @name:	pathname component to lookup
+ * @base:	base directory to lookup from
+ * @len:	maximum length @len should be interpreted to
+ *
+ * Look up a dentry by name in the dcache, returning NULL if it does not
+ * currently exist.  The function does not try to create a dentry.
+ *
+ * Note that this routine is purely a helper for filesystem usage and should
+ * not be called by generic code.
+ *
+ * The caller must hold base->i_mutex.
+ */
+struct dentry *try_lookup_one_len(const char *name, struct dentry *base, int len)
+{
+	struct qstr this;
+	int err;
+
+	WARN_ON_ONCE(!inode_is_locked(base->d_inode));
+
+	err = lookup_one_common(&nop_mnt_idmap, name, base, len, &this);
+	if (err)
+		return ERR_PTR(err);
+
+	return lookup_dcache(&this, base, 0);
+}
+EXPORT_SYMBOL(try_lookup_one_len);
+
+/**
+ * lookup_one_len - filesystem helper to lookup single pathname component
+ * @name:	pathname component to lookup
+ * @base:	base directory to lookup from
+ * @len:	maximum length @len should be interpreted to
+ *
+ * Note that this routine is purely a helper for filesystem usage and should
+ * not be called by generic code.
+ *
+ * The caller must hold base->i_mutex.
+ */
+struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)
+{
+	struct dentry *dentry;
+	struct qstr this;
+	int err;
+
+	WARN_ON_ONCE(!inode_is_locked(base->d_inode));
+
+	err = lookup_one_common(&nop_mnt_idmap, name, base, len, &this);
+	if (err)
+		return ERR_PTR(err);
+
+	dentry = lookup_dcache(&this, base, 0);
+	return dentry ? dentry : __lookup_slow(&this, base, 0);
+}
+EXPORT_SYMBOL(lookup_one_len);
+
+/**
+ * lookup_one - filesystem helper to lookup single pathname component
+ * @idmap:	idmap of the mount the lookup is performed from
+ * @name:	pathname component to lookup
+ * @base:	base directory to lookup from
+ * @len:	maximum length @len should be interpreted to
+ *
+ * Note that this routine is purely a helper for filesystem usage and should
+ * not be called by generic code.
+ *
+ * The caller must hold base->i_mutex.
+ */
+struct dentry *lookup_one(struct mnt_idmap *idmap, const char *name,
+			  struct dentry *base, int len)
+{
+	struct dentry *dentry;
+	struct qstr this;
+	int err;
+
+	WARN_ON_ONCE(!inode_is_locked(base->d_inode));
+
+	err = lookup_one_common(idmap, name, base, len, &this);
+	if (err)
+		return ERR_PTR(err);
+
+	dentry = lookup_dcache(&this, base, 0);
+	return dentry ? dentry : __lookup_slow(&this, base, 0);
+}
+EXPORT_SYMBOL(lookup_one);
+
+/**
+ * lookup_one_unlocked - filesystem helper to lookup single pathname component
+ * @idmap:	idmap of the mount the lookup is performed from
+ * @name:	pathname component to lookup
+ * @base:	base directory to lookup from
+ * @len:	maximum length @len should be interpreted to
+ *
+ * Note that this routine is purely a helper for filesystem usage and should
+ * not be called by generic code.
+ *
+ * Unlike lookup_one_len, it should be called without the parent
+ * i_mutex held, and will take the i_mutex itself if necessary.
+ */
+struct dentry *lookup_one_unlocked(struct mnt_idmap *idmap,
+				   const char *name, struct dentry *base,
+				   int len)
+{
+	struct qstr this;
+	int err;
+	struct dentry *ret;
+
+	err = lookup_one_common(idmap, name, base, len, &this);
+	if (err)
+		return ERR_PTR(err);
+
+	ret = lookup_dcache(&this, base, 0);
+	if (!ret)
+		ret = lookup_slow(&this, base, 0);
+	return ret;
+}
+EXPORT_SYMBOL(lookup_one_unlocked);
+
+/**
+ * lookup_one_positive_unlocked - filesystem helper to lookup single
+ *				  pathname component
+ * @idmap:	idmap of the mount the lookup is performed from
+ * @name:	pathname component to lookup
+ * @base:	base directory to lookup from
+ * @len:	maximum length @len should be interpreted to
+ *
+ * This helper will yield ERR_PTR(-ENOENT) on negatives. The helper returns
+ * known positive or ERR_PTR(). This is what most of the users want.
+ *
+ * Note that pinned negative with unlocked parent _can_ become positive at any
+ * time, so callers of lookup_one_unlocked() need to be very careful; pinned
+ * positives have >d_inode stable, so this one avoids such problems.
+ *
+ * Note that this routine is purely a helper for filesystem usage and should
+ * not be called by generic code.
+ *
+ * The helper should be called without i_mutex held.
+ */
+struct dentry *lookup_one_positive_unlocked(struct mnt_idmap *idmap,
+					    const char *name,
+					    struct dentry *base, int len)
+{
+	struct dentry *ret = lookup_one_unlocked(idmap, name, base, len);
+
+	if (!IS_ERR(ret) && d_flags_negative(smp_load_acquire(&ret->d_flags))) {
+		dput(ret);
+		ret = ERR_PTR(-ENOENT);
+	}
+	return ret;
+}
+EXPORT_SYMBOL(lookup_one_positive_unlocked);
+
+/**
+ * lookup_one_len_unlocked - filesystem helper to lookup single pathname component
+ * @name:	pathname component to lookup
+ * @base:	base directory to lookup from
+ * @len:	maximum length @len should be interpreted to
+ *
+ * Note that this routine is purely a helper for filesystem usage and should
+ * not be called by generic code.
+ *
+ * Unlike lookup_one_len, it should be called without the parent
+ * i_mutex held, and will take the i_mutex itself if necessary.
+ */
+struct dentry *lookup_one_len_unlocked(const char *name,
+				       struct dentry *base, int len)
+{
+	return lookup_one_unlocked(&nop_mnt_idmap, name, base, len);
+}
+EXPORT_SYMBOL(lookup_one_len_unlocked);
+
+/*
+ * Like lookup_one_len_unlocked(), except that it yields ERR_PTR(-ENOENT)
+ * on negatives.  Returns known positive or ERR_PTR(); that's what
+ * most of the users want.  Note that pinned negative with unlocked parent
+ * _can_ become positive at any time, so callers of lookup_one_len_unlocked()
+ * need to be very careful; pinned positives have ->d_inode stable, so
+ * this one avoids such problems.
+ */
+struct dentry *lookup_positive_unlocked(const char *name,
+				       struct dentry *base, int len)
+{
+	return lookup_one_positive_unlocked(&nop_mnt_idmap, name, base, len);
+}
+EXPORT_SYMBOL(lookup_positive_unlocked);
+
+#ifdef CONFIG_UNIX98_PTYS
+int path_pts(struct path *path)
+{
+	/* Find something mounted on "pts" in the same directory as
+	 * the input path.
+	 */
+	struct dentry *parent = dget_parent(path->dentry);
+	struct dentry *child;
+	struct qstr this = QSTR_INIT("pts", 3);
+
+	if (unlikely(!path_connected(path->mnt, parent))) {
+		dput(parent);
+		return -ENOENT;
+	}
+	dput(path->dentry);
+	path->dentry = parent;
+	child = d_hash_and_lookup(parent, &this);
+	if (IS_ERR_OR_NULL(child))
+		return -ENOENT;
+
+	path->dentry = child;
+	dput(parent);
+	follow_down(path, 0);
+	return 0;
+}
+#endif
+
+int user_path_at_empty(int dfd, const char __user *name, unsigned flags,
+		 struct path *path, int *empty)
+{
+	struct filename *filename = getname_flags(name, flags, empty);
+	int ret = filename_lookup(dfd, filename, flags, path, NULL);
+
+	putname(filename);
+	return ret;
+}
+EXPORT_SYMBOL(user_path_at_empty);
+
+int __check_sticky(struct mnt_idmap *idmap, struct inode *dir,
+		   struct inode *inode)
+{
+	kuid_t fsuid = current_fsuid();
+
+	if (vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, inode), fsuid))
+		return 0;
+	if (vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, dir), fsuid))
+		return 0;
+	return !capable_wrt_inode_uidgid(idmap, inode, CAP_FOWNER);
+}
+EXPORT_SYMBOL(__check_sticky);
+
+/*
+ *	Check whether we can remove a link victim from directory dir, check
+ *  whether the type of victim is right.
+ *  1. We can't do it if dir is read-only (done in permission())
+ *  2. We should have write and exec permissions on dir
+ *  3. We can't remove anything from append-only dir
+ *  4. We can't do anything with immutable dir (done in permission())
+ *  5. If the sticky bit on dir is set we should either
+ *	a. be owner of dir, or
+ *	b. be owner of victim, or
+ *	c. have CAP_FOWNER capability
+ *  6. If the victim is append-only or immutable we can't do antyhing with
+ *     links pointing to it.
+ *  7. If the victim has an unknown uid or gid we can't change the inode.
+ *  8. If we were asked to remove a directory and victim isn't one - ENOTDIR.
+ *  9. If we were asked to remove a non-directory and victim isn't one - EISDIR.
+ * 10. We can't remove a root or mountpoint.
+ * 11. We don't allow removal of NFS sillyrenamed files; it's handled by
+ *     nfs_async_unlink().
+ */
+static int may_delete(struct mnt_idmap *idmap, struct inode *dir,
+		      struct dentry *victim, bool isdir)
+{
+	struct inode *inode = d_backing_inode(victim);
+	int error;
+
+	if (d_is_negative(victim))
+		return -ENOENT;
+	BUG_ON(!inode);
+
+	BUG_ON(victim->d_parent->d_inode != dir);
+
+	/* Inode writeback is not safe when the uid or gid are invalid. */
+	if (!vfsuid_valid(i_uid_into_vfsuid(idmap, inode)) ||
+	    !vfsgid_valid(i_gid_into_vfsgid(idmap, inode)))
+		return -EOVERFLOW;
+
+	audit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);
+
+	error = inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);
+	if (error)
+		return error;
+	if (IS_APPEND(dir))
+		return -EPERM;
+
+	if (check_sticky(idmap, dir, inode) || IS_APPEND(inode) ||
+	    IS_IMMUTABLE(inode) || IS_SWAPFILE(inode) ||
+	    HAS_UNMAPPED_ID(idmap, inode))
+		return -EPERM;
+	if (isdir) {
+		if (!d_is_dir(victim))
+			return -ENOTDIR;
+		if (IS_ROOT(victim))
+			return -EBUSY;
+	} else if (d_is_dir(victim))
+		return -EISDIR;
+	if (IS_DEADDIR(dir))
+		return -ENOENT;
+	if (victim->d_flags & DCACHE_NFSFS_RENAMED)
+		return -EBUSY;
+	return 0;
+}
+
+/*	Check whether we can create an object with dentry child in directory
+ *  dir.
+ *  1. We can't do it if child already exists (open has special treatment for
+ *     this case, but since we are inlined it's OK)
+ *  2. We can't do it if dir is read-only (done in permission())
+ *  3. We can't do it if the fs can't represent the fsuid or fsgid.
+ *  4. We should have write and exec permissions on dir
+ *  5. We can't do it if dir is immutable (done in permission())
+ */
+static inline int may_create(struct mnt_idmap *idmap,
+			     struct inode *dir, struct dentry *child)
+{
+	audit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE);
+	if (child->d_inode)
+		return -EEXIST;
+	if (IS_DEADDIR(dir))
+		return -ENOENT;
+	if (!fsuidgid_has_mapping(dir->i_sb, idmap))
+		return -EOVERFLOW;
+
+	return inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);
+}
+
+static struct dentry *lock_two_directories(struct dentry *p1, struct dentry *p2)
+{
+	struct dentry *p;
+
+	p = d_ancestor(p2, p1);
+	if (p) {
+		inode_lock_nested(p2->d_inode, I_MUTEX_PARENT);
+		inode_lock_nested(p1->d_inode, I_MUTEX_PARENT2);
+		return p;
+	}
+
+	p = d_ancestor(p1, p2);
+	inode_lock_nested(p1->d_inode, I_MUTEX_PARENT);
+	inode_lock_nested(p2->d_inode, I_MUTEX_PARENT2);
+	return p;
+}
+
+/*
+ * p1 and p2 should be directories on the same fs.
+ */
+struct dentry *lock_rename(struct dentry *p1, struct dentry *p2)
+{
+	if (p1 == p2) {
+		inode_lock_nested(p1->d_inode, I_MUTEX_PARENT);
+		return NULL;
+	}
+
+	mutex_lock(&p1->d_sb->s_vfs_rename_mutex);
+	return lock_two_directories(p1, p2);
+}
+EXPORT_SYMBOL_NS(lock_rename, ANDROID_GKI_VFS_EXPORT_ONLY);
+
+/*
+ * c1 and p2 should be on the same fs.
+ */
+struct dentry *lock_rename_child(struct dentry *c1, struct dentry *p2)
+{
+	if (READ_ONCE(c1->d_parent) == p2) {
+		/*
+		 * hopefully won't need to touch ->s_vfs_rename_mutex at all.
+		 */
+		inode_lock_nested(p2->d_inode, I_MUTEX_PARENT);
+		/*
+		 * now that p2 is locked, nobody can move in or out of it,
+		 * so the test below is safe.
+		 */
+		if (likely(c1->d_parent == p2))
+			return NULL;
+
+		/*
+		 * c1 got moved out of p2 while we'd been taking locks;
+		 * unlock and fall back to slow case.
+		 */
+		inode_unlock(p2->d_inode);
+	}
+
+	mutex_lock(&c1->d_sb->s_vfs_rename_mutex);
+	/*
+	 * nobody can move out of any directories on this fs.
+	 */
+	if (likely(c1->d_parent != p2))
+		return lock_two_directories(c1->d_parent, p2);
+
+	/*
+	 * c1 got moved into p2 while we were taking locks;
+	 * we need p2 locked and ->s_vfs_rename_mutex unlocked,
+	 * for consistency with lock_rename().
+	 */
+	inode_lock_nested(p2->d_inode, I_MUTEX_PARENT);
+	mutex_unlock(&c1->d_sb->s_vfs_rename_mutex);
+	return NULL;
+}
+EXPORT_SYMBOL(lock_rename_child);
+
+void unlock_rename(struct dentry *p1, struct dentry *p2)
+{
+	inode_unlock(p1->d_inode);
+	if (p1 != p2) {
+		inode_unlock(p2->d_inode);
+		mutex_unlock(&p1->d_sb->s_vfs_rename_mutex);
+	}
+}
+EXPORT_SYMBOL_NS(unlock_rename, ANDROID_GKI_VFS_EXPORT_ONLY);
+
+/**
+ * mode_strip_umask - handle vfs umask stripping
+ * @dir:	parent directory of the new inode
+ * @mode:	mode of the new inode to be created in @dir
+ *
+ * Umask stripping depends on whether or not the filesystem supports POSIX
+ * ACLs. If the filesystem doesn't support it umask stripping is done directly
+ * in here. If the filesystem does support POSIX ACLs umask stripping is
+ * deferred until the filesystem calls posix_acl_create().
+ *
+ * Returns: mode
+ */
+static inline umode_t mode_strip_umask(const struct inode *dir, umode_t mode)
+{
+	if (!IS_POSIXACL(dir))
+		mode &= ~current_umask();
+	return mode;
+}
+
+/**
+ * vfs_prepare_mode - prepare the mode to be used for a new inode
+ * @idmap:	idmap of the mount the inode was found from
+ * @dir:	parent directory of the new inode
+ * @mode:	mode of the new inode
+ * @mask_perms:	allowed permission by the vfs
+ * @type:	type of file to be created
+ *
+ * This helper consolidates and enforces vfs restrictions on the @mode of a new
+ * object to be created.
+ *
+ * Umask stripping depends on whether the filesystem supports POSIX ACLs (see
+ * the kernel documentation for mode_strip_umask()). Moving umask stripping
+ * after setgid stripping allows the same ordering for both non-POSIX ACL and
+ * POSIX ACL supporting filesystems.
+ *
+ * Note that it's currently valid for @type to be 0 if a directory is created.
+ * Filesystems raise that flag individually and we need to check whether each
+ * filesystem can deal with receiving S_IFDIR from the vfs before we enforce a
+ * non-zero type.
+ *
+ * Returns: mode to be passed to the filesystem
+ */
+static inline umode_t vfs_prepare_mode(struct mnt_idmap *idmap,
+				       const struct inode *dir, umode_t mode,
+				       umode_t mask_perms, umode_t type)
+{
+	mode = mode_strip_sgid(idmap, dir, mode);
+	mode = mode_strip_umask(dir, mode);
+
+	/*
+	 * Apply the vfs mandated allowed permission mask and set the type of
+	 * file to be created before we call into the filesystem.
+	 */
+	mode &= (mask_perms & ~S_IFMT);
+	mode |= (type & S_IFMT);
+
+	return mode;
+}
+
+/**
+ * vfs_create - create new file
+ * @idmap:	idmap of the mount the inode was found from
+ * @dir:	inode of @dentry
+ * @dentry:	pointer to dentry of the base directory
+ * @mode:	mode of the new file
+ * @want_excl:	whether the file must not yet exist
+ *
+ * Create a new file.
+ *
+ * If the inode has been found through an idmapped mount the idmap of
+ * the vfsmount must be passed through @idmap. This function will then take
+ * care to map the inode according to @idmap before checking permissions.
+ * On non-idmapped mounts or if permission checking is to be performed on the
+ * raw inode simply passs @nop_mnt_idmap.
+ */
+int vfs_create(struct mnt_idmap *idmap, struct inode *dir,
+	       struct dentry *dentry, umode_t mode, bool want_excl)
+{
+	int error;
+
+	error = may_create(idmap, dir, dentry);
+	if (error)
+		return error;
+
+	if (!dir->i_op->create)
+		return -EACCES;	/* shouldn't it be ENOSYS? */
+
+	mode = vfs_prepare_mode(idmap, dir, mode, S_IALLUGO, S_IFREG);
+	error = security_inode_create(dir, dentry, mode);
+	if (error)
+		return error;
+	error = dir->i_op->create(idmap, dir, dentry, mode, want_excl);
+	if (!error)
+		fsnotify_create(dir, dentry);
+	return error;
+}
+EXPORT_SYMBOL_NS(vfs_create, ANDROID_GKI_VFS_EXPORT_ONLY);
+
+int vfs_mkobj(struct dentry *dentry, umode_t mode,
+		int (*f)(struct dentry *, umode_t, void *),
+		void *arg)
+{
+	struct inode *dir = dentry->d_parent->d_inode;
+	int error = may_create(&nop_mnt_idmap, dir, dentry);
+	if (error)
+		return error;
+
+	mode &= S_IALLUGO;
+	mode |= S_IFREG;
+	error = security_inode_create(dir, dentry, mode);
+	if (error)
+		return error;
+	error = f(dentry, mode, arg);
+	if (!error)
+		fsnotify_create(dir, dentry);
+	return error;
+}
+EXPORT_SYMBOL(vfs_mkobj);
+
+bool may_open_dev(const struct path *path)
+{
+	return !(path->mnt->mnt_flags & MNT_NODEV) &&
+		!(path->mnt->mnt_sb->s_iflags & SB_I_NODEV);
+}
+
+static int may_open(struct mnt_idmap *idmap, const struct path *path,
+		    int acc_mode, int flag)
+{
+	struct dentry *dentry = path->dentry;
+	struct inode *inode = dentry->d_inode;
+	int error;
+
+	if (!inode)
+		return -ENOENT;
+
+	switch (inode->i_mode & S_IFMT) {
+	case S_IFLNK:
+		return -ELOOP;
+	case S_IFDIR:
+		if (acc_mode & MAY_WRITE)
+			return -EISDIR;
+		if (acc_mode & MAY_EXEC)
+			return -EACCES;
+		break;
+	case S_IFBLK:
+	case S_IFCHR:
+		if (!may_open_dev(path))
+			return -EACCES;
+		fallthrough;
+	case S_IFIFO:
+	case S_IFSOCK:
+		if (acc_mode & MAY_EXEC)
+			return -EACCES;
+		flag &= ~O_TRUNC;
+		break;
+	case S_IFREG:
+		if ((acc_mode & MAY_EXEC) && path_noexec(path))
+			return -EACCES;
+		break;
+	}
+
+	error = inode_permission(idmap, inode, MAY_OPEN | acc_mode);
+	if (error)
+		return error;
+
+	/*
+	 * An append-only file must be opened in append mode for writing.
+	 */
+	if (IS_APPEND(inode)) {
+		if  ((flag & O_ACCMODE) != O_RDONLY && !(flag & O_APPEND))
+			return -EPERM;
+		if (flag & O_TRUNC)
+			return -EPERM;
+	}
+
+	/* O_NOATIME can only be set by the owner or superuser */
+	if (flag & O_NOATIME && !inode_owner_or_capable(idmap, inode))
+		return -EPERM;
+
+	return 0;
+}
+
+static int handle_truncate(struct mnt_idmap *idmap, struct file *filp)
+{
+	const struct path *path = &filp->f_path;
+	struct inode *inode = path->dentry->d_inode;
+	int error = get_write_access(inode);
+	if (error)
+		return error;
+
+	error = security_file_truncate(filp);
+	if (!error) {
+		error = do_truncate(idmap, path->dentry, 0,
+				    ATTR_MTIME|ATTR_CTIME|ATTR_OPEN,
+				    filp);
+	}
+	put_write_access(inode);
+	return error;
+}
+
+static inline int open_to_namei_flags(int flag)
+{
+	if ((flag & O_ACCMODE) == 3)
+		flag--;
+	return flag;
+}
+
+static int may_o_create(struct mnt_idmap *idmap,
+			const struct path *dir, struct dentry *dentry,
+			umode_t mode)
+{
+	int error = security_path_mknod(dir, dentry, mode, 0);
+	if (error)
+		return error;
+
+	if (!fsuidgid_has_mapping(dir->dentry->d_sb, idmap))
+		return -EOVERFLOW;
+
+	error = inode_permission(idmap, dir->dentry->d_inode,
+				 MAY_WRITE | MAY_EXEC);
+	if (error)
+		return error;
+
+	return security_inode_create(dir->dentry->d_inode, dentry, mode);
+}
+
+/*
+ * Attempt to atomically look up, create and open a file from a negative
+ * dentry.
+ *
+ * Returns 0 if successful.  The file will have been created and attached to
+ * @file by the filesystem calling finish_open().
+ *
+ * If the file was looked up only or didn't need creating, FMODE_OPENED won't
+ * be set.  The caller will need to perform the open themselves.  @path will
+ * have been updated to point to the new dentry.  This may be negative.
+ *
+ * Returns an error code otherwise.
+ */
+static struct dentry *atomic_open(struct nameidata *nd, struct dentry *dentry,
+				  struct file *file,
+				  int open_flag, umode_t mode)
+{
+	struct dentry *const DENTRY_NOT_SET = (void *) -1UL;
+	struct inode *dir =  nd->path.dentry->d_inode;
+	int error;
+
+	if (nd->flags & LOOKUP_DIRECTORY)
+		open_flag |= O_DIRECTORY;
+
+	file->f_path.dentry = DENTRY_NOT_SET;
+	file->f_path.mnt = nd->path.mnt;
+	error = dir->i_op->atomic_open(dir, dentry, file,
+				       open_to_namei_flags(open_flag), mode);
+	d_lookup_done(dentry);
+	if (!error) {
+		if (file->f_mode & FMODE_OPENED) {
+			if (unlikely(dentry != file->f_path.dentry)) {
+				dput(dentry);
+				dentry = dget(file->f_path.dentry);
+			}
+		} else if (WARN_ON(file->f_path.dentry == DENTRY_NOT_SET)) {
+			error = -EIO;
+		} else {
+			if (file->f_path.dentry) {
+				dput(dentry);
+				dentry = file->f_path.dentry;
+			}
+			if (unlikely(d_is_negative(dentry)))
+				error = -ENOENT;
+		}
+	}
+	if (error) {
+		dput(dentry);
+		dentry = ERR_PTR(error);
+	}
+	return dentry;
+}
+
+/*
+ * Look up and maybe create and open the last component.
+ *
+ * Must be called with parent locked (exclusive in O_CREAT case).
+ *
+ * Returns 0 on success, that is, if
+ *  the file was successfully atomically created (if necessary) and opened, or
+ *  the file was not completely opened at this time, though lookups and
+ *  creations were performed.
+ * These case are distinguished by presence of FMODE_OPENED on file->f_mode.
+ * In the latter case dentry returned in @path might be negative if O_CREAT
+ * hadn't been specified.
+ *
+ * An error code is returned on failure.
+ */
+static struct dentry *lookup_open(struct nameidata *nd, struct file *file,
+				  const struct open_flags *op,
+				  bool got_write)
+{
+	struct mnt_idmap *idmap;
+	struct dentry *dir = nd->path.dentry;
+	struct inode *dir_inode = dir->d_inode;
+	int open_flag = op->open_flag;
+	struct dentry *dentry;
+	int error, create_error = 0;
+	umode_t mode = op->mode;
+	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);
+
+	if (unlikely(IS_DEADDIR(dir_inode)))
+		return ERR_PTR(-ENOENT);
+
+	file->f_mode &= ~FMODE_CREATED;
+	dentry = d_lookup(dir, &nd->last);
+	for (;;) {
+		if (!dentry) {
+			dentry = d_alloc_parallel(dir, &nd->last, &wq);
+			if (IS_ERR(dentry))
+				return dentry;
+		}
+		if (d_in_lookup(dentry))
+			break;
+
+		error = d_revalidate(dentry, nd->flags);
+		if (likely(error > 0))
+			break;
+		if (error)
+			goto out_dput;
+		d_invalidate(dentry);
+		dput(dentry);
+		dentry = NULL;
+	}
+	if (dentry->d_inode) {
+		/* Cached positive dentry: will open in f_op->open */
+		return dentry;
+	}
+
+	/*
+	 * Checking write permission is tricky, bacuse we don't know if we are
+	 * going to actually need it: O_CREAT opens should work as long as the
+	 * file exists.  But checking existence breaks atomicity.  The trick is
+	 * to check access and if not granted clear O_CREAT from the flags.
+	 *
+	 * Another problem is returing the "right" error value (e.g. for an
+	 * O_EXCL open we want to return EEXIST not EROFS).
+	 */
+	if (unlikely(!got_write))
+		open_flag &= ~O_TRUNC;
+	idmap = mnt_idmap(nd->path.mnt);
+	if (open_flag & O_CREAT) {
+		if (open_flag & O_EXCL)
+			open_flag &= ~O_TRUNC;
+		mode = vfs_prepare_mode(idmap, dir->d_inode, mode, mode, mode);
+		if (likely(got_write))
+			create_error = may_o_create(idmap, &nd->path,
+						    dentry, mode);
+		else
+			create_error = -EROFS;
+	}
+	if (create_error)
+		open_flag &= ~O_CREAT;
+	if (dir_inode->i_op->atomic_open) {
+		dentry = atomic_open(nd, dentry, file, open_flag, mode);
+		if (unlikely(create_error) && dentry == ERR_PTR(-ENOENT))
+			dentry = ERR_PTR(create_error);
+		return dentry;
+	}
+
+	if (d_in_lookup(dentry)) {
+		struct dentry *res = dir_inode->i_op->lookup(dir_inode, dentry,
+							     nd->flags);
+		d_lookup_done(dentry);
+		if (unlikely(res)) {
+			if (IS_ERR(res)) {
+				error = PTR_ERR(res);
+				goto out_dput;
+			}
+			dput(dentry);
+			dentry = res;
+		}
+	}
+
+	/* Negative dentry, just create the file */
+	if (!dentry->d_inode && (open_flag & O_CREAT)) {
+		file->f_mode |= FMODE_CREATED;
+		audit_inode_child(dir_inode, dentry, AUDIT_TYPE_CHILD_CREATE);
+		if (!dir_inode->i_op->create) {
+			error = -EACCES;
+			goto out_dput;
+		}
+
+		error = dir_inode->i_op->create(idmap, dir_inode, dentry,
+						mode, open_flag & O_EXCL);
+		if (error)
+			goto out_dput;
+	}
+	if (unlikely(create_error) && !dentry->d_inode) {
+		error = create_error;
+		goto out_dput;
+	}
+	return dentry;
+
+out_dput:
+	dput(dentry);
+	return ERR_PTR(error);
+}
+
+static const char *open_last_lookups(struct nameidata *nd,
+		   struct file *file, const struct open_flags *op)
+{
+	struct dentry *dir = nd->path.dentry;
+	int open_flag = op->open_flag;
+	bool got_write = false;
+	struct dentry *dentry;
+	const char *res;
+
+	nd->flags |= op->intent;
+
+	if (nd->last_type != LAST_NORM) {
+		if (nd->depth)
+			put_link(nd);
+		return handle_dots(nd, nd->last_type);
+	}
+
+	if (!(open_flag & O_CREAT)) {
+		if (nd->last.name[nd->last.len])
+			nd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;
+		/* we _can_ be in RCU mode here */
+		dentry = lookup_fast(nd);
+		if (IS_ERR(dentry))
+			return ERR_CAST(dentry);
+		if (likely(dentry))
+			goto finish_lookup;
+
+		BUG_ON(nd->flags & LOOKUP_RCU);
+	} else {
+		/* create side of things */
+		if (nd->flags & LOOKUP_RCU) {
+			if (!try_to_unlazy(nd))
+				return ERR_PTR(-ECHILD);
+		}
+		audit_inode(nd->name, dir, AUDIT_INODE_PARENT);
+		/* trailing slashes? */
+		if (unlikely(nd->last.name[nd->last.len]))
+			return ERR_PTR(-EISDIR);
+	}
+
+	if (open_flag & (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) {
+		got_write = !mnt_want_write(nd->path.mnt);
+		/*
+		 * do _not_ fail yet - we might not need that or fail with
+		 * a different error; let lookup_open() decide; we'll be
+		 * dropping this one anyway.
+		 */
+	}
+	if (open_flag & O_CREAT)
+		inode_lock(dir->d_inode);
+	else
+		inode_lock_shared(dir->d_inode);
+	dentry = lookup_open(nd, file, op, got_write);
+	if (!IS_ERR(dentry) && (file->f_mode & FMODE_CREATED))
+		fsnotify_create(dir->d_inode, dentry);
+	if (open_flag & O_CREAT)
+		inode_unlock(dir->d_inode);
+	else
+		inode_unlock_shared(dir->d_inode);
+
+	if (got_write)
+		mnt_drop_write(nd->path.mnt);
+
+	if (IS_ERR(dentry))
+		return ERR_CAST(dentry);
+
+	if (file->f_mode & (FMODE_OPENED | FMODE_CREATED)) {
+		dput(nd->path.dentry);
+		nd->path.dentry = dentry;
+		return NULL;
+	}
+
+finish_lookup:
+	if (nd->depth)
+		put_link(nd);
+	res = step_into(nd, WALK_TRAILING, dentry);
+	if (unlikely(res))
+		nd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);
+	return res;
+}
+
+/*
+ * Handle the last step of open()
+ */
+static int do_open(struct nameidata *nd,
+		   struct file *file, const struct open_flags *op)
+{
+	struct mnt_idmap *idmap;
+	int open_flag = op->open_flag;
+	bool do_truncate;
+	int acc_mode;
+	int error;
+
+	if (!(file->f_mode & (FMODE_OPENED | FMODE_CREATED))) {
+		error = complete_walk(nd);
+		if (error)
+			return error;
+	}
+	if (!(file->f_mode & FMODE_CREATED))
+		audit_inode(nd->name, nd->path.dentry, 0);
+	idmap = mnt_idmap(nd->path.mnt);
+	if (open_flag & O_CREAT) {
+		if ((open_flag & O_EXCL) && !(file->f_mode & FMODE_CREATED))
+			return -EEXIST;
+		if (d_is_dir(nd->path.dentry))
+			return -EISDIR;
+		error = may_create_in_sticky(idmap, nd,
+					     d_backing_inode(nd->path.dentry));
+		if (unlikely(error))
+			return error;
+	}
+	if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))
+		return -ENOTDIR;
+
+	do_truncate = false;
+	acc_mode = op->acc_mode;
+	if (file->f_mode & FMODE_CREATED) {
+		/* Don't check for write permission, don't truncate */
+		open_flag &= ~O_TRUNC;
+		acc_mode = 0;
+	} else if (d_is_reg(nd->path.dentry) && open_flag & O_TRUNC) {
+		error = mnt_want_write(nd->path.mnt);
+		if (error)
+			return error;
+		do_truncate = true;
+	}
+	error = may_open(idmap, &nd->path, acc_mode, open_flag);
+	if (!error && !(file->f_mode & FMODE_OPENED))
+		error = vfs_open(&nd->path, file);
+	if (!error)
+		error = ima_file_check(file, op->acc_mode);
+	if (!error && do_truncate)
+		error = handle_truncate(idmap, file);
+	if (unlikely(error > 0)) {
+		WARN_ON(1);
+		error = -EINVAL;
+	}
+	if (do_truncate)
+		mnt_drop_write(nd->path.mnt);
+	return error;
+}
+
+/**
+ * vfs_tmpfile - create tmpfile
+ * @idmap:	idmap of the mount the inode was found from
+ * @parentpath:	pointer to the path of the base directory
+ * @file:	file descriptor of the new tmpfile
+ * @mode:	mode of the new tmpfile
+ *
+ * Create a temporary file.
+ *
+ * If the inode has been found through an idmapped mount the idmap of
+ * the vfsmount must be passed through @idmap. This function will then take
+ * care to map the inode according to @idmap before checking permissions.
+ * On non-idmapped mounts or if permission checking is to be performed on the
+ * raw inode simply passs @nop_mnt_idmap.
+ */
+static int vfs_tmpfile(struct mnt_idmap *idmap,
+		       const struct path *parentpath,
+		       struct file *file, umode_t mode)
+{
+	struct dentry *child;
+	struct inode *dir = d_inode(parentpath->dentry);
+	struct inode *inode;
+	int error;
+	int open_flag = file->f_flags;
+
+	/* we want directory to be writable */
+	error = inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);
+	if (error)
+		return error;
+	if (!dir->i_op->tmpfile)
+		return -EOPNOTSUPP;
+	child = d_alloc(parentpath->dentry, &slash_name);
+	if (unlikely(!child))
+		return -ENOMEM;
+	file->f_path.mnt = parentpath->mnt;
+	file->f_path.dentry = child;
+	mode = vfs_prepare_mode(idmap, dir, mode, mode, mode);
+	error = dir->i_op->tmpfile(idmap, dir, file, mode);
+	dput(child);
+	if (error)
+		return error;
+	/* Don't check for other permissions, the inode was just created */
+	error = may_open(idmap, &file->f_path, 0, file->f_flags);
+	if (error)
+		return error;
+	inode = file_inode(file);
+	if (!(open_flag & O_EXCL)) {
+		spin_lock(&inode->i_lock);
+		inode->i_state |= I_LINKABLE;
+		spin_unlock(&inode->i_lock);
+	}
+	ima_post_create_tmpfile(idmap, inode);
+	return 0;
+}
+
+/**
+ * kernel_tmpfile_open - open a tmpfile for kernel internal use
+ * @idmap:	idmap of the mount the inode was found from
+ * @parentpath:	path of the base directory
+ * @mode:	mode of the new tmpfile
+ * @open_flag:	flags
+ * @cred:	credentials for open
+ *
+ * Create and open a temporary file.  The file is not accounted in nr_files,
+ * hence this is only for kernel internal use, and must not be installed into
+ * file tables or such.
+ */
+struct file *kernel_tmpfile_open(struct mnt_idmap *idmap,
+				 const struct path *parentpath,
+				 umode_t mode, int open_flag,
+				 const struct cred *cred)
+{
+	struct file *file;
+	int error;
+
+	file = alloc_empty_file_noaccount(open_flag, cred);
+	if (IS_ERR(file))
+		return file;
+
+	error = vfs_tmpfile(idmap, parentpath, file, mode);
+	if (error) {
+		fput(file);
+		file = ERR_PTR(error);
+	}
+	return file;
+}
+EXPORT_SYMBOL(kernel_tmpfile_open);
+
+static int do_tmpfile(struct nameidata *nd, unsigned flags,
+		const struct open_flags *op,
+		struct file *file)
+{
+	struct path path;
+	int error = path_lookupat(nd, flags | LOOKUP_DIRECTORY, &path);
+
+	if (unlikely(error))
+		return error;
+	error = mnt_want_write(path.mnt);
+	if (unlikely(error))
+		goto out;
+	error = vfs_tmpfile(mnt_idmap(path.mnt), &path, file, op->mode);
+	if (error)
+		goto out2;
+	audit_inode(nd->name, file->f_path.dentry, 0);
+out2:
+	mnt_drop_write(path.mnt);
+out:
+	path_put(&path);
+	return error;
+}
+
+static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)
+{
+	struct path path;
+	int error = path_lookupat(nd, flags, &path);
+	if (!error) {
+		audit_inode(nd->name, path.dentry, 0);
+		error = vfs_open(&path, file);
+		path_put(&path);
+	}
+	return error;
+}
+
+static struct file *path_openat(struct nameidata *nd,
+			const struct open_flags *op, unsigned flags)
+{
+	struct file *file;
+	int error;
+
+	file = alloc_empty_file(op->open_flag, current_cred());
+	if (IS_ERR(file))
+		return file;
+
+	if (unlikely(file->f_flags & __O_TMPFILE)) {
+		error = do_tmpfile(nd, flags, op, file);
+	} else if (unlikely(file->f_flags & O_PATH)) {
+		error = do_o_path(nd, flags, file);
+	} else {
+		const char *s = path_init(nd, flags);
+		while (!(error = link_path_walk(s, nd)) &&
+		       (s = open_last_lookups(nd, file, op)) != NULL)
+			;
+		if (!error)
+			error = do_open(nd, file, op);
+		terminate_walk(nd);
+	}
+	if (likely(!error)) {
+		if (likely(file->f_mode & FMODE_OPENED))
+			return file;
+		WARN_ON(1);
+		error = -EINVAL;
+	}
+	fput(file);
+	if (error == -EOPENSTALE) {
+		if (flags & LOOKUP_RCU)
+			error = -ECHILD;
+		else
+			error = -ESTALE;
+	}
+	return ERR_PTR(error);
+}
+
+struct file *do_filp_open(int dfd, struct filename *pathname,
+		const struct open_flags *op)
+{
+	struct nameidata nd;
+	int flags = op->lookup_flags;
+	struct file *filp;
+
+	set_nameidata(&nd, dfd, pathname, NULL);
+	filp = path_openat(&nd, op, flags | LOOKUP_RCU);
+	if (unlikely(filp == ERR_PTR(-ECHILD)))
+		filp = path_openat(&nd, op, flags);
+	if (unlikely(filp == ERR_PTR(-ESTALE)))
+		filp = path_openat(&nd, op, flags | LOOKUP_REVAL);
+	restore_nameidata();
+	return filp;
+}
+
+struct file *do_file_open_root(const struct path *root,
+		const char *name, const struct open_flags *op)
+{
+	struct nameidata nd;
+	struct file *file;
+	struct filename *filename;
+	int flags = op->lookup_flags;
+
+	if (d_is_symlink(root->dentry) && op->intent & LOOKUP_OPEN)
+		return ERR_PTR(-ELOOP);
+
+	filename = getname_kernel(name);
+	if (IS_ERR(filename))
+		return ERR_CAST(filename);
+
+	set_nameidata(&nd, -1, filename, root);
+	file = path_openat(&nd, op, flags | LOOKUP_RCU);
+	if (unlikely(file == ERR_PTR(-ECHILD)))
+		file = path_openat(&nd, op, flags);
+	if (unlikely(file == ERR_PTR(-ESTALE)))
+		file = path_openat(&nd, op, flags | LOOKUP_REVAL);
+	restore_nameidata();
+	putname(filename);
+	return file;
+}
+
+static struct dentry *filename_create(int dfd, struct filename *name,
+				      struct path *path, unsigned int lookup_flags)
+{
+	struct dentry *dentry = ERR_PTR(-EEXIST);
+	struct qstr last;
+	bool want_dir = lookup_flags & LOOKUP_DIRECTORY;
+	unsigned int reval_flag = lookup_flags & LOOKUP_REVAL;
+	unsigned int create_flags = LOOKUP_CREATE | LOOKUP_EXCL;
+	int type;
+	int err2;
+	int error;
+
+	error = filename_parentat(dfd, name, reval_flag, path, &last, &type);
+	if (error)
+		return ERR_PTR(error);
+
+	/*
+	 * Yucky last component or no last component at all?
+	 * (foo/., foo/.., /////)
+	 */
+	if (unlikely(type != LAST_NORM))
+		goto out;
+
+	/* don't fail immediately if it's r/o, at least try to report other errors */
+	err2 = mnt_want_write(path->mnt);
+	/*
+	 * Do the final lookup.  Suppress 'create' if there is a trailing
+	 * '/', and a directory wasn't requested.
+	 */
+	if (last.name[last.len] && !want_dir)
+		create_flags = 0;
+	inode_lock_nested(path->dentry->d_inode, I_MUTEX_PARENT);
+	dentry = lookup_one_qstr_excl(&last, path->dentry,
+				      reval_flag | create_flags);
+	if (IS_ERR(dentry))
+		goto unlock;
+
+	error = -EEXIST;
+	if (d_is_positive(dentry))
+		goto fail;
+
+	/*
+	 * Special case - lookup gave negative, but... we had foo/bar/
+	 * From the vfs_mknod() POV we just have a negative dentry -
+	 * all is fine. Let's be bastards - you had / on the end, you've
+	 * been asking for (non-existent) directory. -ENOENT for you.
+	 */
+	if (unlikely(!create_flags)) {
+		error = -ENOENT;
+		goto fail;
+	}
+	if (unlikely(err2)) {
+		error = err2;
+		goto fail;
+	}
+	return dentry;
+fail:
+	dput(dentry);
+	dentry = ERR_PTR(error);
+unlock:
+	inode_unlock(path->dentry->d_inode);
+	if (!err2)
+		mnt_drop_write(path->mnt);
+out:
+	path_put(path);
+	return dentry;
+}
+
+struct dentry *kern_path_create(int dfd, const char *pathname,
+				struct path *path, unsigned int lookup_flags)
+{
+	struct filename *filename = getname_kernel(pathname);
+	struct dentry *res = filename_create(dfd, filename, path, lookup_flags);
+
+	putname(filename);
+	return res;
+}
+EXPORT_SYMBOL(kern_path_create);
+
+void done_path_create(struct path *path, struct dentry *dentry)
+{
+	dput(dentry);
+	inode_unlock(path->dentry->d_inode);
+	mnt_drop_write(path->mnt);
+	path_put(path);
+}
+EXPORT_SYMBOL(done_path_create);
+
+inline struct dentry *user_path_create(int dfd, const char __user *pathname,
+				struct path *path, unsigned int lookup_flags)
+{
+	struct filename *filename = getname(pathname);
+	struct dentry *res = filename_create(dfd, filename, path, lookup_flags);
+
+	putname(filename);
+	return res;
+}
+EXPORT_SYMBOL(user_path_create);
+
+/**
+ * vfs_mknod - create device node or file
+ * @idmap:	idmap of the mount the inode was found from
+ * @dir:	inode of @dentry
+ * @dentry:	pointer to dentry of the base directory
+ * @mode:	mode of the new device node or file
+ * @dev:	device number of device to create
+ *
+ * Create a device node or file.
+ *
+ * If the inode has been found through an idmapped mount the idmap of
+ * the vfsmount must be passed through @idmap. This function will then take
+ * care to map the inode according to @idmap before checking permissions.
+ * On non-idmapped mounts or if permission checking is to be performed on the
+ * raw inode simply passs @nop_mnt_idmap.
+ */
+int vfs_mknod(struct mnt_idmap *idmap, struct inode *dir,
+	      struct dentry *dentry, umode_t mode, dev_t dev)
+{
+	bool is_whiteout = S_ISCHR(mode) && dev == WHITEOUT_DEV;
+	int error = may_create(idmap, dir, dentry);
+
+	if (error)
+		return error;
+
+	if ((S_ISCHR(mode) || S_ISBLK(mode)) && !is_whiteout &&
+	    !capable(CAP_MKNOD))
+		return -EPERM;
+
+	if (!dir->i_op->mknod)
+		return -EPERM;
+
+	mode = vfs_prepare_mode(idmap, dir, mode, mode, mode);
+	error = devcgroup_inode_mknod(mode, dev);
+	if (error)
+		return error;
+
+	error = security_inode_mknod(dir, dentry, mode, dev);
+	if (error)
+		return error;
+
+	error = dir->i_op->mknod(idmap, dir, dentry, mode, dev);
+	if (!error)
+		fsnotify_create(dir, dentry);
+	return error;
+}
+EXPORT_SYMBOL(vfs_mknod);
+
+static int may_mknod(umode_t mode)
+{
+	switch (mode & S_IFMT) {
+	case S_IFREG:
+	case S_IFCHR:
+	case S_IFBLK:
+	case S_IFIFO:
+	case S_IFSOCK:
+	case 0: /* zero mode translates to S_IFREG */
+		return 0;
+	case S_IFDIR:
+		return -EPERM;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int do_mknodat(int dfd, struct filename *name, umode_t mode,
+		unsigned int dev)
+{
+	struct mnt_idmap *idmap;
+	struct dentry *dentry;
+	struct path path;
+	int error;
+	unsigned int lookup_flags = 0;
+
+	error = may_mknod(mode);
+	if (error)
+		goto out1;
+retry:
+	dentry = filename_create(dfd, name, &path, lookup_flags);
+	error = PTR_ERR(dentry);
+	if (IS_ERR(dentry))
+		goto out1;
+
+	error = security_path_mknod(&path, dentry,
+			mode_strip_umask(path.dentry->d_inode, mode), dev);
+	if (error)
+		goto out2;
+
+	idmap = mnt_idmap(path.mnt);
+	switch (mode & S_IFMT) {
+		case 0: case S_IFREG:
+			error = vfs_create(idmap, path.dentry->d_inode,
+					   dentry, mode, true);
+			if (!error)
+				ima_post_path_mknod(idmap, dentry);
+			break;
+		case S_IFCHR: case S_IFBLK:
+			error = vfs_mknod(idmap, path.dentry->d_inode,
+					  dentry, mode, new_decode_dev(dev));
+			break;
+		case S_IFIFO: case S_IFSOCK:
+			error = vfs_mknod(idmap, path.dentry->d_inode,
+					  dentry, mode, 0);
+			break;
+	}
+out2:
+	done_path_create(&path, dentry);
+	if (retry_estale(error, lookup_flags)) {
+		lookup_flags |= LOOKUP_REVAL;
+		goto retry;
+	}
+out1:
+	putname(name);
+	return error;
+}
+
+SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode,
+		unsigned int, dev)
+{
+	return do_mknodat(dfd, getname(filename), mode, dev);
+}
+
+SYSCALL_DEFINE3(mknod, const char __user *, filename, umode_t, mode, unsigned, dev)
+{
+	return do_mknodat(AT_FDCWD, getname(filename), mode, dev);
+}
+
+/**
+ * vfs_mkdir - create directory
+ * @idmap:	idmap of the mount the inode was found from
+ * @dir:	inode of @dentry
+ * @dentry:	pointer to dentry of the base directory
+ * @mode:	mode of the new directory
+ *
+ * Create a directory.
+ *
+ * If the inode has been found through an idmapped mount the idmap of
+ * the vfsmount must be passed through @idmap. This function will then take
+ * care to map the inode according to @idmap before checking permissions.
+ * On non-idmapped mounts or if permission checking is to be performed on the
+ * raw inode simply passs @nop_mnt_idmap.
+ */
+int vfs_mkdir(struct mnt_idmap *idmap, struct inode *dir,
+	      struct dentry *dentry, umode_t mode)
+{
+	int error;
+	unsigned max_links = dir->i_sb->s_max_links;
+
+	error = may_create(idmap, dir, dentry);
+	if (error)
+		return error;
+
+	if (!dir->i_op->mkdir)
+		return -EPERM;
+
+	mode = vfs_prepare_mode(idmap, dir, mode, S_IRWXUGO | S_ISVTX, 0);
+	error = security_inode_mkdir(dir, dentry, mode);
+	if (error)
+		return error;
+
+	if (max_links && dir->i_nlink >= max_links)
+		return -EMLINK;
+
+	error = dir->i_op->mkdir(idmap, dir, dentry, mode);
+	if (!error)
+		fsnotify_mkdir(dir, dentry);
+	return error;
+}
+EXPORT_SYMBOL_NS(vfs_mkdir, ANDROID_GKI_VFS_EXPORT_ONLY);
+
+int do_mkdirat(int dfd, struct filename *name, umode_t mode)
+{
+	struct dentry *dentry;
+	struct path path;
+	int error;
+	unsigned int lookup_flags = LOOKUP_DIRECTORY;
+
+retry:
+	dentry = filename_create(dfd, name, &path, lookup_flags);
+	error = PTR_ERR(dentry);
+	if (IS_ERR(dentry))
+		goto out_putname;
+
+	error = security_path_mkdir(&path, dentry,
+			mode_strip_umask(path.dentry->d_inode, mode));
+	if (!error) {
+		error = vfs_mkdir(mnt_idmap(path.mnt), path.dentry->d_inode,
+				  dentry, mode);
+	}
+	done_path_create(&path, dentry);
+	if (retry_estale(error, lookup_flags)) {
+		lookup_flags |= LOOKUP_REVAL;
+		goto retry;
+	}
+out_putname:
+	putname(name);
+	return error;
+}
+
+SYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode)
+{
+	return do_mkdirat(dfd, getname(pathname), mode);
+}
+
+SYSCALL_DEFINE2(mkdir, const char __user *, pathname, umode_t, mode)
+{
+	return do_mkdirat(AT_FDCWD, getname(pathname), mode);
+}
+
+/**
+ * vfs_rmdir - remove directory
+ * @idmap:	idmap of the mount the inode was found from
+ * @dir:	inode of @dentry
+ * @dentry:	pointer to dentry of the base directory
+ *
+ * Remove a directory.
+ *
+ * If the inode has been found through an idmapped mount the idmap of
+ * the vfsmount must be passed through @idmap. This function will then take
+ * care to map the inode according to @idmap before checking permissions.
+ * On non-idmapped mounts or if permission checking is to be performed on the
+ * raw inode simply passs @nop_mnt_idmap.
+ */
+int vfs_rmdir(struct mnt_idmap *idmap, struct inode *dir,
+		     struct dentry *dentry)
+{
+	int error = may_delete(idmap, dir, dentry, 1);
+
+	if (error)
+		return error;
+
+	if (!dir->i_op->rmdir)
+		return -EPERM;
+
+	dget(dentry);
+	inode_lock(dentry->d_inode);
+
+	error = -EBUSY;
+	if (is_local_mountpoint(dentry) ||
+	    (dentry->d_inode->i_flags & S_KERNEL_FILE))
+		goto out;
+
+	error = security_inode_rmdir(dir, dentry);
+	if (error)
+		goto out;
+
+	error = dir->i_op->rmdir(dir, dentry);
+	if (error)
+		goto out;
+
+	shrink_dcache_parent(dentry);
+	dentry->d_inode->i_flags |= S_DEAD;
+	dont_mount(dentry);
+	detach_mounts(dentry);
+
+out:
+	inode_unlock(dentry->d_inode);
+	dput(dentry);
+	if (!error)
+		d_delete_notify(dir, dentry);
+	return error;
+}
+EXPORT_SYMBOL_NS(vfs_rmdir, ANDROID_GKI_VFS_EXPORT_ONLY);
+
+int do_rmdir(int dfd, struct filename *name)
+{
+	int error;
+	struct dentry *dentry;
+	struct path path;
+	struct qstr last;
+	int type;
+	unsigned int lookup_flags = 0;
+retry:
+	error = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);
+	if (error)
+		goto exit1;
+
+	switch (type) {
+	case LAST_DOTDOT:
+		error = -ENOTEMPTY;
+		goto exit2;
+	case LAST_DOT:
+		error = -EINVAL;
+		goto exit2;
+	case LAST_ROOT:
+		error = -EBUSY;
+		goto exit2;
+	}
+
+	error = mnt_want_write(path.mnt);
+	if (error)
+		goto exit2;
+
+	inode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);
+	dentry = lookup_one_qstr_excl(&last, path.dentry, lookup_flags);
+	error = PTR_ERR(dentry);
+	if (IS_ERR(dentry))
+		goto exit3;
+	if (!dentry->d_inode) {
+		error = -ENOENT;
+		goto exit4;
+	}
+	error = security_path_rmdir(&path, dentry);
+	if (error)
+		goto exit4;
+	error = vfs_rmdir(mnt_idmap(path.mnt), path.dentry->d_inode, dentry);
+exit4:
+	dput(dentry);
+exit3:
+	inode_unlock(path.dentry->d_inode);
+	mnt_drop_write(path.mnt);
+exit2:
+	path_put(&path);
+	if (retry_estale(error, lookup_flags)) {
+		lookup_flags |= LOOKUP_REVAL;
+		goto retry;
+	}
+exit1:
+	putname(name);
+	return error;
+}
+
+SYSCALL_DEFINE1(rmdir, const char __user *, pathname)
+{
+	return do_rmdir(AT_FDCWD, getname(pathname));
+}
+
+/**
+ * vfs_unlink - unlink a filesystem object
+ * @idmap:	idmap of the mount the inode was found from
+ * @dir:	parent directory
+ * @dentry:	victim
+ * @delegated_inode: returns victim inode, if the inode is delegated.
+ *
+ * The caller must hold dir->i_mutex.
+ *
+ * If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and
+ * return a reference to the inode in delegated_inode.  The caller
+ * should then break the delegation on that inode and retry.  Because
+ * breaking a delegation may take a long time, the caller should drop
+ * dir->i_mutex before doing so.
+ *
+ * Alternatively, a caller may pass NULL for delegated_inode.  This may
+ * be appropriate for callers that expect the underlying filesystem not
+ * to be NFS exported.
+ *
+ * If the inode has been found through an idmapped mount the idmap of
+ * the vfsmount must be passed through @idmap. This function will then take
+ * care to map the inode according to @idmap before checking permissions.
+ * On non-idmapped mounts or if permission checking is to be performed on the
+ * raw inode simply passs @nop_mnt_idmap.
+ */
+int vfs_unlink(struct mnt_idmap *idmap, struct inode *dir,
+	       struct dentry *dentry, struct inode **delegated_inode)
+{
+	struct inode *target = dentry->d_inode;
+	int error = may_delete(idmap, dir, dentry, 0);
+
+	if (error)
+		return error;
+
+	if (!dir->i_op->unlink)
+		return -EPERM;
+
+	inode_lock(target);
+	if (IS_SWAPFILE(target))
+		error = -EPERM;
+	else if (is_local_mountpoint(dentry))
+		error = -EBUSY;
+	else {
+		error = security_inode_unlink(dir, dentry);
+		if (!error) {
+			error = try_break_deleg(target, delegated_inode);
+			if (error)
+				goto out;
+			error = dir->i_op->unlink(dir, dentry);
+			if (!error) {
+				dont_mount(dentry);
+				detach_mounts(dentry);
+			}
+		}
+	}
+out:
+	inode_unlock(target);
+
+	/* We don't d_delete() NFS sillyrenamed files--they still exist. */
+	if (!error && dentry->d_flags & DCACHE_NFSFS_RENAMED) {
+		fsnotify_unlink(dir, dentry);
+	} else if (!error) {
+		fsnotify_link_count(target);
+		d_delete_notify(dir, dentry);
+	}
+
+	return error;
+}
+EXPORT_SYMBOL_NS(vfs_unlink, ANDROID_GKI_VFS_EXPORT_ONLY);
+
+/*
+ * Make sure that the actual truncation of the file will occur outside its
+ * directory's i_mutex.  Truncate can take a long time if there is a lot of
+ * writeout happening, and we don't want to prevent access to the directory
+ * while waiting on the I/O.
+ */
+int do_unlinkat(int dfd, struct filename *name)
+{
+	int error;
+	struct dentry *dentry;
+	struct path path;
+	struct qstr last;
+	int type;
+	struct inode *inode = NULL;
+	struct inode *delegated_inode = NULL;
+	unsigned int lookup_flags = 0;
+retry:
+	error = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);
+	if (error)
+		goto exit1;
+
+	error = -EISDIR;
+	if (type != LAST_NORM)
+		goto exit2;
+
+	error = mnt_want_write(path.mnt);
+	if (error)
+		goto exit2;
+retry_deleg:
+	inode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);
+	dentry = lookup_one_qstr_excl(&last, path.dentry, lookup_flags);
+	error = PTR_ERR(dentry);
+	if (!IS_ERR(dentry)) {
+
+		/* Why not before? Because we want correct error value */
+		if (last.name[last.len])
+			goto slashes;
+		inode = dentry->d_inode;
+		if (d_is_negative(dentry))
+			goto slashes;
+		ihold(inode);
+		error = security_path_unlink(&path, dentry);
+		if (error)
+			goto exit3;
+		error = vfs_unlink(mnt_idmap(path.mnt), path.dentry->d_inode,
+				   dentry, &delegated_inode);
+exit3:
+		dput(dentry);
+	}
+	inode_unlock(path.dentry->d_inode);
+	if (inode)
+		iput(inode);	/* truncate the inode here */
+	inode = NULL;
+	if (delegated_inode) {
+		error = break_deleg_wait(&delegated_inode);
+		if (!error)
+			goto retry_deleg;
+	}
+	mnt_drop_write(path.mnt);
+exit2:
+	path_put(&path);
+	if (retry_estale(error, lookup_flags)) {
+		lookup_flags |= LOOKUP_REVAL;
+		inode = NULL;
+		goto retry;
+	}
+exit1:
+	putname(name);
+	return error;
+
+slashes:
+	if (d_is_negative(dentry))
+		error = -ENOENT;
+	else if (d_is_dir(dentry))
+		error = -EISDIR;
+	else
+		error = -ENOTDIR;
+	goto exit3;
+}
+
+SYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)
+{
+	if ((flag & ~AT_REMOVEDIR) != 0)
+		return -EINVAL;
+
+	if (flag & AT_REMOVEDIR)
+		return do_rmdir(dfd, getname(pathname));
+	return do_unlinkat(dfd, getname(pathname));
+}
+
+SYSCALL_DEFINE1(unlink, const char __user *, pathname)
+{
+	return do_unlinkat(AT_FDCWD, getname(pathname));
+}
+
+/**
+ * vfs_symlink - create symlink
+ * @idmap:	idmap of the mount the inode was found from
+ * @dir:	inode of @dentry
+ * @dentry:	pointer to dentry of the base directory
+ * @oldname:	name of the file to link to
+ *
+ * Create a symlink.
+ *
+ * If the inode has been found through an idmapped mount the idmap of
+ * the vfsmount must be passed through @idmap. This function will then take
+ * care to map the inode according to @idmap before checking permissions.
+ * On non-idmapped mounts or if permission checking is to be performed on the
+ * raw inode simply passs @nop_mnt_idmap.
+ */
+int vfs_symlink(struct mnt_idmap *idmap, struct inode *dir,
+		struct dentry *dentry, const char *oldname)
+{
+	int error;
+
+	error = may_create(idmap, dir, dentry);
+	if (error)
+		return error;
+
+	if (!dir->i_op->symlink)
+		return -EPERM;
+
+	error = security_inode_symlink(dir, dentry, oldname);
+	if (error)
+		return error;
+
+	error = dir->i_op->symlink(idmap, dir, dentry, oldname);
+	if (!error)
+		fsnotify_create(dir, dentry);
+	return error;
+}
+EXPORT_SYMBOL(vfs_symlink);
+
+int do_symlinkat(struct filename *from, int newdfd, struct filename *to)
+{
+	int error;
+	struct dentry *dentry;
+	struct path path;
+	unsigned int lookup_flags = 0;
+
+	if (IS_ERR(from)) {
+		error = PTR_ERR(from);
+		goto out_putnames;
+	}
+retry:
+	dentry = filename_create(newdfd, to, &path, lookup_flags);
+	error = PTR_ERR(dentry);
+	if (IS_ERR(dentry))
+		goto out_putnames;
+
+	error = security_path_symlink(&path, dentry, from->name);
+	if (!error)
+		error = vfs_symlink(mnt_idmap(path.mnt), path.dentry->d_inode,
+				    dentry, from->name);
+	done_path_create(&path, dentry);
+	if (retry_estale(error, lookup_flags)) {
+		lookup_flags |= LOOKUP_REVAL;
+		goto retry;
+	}
+out_putnames:
+	putname(to);
+	putname(from);
+	return error;
+}
+
+SYSCALL_DEFINE3(symlinkat, const char __user *, oldname,
+		int, newdfd, const char __user *, newname)
+{
+	return do_symlinkat(getname(oldname), newdfd, getname(newname));
+}
+
+SYSCALL_DEFINE2(symlink, const char __user *, oldname, const char __user *, newname)
+{
+	return do_symlinkat(getname(oldname), AT_FDCWD, getname(newname));
+}
+
+/**
+ * vfs_link - create a new link
+ * @old_dentry:	object to be linked
+ * @idmap:	idmap of the mount
+ * @dir:	new parent
+ * @new_dentry:	where to create the new link
+ * @delegated_inode: returns inode needing a delegation break
+ *
+ * The caller must hold dir->i_mutex
+ *
+ * If vfs_link discovers a delegation on the to-be-linked file in need
+ * of breaking, it will return -EWOULDBLOCK and return a reference to the
+ * inode in delegated_inode.  The caller should then break the delegation
+ * and retry.  Because breaking a delegation may take a long time, the
+ * caller should drop the i_mutex before doing so.
+ *
+ * Alternatively, a caller may pass NULL for delegated_inode.  This may
+ * be appropriate for callers that expect the underlying filesystem not
+ * to be NFS exported.
+ *
+ * If the inode has been found through an idmapped mount the idmap of
+ * the vfsmount must be passed through @idmap. This function will then take
+ * care to map the inode according to @idmap before checking permissions.
+ * On non-idmapped mounts or if permission checking is to be performed on the
+ * raw inode simply passs @nop_mnt_idmap.
+ */
+int vfs_link(struct dentry *old_dentry, struct mnt_idmap *idmap,
+	     struct inode *dir, struct dentry *new_dentry,
+	     struct inode **delegated_inode)
+{
+	struct inode *inode = old_dentry->d_inode;
+	unsigned max_links = dir->i_sb->s_max_links;
+	int error;
+
+	if (!inode)
+		return -ENOENT;
+
+	error = may_create(idmap, dir, new_dentry);
+	if (error)
+		return error;
+
+	if (dir->i_sb != inode->i_sb)
+		return -EXDEV;
+
+	/*
+	 * A link to an append-only or immutable file cannot be created.
+	 */
+	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+		return -EPERM;
+	/*
+	 * Updating the link count will likely cause i_uid and i_gid to
+	 * be writen back improperly if their true value is unknown to
+	 * the vfs.
+	 */
+	if (HAS_UNMAPPED_ID(idmap, inode))
+		return -EPERM;
+	if (!dir->i_op->link)
+		return -EPERM;
+	if (S_ISDIR(inode->i_mode))
+		return -EPERM;
+
+	error = security_inode_link(old_dentry, dir, new_dentry);
+	if (error)
+		return error;
+
+	inode_lock(inode);
+	/* Make sure we don't allow creating hardlink to an unlinked file */
+	if (inode->i_nlink == 0 && !(inode->i_state & I_LINKABLE))
+		error =  -ENOENT;
+	else if (max_links && inode->i_nlink >= max_links)
+		error = -EMLINK;
+	else {
+		error = try_break_deleg(inode, delegated_inode);
+		if (!error)
+			error = dir->i_op->link(old_dentry, dir, new_dentry);
+	}
+
+	if (!error && (inode->i_state & I_LINKABLE)) {
+		spin_lock(&inode->i_lock);
+		inode->i_state &= ~I_LINKABLE;
+		spin_unlock(&inode->i_lock);
+	}
+	inode_unlock(inode);
+	if (!error)
+		fsnotify_link(dir, inode, new_dentry);
+	return error;
+}
+EXPORT_SYMBOL_NS(vfs_link, ANDROID_GKI_VFS_EXPORT_ONLY);
+
+/*
+ * Hardlinks are often used in delicate situations.  We avoid
+ * security-related surprises by not following symlinks on the
+ * newname.  --KAB
+ *
+ * We don't follow them on the oldname either to be compatible
+ * with linux 2.0, and to avoid hard-linking to directories
+ * and other special files.  --ADM
+ */
+int do_linkat(int olddfd, struct filename *old, int newdfd,
+	      struct filename *new, int flags)
+{
+	struct mnt_idmap *idmap;
+	struct dentry *new_dentry;
+	struct path old_path, new_path;
+	struct inode *delegated_inode = NULL;
+	int how = 0;
+	int error;
+
+	if ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0) {
+		error = -EINVAL;
+		goto out_putnames;
+	}
+	/*
+	 * To use null names we require CAP_DAC_READ_SEARCH
+	 * This ensures that not everyone will be able to create
+	 * handlink using the passed filedescriptor.
+	 */
+	if (flags & AT_EMPTY_PATH && !capable(CAP_DAC_READ_SEARCH)) {
+		error = -ENOENT;
+		goto out_putnames;
+	}
+
+	if (flags & AT_SYMLINK_FOLLOW)
+		how |= LOOKUP_FOLLOW;
+retry:
+	error = filename_lookup(olddfd, old, how, &old_path, NULL);
+	if (error)
+		goto out_putnames;
+
+	new_dentry = filename_create(newdfd, new, &new_path,
+					(how & LOOKUP_REVAL));
+	error = PTR_ERR(new_dentry);
+	if (IS_ERR(new_dentry))
+		goto out_putpath;
+
+	error = -EXDEV;
+	if (old_path.mnt != new_path.mnt)
+		goto out_dput;
+	idmap = mnt_idmap(new_path.mnt);
+	error = may_linkat(idmap, &old_path);
+	if (unlikely(error))
+		goto out_dput;
+	error = security_path_link(old_path.dentry, &new_path, new_dentry);
+	if (error)
+		goto out_dput;
+	error = vfs_link(old_path.dentry, idmap, new_path.dentry->d_inode,
+			 new_dentry, &delegated_inode);
+out_dput:
+	done_path_create(&new_path, new_dentry);
+	if (delegated_inode) {
+		error = break_deleg_wait(&delegated_inode);
+		if (!error) {
+			path_put(&old_path);
+			goto retry;
+		}
+	}
+	if (retry_estale(error, how)) {
+		path_put(&old_path);
+		how |= LOOKUP_REVAL;
+		goto retry;
+	}
+out_putpath:
+	path_put(&old_path);
+out_putnames:
+	putname(old);
+	putname(new);
+
+	return error;
+}
+
+SYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,
+		int, newdfd, const char __user *, newname, int, flags)
+{
+	return do_linkat(olddfd, getname_uflags(oldname, flags),
+		newdfd, getname(newname), flags);
+}
+
+SYSCALL_DEFINE2(link, const char __user *, oldname, const char __user *, newname)
+{
+	return do_linkat(AT_FDCWD, getname(oldname), AT_FDCWD, getname(newname), 0);
+}
+
+/**
+ * vfs_rename - rename a filesystem object
+ * @rd:		pointer to &struct renamedata info
+ *
+ * The caller must hold multiple mutexes--see lock_rename()).
+ *
+ * If vfs_rename discovers a delegation in need of breaking at either
+ * the source or destination, it will return -EWOULDBLOCK and return a
+ * reference to the inode in delegated_inode.  The caller should then
+ * break the delegation and retry.  Because breaking a delegation may
+ * take a long time, the caller should drop all locks before doing
+ * so.
+ *
+ * Alternatively, a caller may pass NULL for delegated_inode.  This may
+ * be appropriate for callers that expect the underlying filesystem not
+ * to be NFS exported.
+ *
+ * The worst of all namespace operations - renaming directory. "Perverted"
+ * doesn't even start to describe it. Somebody in UCB had a heck of a trip...
+ * Problems:
+ *
+ *	a) we can get into loop creation.
+ *	b) race potential - two innocent renames can create a loop together.
+ *	   That's where 4.4BSD screws up. Current fix: serialization on
+ *	   sb->s_vfs_rename_mutex. We might be more accurate, but that's another
+ *	   story.
+ *	c) we may have to lock up to _four_ objects - parents and victim (if it exists),
+ *	   and source (if it's a non-directory or a subdirectory that moves to
+ *	   different parent).
+ *	   And that - after we got ->i_mutex on parents (until then we don't know
+ *	   whether the target exists).  Solution: try to be smart with locking
+ *	   order for inodes.  We rely on the fact that tree topology may change
+ *	   only under ->s_vfs_rename_mutex _and_ that parent of the object we
+ *	   move will be locked.  Thus we can rank directories by the tree
+ *	   (ancestors first) and rank all non-directories after them.
+ *	   That works since everybody except rename does "lock parent, lookup,
+ *	   lock child" and rename is under ->s_vfs_rename_mutex.
+ *	   HOWEVER, it relies on the assumption that any object with ->lookup()
+ *	   has no more than 1 dentry.  If "hybrid" objects will ever appear,
+ *	   we'd better make sure that there's no link(2) for them.
+ *	d) conversion from fhandle to dentry may come in the wrong moment - when
+ *	   we are removing the target. Solution: we will have to grab ->i_mutex
+ *	   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on
+ *	   ->i_mutex on parents, which works but leads to some truly excessive
+ *	   locking].
+ */
+int vfs_rename(struct renamedata *rd)
+{
+	int error;
+	struct inode *old_dir = rd->old_dir, *new_dir = rd->new_dir;
+	struct dentry *old_dentry = rd->old_dentry;
+	struct dentry *new_dentry = rd->new_dentry;
+	struct inode **delegated_inode = rd->delegated_inode;
+	unsigned int flags = rd->flags;
+	bool is_dir = d_is_dir(old_dentry);
+	struct inode *source = old_dentry->d_inode;
+	struct inode *target = new_dentry->d_inode;
+	bool new_is_dir = false;
+	unsigned max_links = new_dir->i_sb->s_max_links;
+	struct name_snapshot old_name;
+	bool lock_old_subdir, lock_new_subdir;
+
+	if (source == target)
+		return 0;
+
+	error = may_delete(rd->old_mnt_idmap, old_dir, old_dentry, is_dir);
+	if (error)
+		return error;
+
+	if (!target) {
+		error = may_create(rd->new_mnt_idmap, new_dir, new_dentry);
+	} else {
+		new_is_dir = d_is_dir(new_dentry);
+
+		if (!(flags & RENAME_EXCHANGE))
+			error = may_delete(rd->new_mnt_idmap, new_dir,
+					   new_dentry, is_dir);
+		else
+			error = may_delete(rd->new_mnt_idmap, new_dir,
+					   new_dentry, new_is_dir);
+	}
+	if (error)
+		return error;
+
+	if (!old_dir->i_op->rename)
+		return -EPERM;
+
+	/*
+	 * If we are going to change the parent - check write permissions,
+	 * we'll need to flip '..'.
+	 */
+	if (new_dir != old_dir) {
+		if (is_dir) {
+			error = inode_permission(rd->old_mnt_idmap, source,
+						 MAY_WRITE);
+			if (error)
+				return error;
+		}
+		if ((flags & RENAME_EXCHANGE) && new_is_dir) {
+			error = inode_permission(rd->new_mnt_idmap, target,
+						 MAY_WRITE);
+			if (error)
+				return error;
+		}
+	}
+
+	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,
+				      flags);
+	if (error)
+		return error;
+
+	take_dentry_name_snapshot(&old_name, old_dentry);
+	dget(new_dentry);
+	/*
+	 * Lock children.
+	 * The source subdirectory needs to be locked on cross-directory
+	 * rename or cross-directory exchange since its parent changes.
+	 * The target subdirectory needs to be locked on cross-directory
+	 * exchange due to parent change and on any rename due to becoming
+	 * a victim.
+	 * Non-directories need locking in all cases (for NFS reasons);
+	 * they get locked after any subdirectories (in inode address order).
+	 *
+	 * NOTE: WE ONLY LOCK UNRELATED DIRECTORIES IN CROSS-DIRECTORY CASE.
+	 * NEVER, EVER DO THAT WITHOUT ->s_vfs_rename_mutex.
+	 */
+	lock_old_subdir = new_dir != old_dir;
+	lock_new_subdir = new_dir != old_dir || !(flags & RENAME_EXCHANGE);
+	if (is_dir) {
+		if (lock_old_subdir)
+			inode_lock_nested(source, I_MUTEX_CHILD);
+		if (target && (!new_is_dir || lock_new_subdir))
+			inode_lock(target);
+	} else if (new_is_dir) {
+		if (lock_new_subdir)
+			inode_lock_nested(target, I_MUTEX_CHILD);
+		inode_lock(source);
+	} else {
+		lock_two_nondirectories(source, target);
+	}
+
+	error = -EPERM;
+	if (IS_SWAPFILE(source) || (target && IS_SWAPFILE(target)))
+		goto out;
+
+	error = -EBUSY;
+	if (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))
+		goto out;
+
+	if (max_links && new_dir != old_dir) {
+		error = -EMLINK;
+		if (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)
+			goto out;
+		if ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&
+		    old_dir->i_nlink >= max_links)
+			goto out;
+	}
+	if (!is_dir) {
+		error = try_break_deleg(source, delegated_inode);
+		if (error)
+			goto out;
+	}
+	if (target && !new_is_dir) {
+		error = try_break_deleg(target, delegated_inode);
+		if (error)
+			goto out;
+	}
+	error = old_dir->i_op->rename(rd->new_mnt_idmap, old_dir, old_dentry,
+				      new_dir, new_dentry, flags);
+	if (error)
+		goto out;
+
+	if (!(flags & RENAME_EXCHANGE) && target) {
+		if (is_dir) {
+			shrink_dcache_parent(new_dentry);
+			target->i_flags |= S_DEAD;
+		}
+		dont_mount(new_dentry);
+		detach_mounts(new_dentry);
+	}
+	if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {
+		if (!(flags & RENAME_EXCHANGE))
+			d_move(old_dentry, new_dentry);
+		else
+			d_exchange(old_dentry, new_dentry);
+	}
+out:
+	if (!is_dir || lock_old_subdir)
+		inode_unlock(source);
+	if (target && (!new_is_dir || lock_new_subdir))
+		inode_unlock(target);
+	dput(new_dentry);
+	if (!error) {
+		fsnotify_move(old_dir, new_dir, &old_name.name, is_dir,
+			      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);
+		if (flags & RENAME_EXCHANGE) {
+			fsnotify_move(new_dir, old_dir, &old_dentry->d_name,
+				      new_is_dir, NULL, new_dentry);
+		}
+	}
+	release_dentry_name_snapshot(&old_name);
+
+	return error;
+}
+EXPORT_SYMBOL_NS(vfs_rename, ANDROID_GKI_VFS_EXPORT_ONLY);
+
+int do_renameat2(int olddfd, struct filename *from, int newdfd,
+		 struct filename *to, unsigned int flags)
+{
+	struct renamedata rd;
+	struct dentry *old_dentry, *new_dentry;
+	struct dentry *trap;
+	struct path old_path, new_path;
+	struct qstr old_last, new_last;
+	int old_type, new_type;
+	struct inode *delegated_inode = NULL;
+	unsigned int lookup_flags = 0, target_flags = LOOKUP_RENAME_TARGET;
+	bool should_retry = false;
+	int error = -EINVAL;
+
+	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
+		goto put_names;
+
+	if ((flags & (RENAME_NOREPLACE | RENAME_WHITEOUT)) &&
+	    (flags & RENAME_EXCHANGE))
+		goto put_names;
+
+	if (flags & RENAME_EXCHANGE)
+		target_flags = 0;
+
+retry:
+	error = filename_parentat(olddfd, from, lookup_flags, &old_path,
+				  &old_last, &old_type);
+	if (error)
+		goto put_names;
+
+	error = filename_parentat(newdfd, to, lookup_flags, &new_path, &new_last,
+				  &new_type);
+	if (error)
+		goto exit1;
+
+	error = -EXDEV;
+	if (old_path.mnt != new_path.mnt)
+		goto exit2;
+
+	error = -EBUSY;
+	if (old_type != LAST_NORM)
+		goto exit2;
+
+	if (flags & RENAME_NOREPLACE)
+		error = -EEXIST;
+	if (new_type != LAST_NORM)
+		goto exit2;
+
+	error = mnt_want_write(old_path.mnt);
+	if (error)
+		goto exit2;
+
+retry_deleg:
+	trap = lock_rename(new_path.dentry, old_path.dentry);
+
+	old_dentry = lookup_one_qstr_excl(&old_last, old_path.dentry,
+					  lookup_flags);
+	error = PTR_ERR(old_dentry);
+	if (IS_ERR(old_dentry))
+		goto exit3;
+	/* source must exist */
+	error = -ENOENT;
+	if (d_is_negative(old_dentry))
+		goto exit4;
+	new_dentry = lookup_one_qstr_excl(&new_last, new_path.dentry,
+					  lookup_flags | target_flags);
+	error = PTR_ERR(new_dentry);
+	if (IS_ERR(new_dentry))
+		goto exit4;
+	error = -EEXIST;
+	if ((flags & RENAME_NOREPLACE) && d_is_positive(new_dentry))
+		goto exit5;
+	if (flags & RENAME_EXCHANGE) {
+		error = -ENOENT;
+		if (d_is_negative(new_dentry))
+			goto exit5;
+
+		if (!d_is_dir(new_dentry)) {
+			error = -ENOTDIR;
+			if (new_last.name[new_last.len])
+				goto exit5;
+		}
+	}
+	/* unless the source is a directory trailing slashes give -ENOTDIR */
+	if (!d_is_dir(old_dentry)) {
+		error = -ENOTDIR;
+		if (old_last.name[old_last.len])
+			goto exit5;
+		if (!(flags & RENAME_EXCHANGE) && new_last.name[new_last.len])
+			goto exit5;
+	}
+	/* source should not be ancestor of target */
+	error = -EINVAL;
+	if (old_dentry == trap)
+		goto exit5;
+	/* target should not be an ancestor of source */
+	if (!(flags & RENAME_EXCHANGE))
+		error = -ENOTEMPTY;
+	if (new_dentry == trap)
+		goto exit5;
+
+	error = security_path_rename(&old_path, old_dentry,
+				     &new_path, new_dentry, flags);
+	if (error)
+		goto exit5;
+
+	rd.old_dir	   = old_path.dentry->d_inode;
+	rd.old_dentry	   = old_dentry;
+	rd.old_mnt_idmap   = mnt_idmap(old_path.mnt);
+	rd.new_dir	   = new_path.dentry->d_inode;
+	rd.new_dentry	   = new_dentry;
+	rd.new_mnt_idmap   = mnt_idmap(new_path.mnt);
+	rd.delegated_inode = &delegated_inode;
+	rd.flags	   = flags;
+	error = vfs_rename(&rd);
+exit5:
+	dput(new_dentry);
+exit4:
+	dput(old_dentry);
+exit3:
+	unlock_rename(new_path.dentry, old_path.dentry);
+	if (delegated_inode) {
+		error = break_deleg_wait(&delegated_inode);
+		if (!error)
+			goto retry_deleg;
+	}
+	mnt_drop_write(old_path.mnt);
+exit2:
+	if (retry_estale(error, lookup_flags))
+		should_retry = true;
+	path_put(&new_path);
+exit1:
+	path_put(&old_path);
+	if (should_retry) {
+		should_retry = false;
+		lookup_flags |= LOOKUP_REVAL;
+		goto retry;
+	}
+put_names:
+	putname(from);
+	putname(to);
+	return error;
+}
+
+SYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname,
+		int, newdfd, const char __user *, newname, unsigned int, flags)
+{
+	return do_renameat2(olddfd, getname(oldname), newdfd, getname(newname),
+				flags);
+}
+
+SYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname,
+		int, newdfd, const char __user *, newname)
+{
+	return do_renameat2(olddfd, getname(oldname), newdfd, getname(newname),
+				0);
+}
+
+SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
+{
+	return do_renameat2(AT_FDCWD, getname(oldname), AT_FDCWD,
+				getname(newname), 0);
+}
+
+int readlink_copy(char __user *buffer, int buflen, const char *link)
+{
+	int len = PTR_ERR(link);
+	if (IS_ERR(link))
+		goto out;
+
+	len = strlen(link);
+	if (len > (unsigned) buflen)
+		len = buflen;
+	if (copy_to_user(buffer, link, len))
+		len = -EFAULT;
+out:
+	return len;
+}
+
+/**
+ * vfs_readlink - copy symlink body into userspace buffer
+ * @dentry: dentry on which to get symbolic link
+ * @buffer: user memory pointer
+ * @buflen: size of buffer
+ *
+ * Does not touch atime.  That's up to the caller if necessary
+ *
+ * Does not call security hook.
+ */
+int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen)
+{
+	struct inode *inode = d_inode(dentry);
+	DEFINE_DELAYED_CALL(done);
+	const char *link;
+	int res;
+
+	if (unlikely(!(inode->i_opflags & IOP_DEFAULT_READLINK))) {
+		if (unlikely(inode->i_op->readlink))
+			return inode->i_op->readlink(dentry, buffer, buflen);
+
+		if (!d_is_symlink(dentry))
+			return -EINVAL;
+
+		spin_lock(&inode->i_lock);
+		inode->i_opflags |= IOP_DEFAULT_READLINK;
+		spin_unlock(&inode->i_lock);
+	}
+
+	link = READ_ONCE(inode->i_link);
+	if (!link) {
+		link = inode->i_op->get_link(dentry, inode, &done);
+		if (IS_ERR(link))
+			return PTR_ERR(link);
+	}
+	res = readlink_copy(buffer, buflen, link);
+	do_delayed_call(&done);
+	return res;
+}
+EXPORT_SYMBOL(vfs_readlink);
+
+/**
+ * vfs_get_link - get symlink body
+ * @dentry: dentry on which to get symbolic link
+ * @done: caller needs to free returned data with this
+ *
+ * Calls security hook and i_op->get_link() on the supplied inode.
+ *
+ * It does not touch atime.  That's up to the caller if necessary.
+ *
+ * Does not work on "special" symlinks like /proc/$$/fd/N
+ */
+const char *vfs_get_link(struct dentry *dentry, struct delayed_call *done)
+{
+	const char *res = ERR_PTR(-EINVAL);
+	struct inode *inode = d_inode(dentry);
+
+	if (d_is_symlink(dentry)) {
+		res = ERR_PTR(security_inode_readlink(dentry));
+		if (!res)
+			res = inode->i_op->get_link(dentry, inode, done);
+	}
+	return res;
+}
+EXPORT_SYMBOL(vfs_get_link);
+
+/* get the link contents into pagecache */
+static char *__page_get_link(struct dentry *dentry, struct inode *inode,
+			     struct delayed_call *callback)
+{
+	struct page *page;
+	struct address_space *mapping = inode->i_mapping;
+
+	if (!dentry) {
+		page = find_get_page(mapping, 0);
+		if (!page)
+			return ERR_PTR(-ECHILD);
+		if (!PageUptodate(page)) {
+			put_page(page);
+			return ERR_PTR(-ECHILD);
+		}
+	} else {
+		page = read_mapping_page(mapping, 0, NULL);
+		if (IS_ERR(page))
+			return (char*)page;
+	}
+	set_delayed_call(callback, page_put_link, page);
+	BUG_ON(mapping_gfp_mask(mapping) & __GFP_HIGHMEM);
+	return page_address(page);
+}
+
+const char *page_get_link_raw(struct dentry *dentry, struct inode *inode,
+			      struct delayed_call *callback)
+{
+	return __page_get_link(dentry, inode, callback);
+}
+EXPORT_SYMBOL_GPL(page_get_link_raw);
+
+const char *page_get_link(struct dentry *dentry, struct inode *inode,
+					struct delayed_call *callback)
+{
+	char *kaddr = __page_get_link(dentry, inode, callback);
+
+	if (!IS_ERR(kaddr))
+		nd_terminate_link(kaddr, inode->i_size, PAGE_SIZE - 1);
+	return kaddr;
+}
+
+EXPORT_SYMBOL(page_get_link);
+
+void page_put_link(void *arg)
+{
+	put_page(arg);
+}
+EXPORT_SYMBOL(page_put_link);
+
+int page_readlink(struct dentry *dentry, char __user *buffer, int buflen)
+{
+	DEFINE_DELAYED_CALL(done);
+	int res = readlink_copy(buffer, buflen,
+				page_get_link(dentry, d_inode(dentry),
+					      &done));
+	do_delayed_call(&done);
+	return res;
+}
+EXPORT_SYMBOL(page_readlink);
+
+int page_symlink(struct inode *inode, const char *symname, int len)
+{
+	struct address_space *mapping = inode->i_mapping;
+	const struct address_space_operations *aops = mapping->a_ops;
+	bool nofs = !mapping_gfp_constraint(mapping, __GFP_FS);
+	struct page *page;
+	void *fsdata = NULL;
+	int err;
+	unsigned int flags;
+
+retry:
+	if (nofs)
+		flags = memalloc_nofs_save();
+	err = aops->write_begin(NULL, mapping, 0, len-1, &page, &fsdata);
+	if (nofs)
+		memalloc_nofs_restore(flags);
+	if (err)
+		goto fail;
+
+	memcpy(page_address(page), symname, len-1);
+
+	err = aops->write_end(NULL, mapping, 0, len-1, len-1,
+							page, fsdata);
+	if (err < 0)
+		goto fail;
+	if (err < len-1)
+		goto retry;
+
+	mark_inode_dirty(inode);
+	return 0;
+fail:
+	return err;
+}
+EXPORT_SYMBOL(page_symlink);
+
+const struct inode_operations page_symlink_inode_operations = {
+	.get_link	= page_get_link,
+};
+EXPORT_SYMBOL(page_symlink_inode_operations);
diff --git a/fs/proc/cmdline.c b/fs/proc/cmdline.c
index a6f761219..96acd598c 100644
--- a/fs/proc/cmdline.c
+++ b/fs/proc/cmdline.c
@@ -4,9 +4,19 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include "internal.h"
+#ifdef CONFIG_HYMOFS
+#include <linux/hymofs.h>
+#endif
 
 static int cmdline_proc_show(struct seq_file *m, void *v)
 {
+#ifdef CONFIG_HYMOFS_CMDLINE_SPOOF
+	/* HymoFS: try to spoof cmdline, returns 0 if spoofed */
+	if (hymofs_spoof_cmdline(m) == 0) {
+		seq_putc(m, '\n');
+		return 0;
+	}
+#endif
 	seq_puts(m, saved_command_line);
 	seq_putc(m, '\n');
 	return 0;
diff --git a/fs/readdir.c b/fs/readdir.c
index c8c46e294..d42d72ac2 100644
--- a/fs/readdir.c
+++ b/fs/readdir.c
@@ -24,6 +24,10 @@
 
 #include <asm/unaligned.h>
 
+#ifdef CONFIG_HYMOFS
+#include <linux/hymofs.h>
+#endif
+
 /*
  * Some filesystems were never converted to '->iterate_shared()'
  * and their directory iterators want the inode lock held for
@@ -172,6 +176,9 @@ struct old_linux_dirent {
 
 struct readdir_callback {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct hymo_readdir_context hymo;
+#endif
 	struct old_linux_dirent __user * dirent;
 	int result;
 };
@@ -225,11 +232,17 @@ SYSCALL_DEFINE3(old_readdir, unsigned int, fd,
 
 	if (!f.file)
 		return -EBADF;
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_prepare_readdir(&buf.hymo, f.file);
+#endif
 
 	error = iterate_dir(f.file, &buf.ctx);
 	if (buf.result)
 		error = buf.result;
 
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_cleanup_readdir(&buf.hymo);
+#endif
 	fdput_pos(f);
 	return error;
 }
@@ -249,10 +262,16 @@ struct linux_dirent {
 
 struct getdents_callback {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct hymo_readdir_context hymo;
+#endif
 	struct linux_dirent __user * current_dir;
 	int prev_reclen;
 	int count;
 	int error;
+#ifdef CONFIG_HYMOFS
+	bool buffer_full;
+#endif
 };
 
 static bool filldir(struct dir_context *ctx, const char *name, int namlen,
@@ -266,12 +285,21 @@ static bool filldir(struct dir_context *ctx, const char *name, int namlen,
 		sizeof(long));
 	int prev_reclen;
 
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+    if (hymofs_check_filldir(&buf->hymo, name, strlen(name))) return true;
+#endif
+
+
 	buf->error = verify_dirent_name(name, namlen);
 	if (unlikely(buf->error))
 		return false;
 	buf->error = -EINVAL;	/* only used if we fail.. */
-	if (reclen > buf->count)
+	if (reclen > buf->count) {
+#ifdef CONFIG_HYMOFS
+		buf->buffer_full = true;
+#endif
 		return false;
+	}
 	d_ino = ino;
 	if (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {
 		buf->error = -EOVERFLOW;
@@ -312,12 +340,33 @@ SYSCALL_DEFINE3(getdents, unsigned int, fd,
 		.ctx.actor = filldir,
 		.count = count,
 		.current_dir = dirent
+#ifdef CONFIG_HYMOFS
+		, .buffer_full = false
+#endif
 	};
 	int error;
 
 	f = fdget_pos(fd);
 	if (!f.file)
 		return -EBADF;
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_prepare_readdir(&buf.hymo, f.file);
+#endif
+#ifdef CONFIG_HYMOFS_INJECT_ENTRIES
+	if (f.file->f_pos >= HYMO_MAGIC_POS) {
+		void __user *dir_ptr = buf.current_dir;
+		int res = hymofs_inject_entries(&buf.hymo, &dir_ptr, &buf.count, &f.file->f_pos);
+		if (res >= 0)
+			error = count - buf.count;
+		else
+			error = res;
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+		hymofs_cleanup_readdir(&buf.hymo);
+#endif
+		fdput_pos(f);
+		return error;
+	}
+#endif
 
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
@@ -331,16 +380,33 @@ SYSCALL_DEFINE3(getdents, unsigned int, fd,
 		else
 			error = count - buf.count;
 	}
+#ifdef CONFIG_HYMOFS_INJECT_ENTRIES
+	if (error >= 0 && !buf.buffer_full && buf.ctx.pos < HYMO_MAGIC_POS && !signal_pending(current)) {
+		void __user *dir_ptr = buf.current_dir;
+		int res = hymofs_inject_entries(&buf.hymo, &dir_ptr, &buf.count, &f.file->f_pos);
+		if (res > 0)
+			error = count - buf.count;
+	}
+#endif
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_cleanup_readdir(&buf.hymo);
+#endif
 	fdput_pos(f);
 	return error;
 }
 
 struct getdents_callback64 {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct hymo_readdir_context hymo;
+#endif
 	struct linux_dirent64 __user * current_dir;
 	int prev_reclen;
 	int count;
 	int error;
+#ifdef CONFIG_HYMOFS
+	bool buffer_full;
+#endif
 };
 
 static bool filldir64(struct dir_context *ctx, const char *name, int namlen,
@@ -353,15 +419,25 @@ static bool filldir64(struct dir_context *ctx, const char *name, int namlen,
 		sizeof(u64));
 	int prev_reclen;
 
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	if (hymofs_check_filldir(&buf->hymo, name, namlen)) return true;
+#endif
+
+
 	buf->error = verify_dirent_name(name, namlen);
 	if (unlikely(buf->error))
 		return false;
 	buf->error = -EINVAL;	/* only used if we fail.. */
-	if (reclen > buf->count)
+	if (reclen > buf->count) {
+#ifdef CONFIG_HYMOFS
+		buf->buffer_full = true;
+#endif
 		return false;
+	}
 	prev_reclen = buf->prev_reclen;
 	if (prev_reclen && signal_pending(current))
 		return false;
+
 	dirent = buf->current_dir;
 	prev = (void __user *)dirent - prev_reclen;
 	if (!user_write_access_begin(prev, reclen + prev_reclen))
@@ -395,6 +471,9 @@ SYSCALL_DEFINE3(getdents64, unsigned int, fd,
 		.ctx.actor = filldir64,
 		.count = count,
 		.current_dir = dirent
+#ifdef CONFIG_HYMOFS
+		, .buffer_full = false
+#endif
 	};
 	int error;
 
@@ -402,6 +481,25 @@ SYSCALL_DEFINE3(getdents64, unsigned int, fd,
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_prepare_readdir(&buf.hymo, f.file);
+#endif
+#ifdef CONFIG_HYMOFS_INJECT_ENTRIES
+	if (f.file->f_pos >= HYMO_MAGIC_POS) {
+		void __user *dir_ptr = buf.current_dir;
+		int res = hymofs_inject_entries64(&buf.hymo, &dir_ptr, &buf.count, &f.file->f_pos);
+		if (res >= 0)
+			error = count - buf.count;
+		else
+			error = res;
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+		hymofs_cleanup_readdir(&buf.hymo);
+#endif
+		fdput_pos(f);
+		return error;
+	}
+#endif
+
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
@@ -415,6 +513,17 @@ SYSCALL_DEFINE3(getdents64, unsigned int, fd,
 		else
 			error = count - buf.count;
 	}
+#ifdef CONFIG_HYMOFS_INJECT_ENTRIES
+	if (error >= 0 && !buf.buffer_full && buf.ctx.pos < HYMO_MAGIC_POS && !signal_pending(current)) {
+		void __user *dir_ptr = buf.current_dir;
+		int res = hymofs_inject_entries64(&buf.hymo, &dir_ptr, &buf.count, &f.file->f_pos);
+		if (res > 0)
+			error = count - buf.count;
+	}
+#endif
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_cleanup_readdir(&buf.hymo);
+#endif
 	fdput_pos(f);
 	return error;
 }
@@ -429,6 +538,9 @@ struct compat_old_linux_dirent {
 
 struct compat_readdir_callback {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct hymo_readdir_context hymo;
+#endif
 	struct compat_old_linux_dirent __user *dirent;
 	int result;
 };
@@ -484,10 +596,17 @@ COMPAT_SYSCALL_DEFINE3(old_readdir, unsigned int, fd,
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_prepare_readdir(&buf.hymo, f.file);
+#endif
+
 	error = iterate_dir(f.file, &buf.ctx);
 	if (buf.result)
 		error = buf.result;
 
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_cleanup_readdir(&buf.hymo);
+#endif
 	fdput_pos(f);
 	return error;
 }
@@ -501,6 +620,9 @@ struct compat_linux_dirent {
 
 struct compat_getdents_callback {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct hymo_readdir_context hymo;
+#endif
 	struct compat_linux_dirent __user *current_dir;
 	int prev_reclen;
 	int count;
@@ -518,6 +640,10 @@ static bool compat_filldir(struct dir_context *ctx, const char *name, int namlen
 		namlen + 2, sizeof(compat_long_t));
 	int prev_reclen;
 
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+    if (hymofs_check_filldir(&buf->hymo, name, namlen)) return true;
+#endif
+
 	buf->error = verify_dirent_name(name, namlen);
 	if (unlikely(buf->error))
 		return false;
@@ -570,6 +696,10 @@ COMPAT_SYSCALL_DEFINE3(getdents, unsigned int, fd,
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_prepare_readdir(&buf.hymo, f.file);
+#endif
+
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
@@ -582,6 +712,9 @@ COMPAT_SYSCALL_DEFINE3(getdents, unsigned int, fd,
 		else
 			error = count - buf.count;
 	}
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_cleanup_readdir(&buf.hymo);
+#endif
 	fdput_pos(f);
 	return error;
 }
diff --git a/fs/stat.c b/fs/stat.c
index 517fa4ed8..0be080930 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -26,6 +26,10 @@
 #include "internal.h"
 #include "mount.h"
 
+#ifdef CONFIG_HYMOFS
+#include <linux/hymofs.h>
+#endif
+
 /**
  * generic_fillattr - Fill in the basic attributes from the inode struct
  * @idmap:		idmap of the mount the inode was found from
@@ -131,12 +135,20 @@ int vfs_getattr_nosec(const struct path *path, struct kstat *stat,
 				  STATX_ATTR_DAX);
 
 	idmap = mnt_idmap(path->mnt);
-	if (inode->i_op->getattr)
-		return inode->i_op->getattr(idmap, path, stat,
+	if (inode->i_op->getattr) {
+		int ret = inode->i_op->getattr(idmap, path, stat,
 					    request_mask,
 					    query_flags | AT_GETATTR_NOSEC);
+#ifdef CONFIG_HYMOFS_STAT_SPOOF
+		hymofs_post_getattr(path, inode, stat, ret);
+#endif
+		return ret;
+	}
 
 	generic_fillattr(idmap, request_mask, inode, stat);
+#ifdef CONFIG_HYMOFS_STAT_SPOOF
+	hymofs_post_getattr(path, inode, stat, 0);
+#endif
 	return 0;
 }
 EXPORT_SYMBOL(vfs_getattr_nosec);
@@ -235,6 +247,9 @@ static int vfs_statx(int dfd, struct filename *filename, int flags,
 	struct path path;
 	unsigned int lookup_flags = getname_statx_lookup_flags(flags);
 	int error;
+#ifdef CONFIG_HYMOFS
+	struct filename *hymo_filename = NULL;
+#endif
 
 	if (flags & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT | AT_EMPTY_PATH |
 		      AT_STATX_SYNC_TYPE))
@@ -242,6 +257,15 @@ static int vfs_statx(int dfd, struct filename *filename, int flags,
 
 retry:
 	error = filename_lookup(dfd, filename, lookup_flags, &path, NULL);
+	
+#ifdef CONFIG_HYMOFS_FORWARD_REDIRECT
+	/* HymoFS: Handle merge directory - relative path + dirfd case */
+	if (error == -ENOENT && dfd >= 0 && filename->name[0] != '/') {
+		hymo_filename = hymofs_resolve_relative(dfd, filename->name);
+		if (hymo_filename)
+			error = filename_lookup(AT_FDCWD, hymo_filename, lookup_flags, &path, NULL);
+	}
+#endif
 	if (error)
 		goto out;
 
@@ -268,6 +292,10 @@ static int vfs_statx(int dfd, struct filename *filename, int flags,
 		goto retry;
 	}
 out:
+#ifdef CONFIG_HYMOFS
+	if (hymo_filename)
+		putname(hymo_filename);
+#endif
 	return error;
 }
 
diff --git a/fs/xattr.c b/fs/xattr.c
index c49df4a39..60466875f 100644
--- a/fs/xattr.c
+++ b/fs/xattr.c
@@ -25,6 +25,9 @@
 #include <linux/posix_acl_xattr.h>
 
 #include <linux/uaccess.h>
+#ifdef CONFIG_HYMOFS
+#include <linux/hymofs.h>
+#endif
 
 #include "internal.h"
 
@@ -725,6 +728,10 @@ do_getxattr(struct mnt_idmap *idmap, struct dentry *d,
 {
 	ssize_t error;
 	char *kname = ctx->kname->name;
+#ifdef CONFIG_HYMOFS_XATTR_FILTER
+	if (hymofs_is_overlay_xattr(d, kname))
+		return -ENODATA;
+#endif
 
 	if (ctx->size) {
 		if (ctx->size > XATTR_SIZE_MAX)
@@ -831,6 +838,37 @@ listxattr(struct dentry *d, char __user *list, size_t size)
 	ssize_t error;
 	char *klist = NULL;
 
+#ifdef CONFIG_HYMOFS
+	size_t alloc_size = size;
+
+	if (!size) {
+		ssize_t res = vfs_listxattr(d, NULL, 0);
+		if (res <= 0)
+			return res;
+		alloc_size = res;
+	}
+
+	if (alloc_size > XATTR_LIST_MAX)
+		alloc_size = XATTR_LIST_MAX;
+
+	klist = kvmalloc(alloc_size, GFP_KERNEL);
+	if (!klist)
+		return -ENOMEM;
+
+	error = vfs_listxattr(d, klist, alloc_size);
+	if (error > 0) {
+#ifdef CONFIG_HYMOFS_XATTR_FILTER
+		error = hymofs_filter_xattrs(d, klist, error);
+#endif
+
+		if (size && copy_to_user(list, klist, error))
+			error = -EFAULT;
+	} else if (error == -ERANGE && size >= XATTR_LIST_MAX) {
+		/* The file system tried to returned a list bigger
+		   than XATTR_LIST_MAX bytes. Not possible. */
+		error = -E2BIG;
+	}
+#else
 	if (size) {
 		if (size > XATTR_LIST_MAX)
 			size = XATTR_LIST_MAX;
@@ -848,6 +886,7 @@ listxattr(struct dentry *d, char __user *list, size_t size)
 		   than XATTR_LIST_MAX bytes. Not possible. */
 		error = -E2BIG;
 	}
+#endif
 
 	kvfree(klist);
 
diff --git a/include/linux/hymo_magic.h b/include/linux/hymo_magic.h
new file mode 100644
index 000000000..66e1e5a09
--- /dev/null
+++ b/include/linux/hymo_magic.h
@@ -0,0 +1,127 @@
+#ifndef _LINUX_HYMO_MAGIC_H
+#define _LINUX_HYMO_MAGIC_H
+
+#ifdef __KERNEL__
+#include <linux/ioctl.h>
+#include <linux/types.h>
+#include <linux/bits.h>
+#else
+#include <sys/ioctl.h>
+#include <stddef.h>
+#include <stdint.h>
+#endif
+
+#define HYMO_MAGIC1 0x48594D4F // "HYMO"
+#define HYMO_MAGIC2 0x524F4F54 // "ROOT"
+#define HYMO_PROTOCOL_VERSION 12
+
+#define HYMO_MAX_LEN_PATHNAME 256
+#define HYMO_FAKE_CMDLINE_SIZE 4096
+
+/*
+ * HymoFS inode marking bits (stored in inode->i_mapping->flags)
+ * Using high bits to avoid conflict with kernel AS_* flags and SUSFS bits
+ * SUSFS uses bits 33-39, we use 40+
+ */
+#ifdef __KERNEL__
+#define AS_FLAGS_HYMO_HIDE 40
+#define BIT_HYMO_HIDE BIT(40)
+/* Marks a directory as containing hidden entries (for fast filldir skip) */
+#define AS_FLAGS_HYMO_DIR_HAS_HIDDEN 41
+#define BIT_HYMO_DIR_HAS_HIDDEN BIT(41)
+/* Marks an inode for kstat spoofing */
+#define AS_FLAGS_HYMO_SPOOF_KSTAT 42
+#define BIT_HYMO_SPOOF_KSTAT BIT(42)
+#endif
+
+// Only one syscall command: Get anonymous FD
+#define HYMO_CMD_GET_FD 0x48021
+
+struct hymo_syscall_arg {
+    const char *src;
+    const char *target;
+    int type;
+};
+
+struct hymo_syscall_list_arg {
+    char *buf;  // Keep as char* for output buffer
+    size_t size;
+};
+
+/* 
+ * kstat spoofing structure - allows full control over stat() results
+ * Similar to susfs sus_kstat but with HymoFS conventions
+ */
+struct hymo_spoof_kstat {
+    unsigned long target_ino;                           /* Target inode number (after mount/overlay) */
+    char target_pathname[HYMO_MAX_LEN_PATHNAME];        /* Path to spoof */
+    unsigned long spoofed_ino;                          /* Spoofed inode number */
+    unsigned long spoofed_dev;                          /* Spoofed device number */
+    unsigned int spoofed_nlink;                         /* Spoofed link count */
+    long long spoofed_size;                             /* Spoofed file size */
+    long spoofed_atime_sec;                             /* Spoofed access time (seconds) */
+    long spoofed_atime_nsec;                            /* Spoofed access time (nanoseconds) */
+    long spoofed_mtime_sec;                             /* Spoofed modification time (seconds) */
+    long spoofed_mtime_nsec;                            /* Spoofed modification time (nanoseconds) */
+    long spoofed_ctime_sec;                             /* Spoofed change time (seconds) */
+    long spoofed_ctime_nsec;                            /* Spoofed change time (nanoseconds) */
+    unsigned long spoofed_blksize;                      /* Spoofed block size */
+    unsigned long long spoofed_blocks;                  /* Spoofed block count */
+    int is_static;                                      /* If true, ino won't change after remount */
+    int err;                                            /* Error code for userspace feedback */
+};
+
+/*
+ * uname spoofing structure - spoof kernel version info
+ */
+#define HYMO_UNAME_LEN 65
+struct hymo_spoof_uname {
+    char sysname[HYMO_UNAME_LEN];                       
+    char nodename[HYMO_UNAME_LEN];                      
+    char release[HYMO_UNAME_LEN];                       /* e.g., "5.15.0-generic" */
+    char version[HYMO_UNAME_LEN];                       /* e.g., "#1 SMP PREEMPT ..." */
+    char machine[HYMO_UNAME_LEN];                       
+    char domainname[HYMO_UNAME_LEN];                    
+    int err;
+};
+
+/*
+ * cmdline spoofing structure - spoof /proc/cmdline
+ */
+struct hymo_spoof_cmdline {
+    char cmdline[HYMO_FAKE_CMDLINE_SIZE];               /* Fake cmdline content */
+    int err;
+};
+
+/*
+ * Feature flags for HYMO_CMD_GET_FEATURES
+ */
+#define HYMO_FEATURE_KSTAT_SPOOF    (1 << 0)
+#define HYMO_FEATURE_UNAME_SPOOF    (1 << 1)
+#define HYMO_FEATURE_CMDLINE_SPOOF  (1 << 2)
+#define HYMO_FEATURE_SELINUX_BYPASS (1 << 4)
+#define HYMO_FEATURE_MERGE_DIR      (1 << 5)
+
+// ioctl definitions (for fd-based mode)
+// Must be after struct definitions
+#define HYMO_IOC_MAGIC 'H'
+#define HYMO_IOC_ADD_RULE           _IOW(HYMO_IOC_MAGIC, 1, struct hymo_syscall_arg)
+#define HYMO_IOC_DEL_RULE           _IOW(HYMO_IOC_MAGIC, 2, struct hymo_syscall_arg)
+#define HYMO_IOC_HIDE_RULE          _IOW(HYMO_IOC_MAGIC, 3, struct hymo_syscall_arg)
+#define HYMO_IOC_CLEAR_ALL          _IO(HYMO_IOC_MAGIC, 5)
+#define HYMO_IOC_GET_VERSION        _IOR(HYMO_IOC_MAGIC, 6, int)
+#define HYMO_IOC_LIST_RULES         _IOWR(HYMO_IOC_MAGIC, 7, struct hymo_syscall_list_arg)
+#define HYMO_IOC_SET_DEBUG          _IOW(HYMO_IOC_MAGIC, 8, int)
+#define HYMO_IOC_REORDER_MNT_ID     _IO(HYMO_IOC_MAGIC, 9)
+#define HYMO_IOC_SET_STEALTH        _IOW(HYMO_IOC_MAGIC, 10, int)
+#define HYMO_IOC_HIDE_OVERLAY_XATTRS _IOW(HYMO_IOC_MAGIC, 11, struct hymo_syscall_arg)
+#define HYMO_IOC_ADD_MERGE_RULE     _IOW(HYMO_IOC_MAGIC, 12, struct hymo_syscall_arg)
+#define HYMO_IOC_SET_MIRROR_PATH    _IOW(HYMO_IOC_MAGIC, 14, struct hymo_syscall_arg)
+#define HYMO_IOC_ADD_SPOOF_KSTAT    _IOW(HYMO_IOC_MAGIC, 15, struct hymo_spoof_kstat)
+#define HYMO_IOC_UPDATE_SPOOF_KSTAT _IOW(HYMO_IOC_MAGIC, 16, struct hymo_spoof_kstat)
+#define HYMO_IOC_SET_UNAME          _IOW(HYMO_IOC_MAGIC, 17, struct hymo_spoof_uname)
+#define HYMO_IOC_SET_CMDLINE        _IOW(HYMO_IOC_MAGIC, 18, struct hymo_spoof_cmdline)
+#define HYMO_IOC_GET_FEATURES       _IOR(HYMO_IOC_MAGIC, 19, int)
+#define HYMO_IOC_SET_ENABLED        _IOW(HYMO_IOC_MAGIC, 20, int)
+
+#endif /* _LINUX_HYMO_MAGIC_H */
\ No newline at end of file
diff --git a/include/linux/hymofs.h b/include/linux/hymofs.h
new file mode 100644
index 000000000..300332fba
--- /dev/null
+++ b/include/linux/hymofs.h
@@ -0,0 +1,274 @@
+#ifndef _LINUX_HYMOFS_H
+#define _LINUX_HYMOFS_H
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/atomic.h>
+#include <linux/kernel.h> /* For system_state */
+#include <linux/thread_info.h> /* For thread_info flags */
+#include <linux/sched.h> /* For current */
+
+#ifdef CONFIG_HYMOFS
+
+#define HYMO_MAGIC_POS 0x7000000000000000ULL
+
+#define HYMO_DEFAULT_MIRROR_NAME "hymo_mirror"
+#define HYMO_DEFAULT_MIRROR_PATH "/dev/" HYMO_DEFAULT_MIRROR_NAME
+
+/* Internal command definitions (not exposed to userspace, used within hymo_dispatch_cmd) */
+#define HYMO_CMD_CLEAR_ALL          100
+#define HYMO_CMD_GET_VERSION        101
+#define HYMO_CMD_SET_DEBUG          102
+#define HYMO_CMD_REORDER_MNT_ID     103
+#define HYMO_CMD_SET_STEALTH        104
+#define HYMO_CMD_SET_ENABLED        105
+#define HYMO_CMD_LIST_RULES         106
+#define HYMO_CMD_SET_MIRROR_PATH    107
+#define HYMO_CMD_ADD_MERGE_RULE     108
+#define HYMO_CMD_ADD_RULE           109
+#define HYMO_CMD_HIDE_RULE          110
+#define HYMO_CMD_HIDE_OVERLAY_XATTRS 111
+#define HYMO_CMD_DEL_RULE           112
+#define HYMO_CMD_SET_UNAME          115
+
+struct hymo_merge_target_node {
+    struct list_head list;
+    char *target;
+    struct dentry *target_dentry;  /* Cached dentry for fast lookup */
+};
+
+/* Bloom filter for merge target filenames - ultra fast O(1) check */
+#define HYMO_BLOOM_BITS 10  /* 1024 bits = 128 bytes */
+#define HYMO_BLOOM_SIZE (1 << HYMO_BLOOM_BITS)
+#define HYMO_BLOOM_MASK (HYMO_BLOOM_SIZE - 1)
+
+/* Hash table for merge target filenames - O(1) lookup */
+#define HYMO_MERGE_HASH_BITS 6
+#define HYMO_MERGE_HASH_SIZE (1 << HYMO_MERGE_HASH_BITS)
+
+struct hymo_merge_file_entry {
+    struct hlist_node node;
+    char *name;
+    int namlen;
+};
+
+struct hymo_readdir_context {
+    struct file *file;
+    char *path_buf;
+    char *dir_path;
+    int dir_path_len;
+    bool entry_written;
+    struct list_head merge_targets;
+    bool is_replace_mode;
+    bool dir_has_hidden;  /* Fast path: skip hide check if false */
+    bool has_merge_files; /* Fast path: skip merge check if false */
+    unsigned long bloom_filter[HYMO_BLOOM_SIZE / BITS_PER_LONG]; /* Bloom filter for merge filenames */
+    struct hlist_head merge_files[HYMO_MERGE_HASH_SIZE]; /* Pre-built hash of merge target filenames */
+};
+
+extern bool hymofs_enabled;
+
+/* Syscall hook for legacy mode */
+extern int (*hymo_dispatch_cmd_hook)(unsigned int cmd, void __user *arg);
+
+/* ========== Directory entry hiding/injection ========== */
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+void __hymofs_prepare_readdir(struct hymo_readdir_context *ctx, struct file *file);
+void __hymofs_cleanup_readdir(struct hymo_readdir_context *ctx);
+bool __hymofs_check_filldir(struct hymo_readdir_context *ctx, const char *name, int namlen);
+#endif
+
+#ifdef CONFIG_HYMOFS_INJECT_ENTRIES
+int hymofs_inject_entries(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos);
+int hymofs_inject_entries64(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos);
+#endif
+
+/* ========== Stat spoofing ========== */
+#ifdef CONFIG_HYMOFS_STAT_SPOOF
+void hymofs_spoof_stat(const struct path *path, struct kstat *stat);
+void hymofs_spoof_kstat_by_ino(unsigned long ino, struct kstat *stat);
+bool hymofs_is_kstat_spoofed(struct inode *inode);
+void hymofs_post_getattr(const struct path *path, struct inode *inode, 
+                         struct kstat *stat, int ret);
+#endif
+
+/* ========== Extended attributes filtering ========== */
+#ifdef CONFIG_HYMOFS_XATTR_FILTER
+ssize_t hymofs_filter_xattrs(struct dentry *dentry, char *klist, ssize_t len);
+bool hymofs_is_overlay_xattr(struct dentry *dentry, const char *name);
+#endif
+
+/* ========== Uname spoofing ========== */
+#ifdef CONFIG_HYMOFS_UNAME_SPOOF
+struct new_utsname;
+void hymofs_spoof_uname(struct new_utsname *name);
+#endif
+
+/* ========== Cmdline spoofing ========== */
+#ifdef CONFIG_HYMOFS_CMDLINE_SPOOF
+struct seq_file;
+int hymofs_spoof_cmdline(struct seq_file *m);
+bool hymofs_is_cmdline_spoofed(void);
+#endif
+
+struct hymo_name_list {
+    char *name;
+    unsigned char type;
+    struct list_head list;
+};
+
+/* Performance information structure */
+struct hymofs_perf_info {
+    u64 total_checks;
+    u64 fast_path_skips;
+    u64 bloom_rejects;
+    u64 rule_hits;
+};
+
+/* ========== Forward redirection (namei) ========== */
+#ifdef CONFIG_HYMOFS_FORWARD_REDIRECT
+struct filename;
+struct filename *hymofs_handle_getname(struct filename *result);
+struct filename *hymofs_resolve_relative(int dfd, const char *name);
+char *__hymofs_resolve_target(const char *pathname);
+#endif
+
+/* ========== Reverse lookup (d_path) ========== */
+#ifdef CONFIG_HYMOFS_REVERSE_LOOKUP
+int __hymofs_reverse_lookup(const char *pathname, char *buf, size_t buflen);
+char *hymofs_process_d_path(char *res, char *buf, int buflen);
+#endif
+
+/* ========== Path hiding ========== */
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+bool __hymofs_should_hide(const char *pathname, size_t len);
+bool __hymofs_should_spoof_mtime(const char *pathname);
+int hymofs_populate_injected_list(const char *dir_path, struct dentry *parent, struct list_head *head);
+bool __hymofs_is_inode_hidden(struct inode *inode);
+#endif
+
+/* 
+ * Inline wrapper with fast-path checks
+ * 
+ * HymoFS design: Only privileged processes are marked
+ * Default (unmarked) = hidden, Marked = can see everything
+ */
+static __always_inline bool hymofs_is_inode_hidden(struct inode *inode)
+{
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+    /* Fast path: NULL checks */
+    if (unlikely(!inode || !inode->i_mapping))
+        return false;
+    
+    /* Fast path: Root sees everything */
+    if (uid_eq(current_uid(), GLOBAL_ROOT_UID))
+        return false;
+    
+    /* Fast path: No rules loaded */
+    if (!hymofs_enabled)
+        return false;
+    
+    return __hymofs_is_inode_hidden(inode);
+#else
+    return false;
+#endif
+}
+
+static inline void hymofs_prepare_readdir(struct hymo_readdir_context *ctx, struct file *file)
+{
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+    ctx->path_buf = NULL;
+    ctx->file = file;
+    if (!hymofs_enabled) return;
+    __hymofs_prepare_readdir(ctx, file);
+#endif
+}
+
+static inline void hymofs_cleanup_readdir(struct hymo_readdir_context *ctx)
+{
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+    if (ctx->path_buf) __hymofs_cleanup_readdir(ctx);
+#endif
+}
+
+static inline bool hymofs_check_filldir(struct hymo_readdir_context *ctx, const char *name, int namlen)
+{
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+    if (!ctx->path_buf) return false;
+    return __hymofs_check_filldir(ctx, name, namlen);
+#else
+    return false;
+#endif
+}
+
+static inline char *hymofs_resolve_target(const char *pathname)
+{
+#ifdef CONFIG_HYMOFS_FORWARD_REDIRECT
+    if (!hymofs_enabled) return NULL;
+    return __hymofs_resolve_target(pathname);
+#else
+    return NULL;
+#endif
+}
+
+static inline int hymofs_reverse_lookup(const char *pathname, char *buf, size_t buflen)
+{
+#ifdef CONFIG_HYMOFS_REVERSE_LOOKUP
+    if (!hymofs_enabled) return -1;
+    return __hymofs_reverse_lookup(pathname, buf, buflen);
+#else
+    return -1;
+#endif
+}
+
+static inline bool hymofs_should_hide(const char *pathname)
+{
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+    if (!hymofs_enabled) return false;
+    /* Fast path: check for NULL or empty */
+    if (!pathname || !*pathname) return false;
+    return __hymofs_should_hide(pathname, strlen(pathname));
+#else
+    return false;
+#endif
+}
+
+static inline bool hymofs_should_spoof_mtime(const char *pathname)
+{
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+    if (!hymofs_enabled) return false;
+    return __hymofs_should_spoof_mtime(pathname);
+#else
+    return false;
+#endif
+}
+
+#else
+
+/* ========== CONFIG_HYMOFS disabled - all stubs ========== */
+struct hymo_readdir_context {};
+static inline void hymofs_prepare_readdir(struct hymo_readdir_context *ctx, struct file *file) {}
+static inline void hymofs_cleanup_readdir(struct hymo_readdir_context *ctx) {}
+static inline bool hymofs_check_filldir(struct hymo_readdir_context *ctx, const char *name, int namlen) { return false; }
+static inline int hymofs_inject_entries(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos) { return 0; }
+static inline int hymofs_inject_entries64(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos) { return 0; }
+static inline void hymofs_spoof_stat(const struct path *path, struct kstat *stat) {}
+static inline ssize_t hymofs_filter_xattrs(struct dentry *dentry, char *klist, ssize_t len) { return len; }
+static inline bool hymofs_is_overlay_xattr(struct dentry *dentry, const char *name) { return false; }
+static inline struct filename *hymofs_handle_getname(struct filename *result) { return result; }
+static inline struct filename *hymofs_resolve_relative(int dfd, const char *name) { return NULL; }
+static inline char *hymofs_resolve_target(const char *pathname) { return NULL; }
+static inline int hymofs_reverse_lookup(const char *pathname, char *buf, size_t buflen) { return -1; }
+static inline bool hymofs_should_hide(const char *pathname) { return false; }
+static inline bool hymofs_should_spoof_mtime(const char *pathname) { return false; }
+static inline int hymofs_populate_injected_list(const char *dir_path, struct dentry *parent, struct list_head *head) { return 0; }
+static inline bool hymofs_is_inode_hidden(struct inode *inode) { return false; }
+static inline void hymofs_spoof_kstat_by_ino(unsigned long ino, struct kstat *stat) {}
+static inline bool hymofs_is_kstat_spoofed(struct inode *inode) { return false; }
+static inline void hymofs_spoof_uname(struct new_utsname *name) {}
+static inline int hymofs_spoof_cmdline(struct seq_file *m) { return 1; }
+static inline bool hymofs_is_cmdline_spoofed(void) { return false; }
+
+#endif /* CONFIG_HYMOFS */
+
+#endif /* _LINUX_HYMOFS_H */
diff --git a/kernel/reboot.c b/kernel/reboot.c
index 344ceaf5e..b4f73eb4f 100644
--- a/kernel/reboot.c
+++ b/kernel/reboot.c
@@ -18,6 +18,9 @@
 #include <linux/syscalls.h>
 #include <linux/syscore_ops.h>
 #include <linux/uaccess.h>
+#ifdef CONFIG_HYMOFS
+#include <linux/hymo_magic.h>
+#endif
 
 #include <trace/hooks/reboot.h>
 
@@ -29,6 +32,12 @@ static int C_A_D = 1;
 struct pid *cad_pid;
 EXPORT_SYMBOL(cad_pid);
 
+#ifdef CONFIG_HYMOFS
+/* HymoFS Hook */
+int (*hymo_dispatch_cmd_hook)(unsigned int cmd, void __user *arg) = NULL;
+EXPORT_SYMBOL(hymo_dispatch_cmd_hook);
+#endif
+
 #if defined(CONFIG_ARM)
 #define DEFAULT_REBOOT_MODE		= REBOOT_HARD
 #else
@@ -708,6 +717,13 @@ SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,
 	char buffer[256];
 	int ret = 0;
 
+#ifdef CONFIG_HYMOFS
+	/* HymoFS Hook */
+	if (magic1 == HYMO_MAGIC1 && magic2 == HYMO_MAGIC2 && hymo_dispatch_cmd_hook) {
+		return hymo_dispatch_cmd_hook(cmd, arg);
+	}
+#endif
+
 	/* We only trust the superuser with rebooting the system. */
 	if (!ns_capable(pid_ns->user_ns, CAP_SYS_BOOT))
 		return -EPERM;
diff --git a/kernel/sys.c b/kernel/sys.c
index c6b0141e4..2cd7b5331 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -78,6 +78,9 @@
 #include "uid16.h"
 
 #include <trace/hooks/sys.h>
+#ifdef CONFIG_HYMOFS
+#include <linux/hymofs.h>
+#endif
 
 #ifndef SET_UNALIGN_CTL
 # define SET_UNALIGN_CTL(a, b)	(-EINVAL)
@@ -1312,6 +1315,9 @@ SYSCALL_DEFINE1(newuname, struct new_utsname __user *, name)
 	down_read(&uts_sem);
 	memcpy(&tmp, utsname(), sizeof(tmp));
 	up_read(&uts_sem);
+#ifdef CONFIG_HYMOFS_UNAME_SPOOF
+	hymofs_spoof_uname(&tmp);
+#endif
 	if (copy_to_user(name, &tmp, sizeof(tmp)))
 		return -EFAULT;
 
@@ -1336,6 +1342,9 @@ SYSCALL_DEFINE1(uname, struct old_utsname __user *, name)
 	down_read(&uts_sem);
 	memcpy(&tmp, utsname(), sizeof(tmp));
 	up_read(&uts_sem);
+#ifdef CONFIG_HYMOFS_UNAME_SPOOF
+	hymofs_spoof_uname((struct new_utsname *)&tmp);
+#endif
 	if (copy_to_user(name, &tmp, sizeof(tmp)))
 		return -EFAULT;
 
