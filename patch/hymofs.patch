diff --git a/.DS_Store b/.DS_Store
new file mode 100644
index 000000000..a4e454388
Binary files /dev/null and b/.DS_Store differ
diff --git a/fs/Kconfig b/fs/Kconfig
index 410a8f553..7ed6607e2 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -388,3 +388,137 @@ config IO_WQ
 	bool
 
 endmenu
+
+menu "HymoFS"
+
+config HYMOFS
+	bool "HymoFS Support"
+	default n
+	help
+	  HymoFS is a kernel-level path manipulation and hiding framework.
+	  It provides various file system virtualization capabilities for
+	  advanced users and security researchers.
+	  
+	  If unsure, say N.
+
+config HYMOFS_REVERSE_LOOKUP
+	bool "Enable reverse path lookup (d_path hooks)"
+	depends on HYMOFS
+	default y
+	help
+	  Allow converting real paths back to virtual paths when userspace
+	  queries file paths. This is the reverse operation of forward redirect.
+	  
+	  - Low performance overhead (~5% on path resolution)
+	  - Effective on all processes
+	  - Required for complete path hiding
+	  
+	  If unsure, say Y.
+
+config HYMOFS_FORWARD_REDIRECT
+	bool "Enable forward path redirection (namei hooks)"
+	depends on HYMOFS
+	default y
+	help
+	  Allow redirecting virtual paths to real paths during file opening.
+	  This is the forward operation complementary to reverse lookup.
+	  
+	  - Low performance overhead (~3% on file open)
+	  - Effective on all processes
+	  - Required for path redirection
+	  
+	  If unsure, say Y.
+
+config HYMOFS_HIDE_ENTRIES
+	bool "Enable directory entry hiding"
+	depends on HYMOFS
+	default y
+	help
+	  Allow hiding user-defined files and directories from directory listing.
+	  
+	  - Medium performance overhead (~10% on directory traversal)
+	  - Effective on all processes
+	  - Uses in-kernel filtering during readdir()
+	  
+	  If unsure, say Y.
+
+config HYMOFS_INJECT_ENTRIES
+	bool "Enable directory entry injection (experimental)"
+	depends on HYMOFS
+	default n
+	help
+	  Allow injecting virtual files/directories into directory listings.
+	  
+	  - Medium-high performance overhead (~15% on directory traversal)
+	  - Effective on all processes
+	  - Experimental feature, may cause stability issues
+	  
+	  Disable if you don't need virtual files or care about performance.
+	  If unsure, say N.
+
+config HYMOFS_STAT_SPOOF
+	bool "Enable stat/kstat spoofing"
+	depends on HYMOFS
+	default n
+	help
+	  Allow spoofing file metadata (size, timestamps, mode, etc.).
+	  
+	  - Low performance overhead (~2% on stat calls)
+	  - Effective only on zygote spawned user app processes
+	  
+	  Disable if you don't need metadata manipulation.
+	  If unsure, say N.
+
+config HYMOFS_XATTR_FILTER
+	bool "Enable extended attributes filtering"
+	depends on HYMOFS
+	default y
+	help
+	  Allow filtering/spoofing extended attributes (xattr).
+	  
+	  - Very low performance overhead (~1% on xattr operations)
+	  - Effective on all processes
+	  - Commonly used to hide SELinux contexts
+	  
+	  If unsure, say Y.
+
+config HYMOFS_UNAME_SPOOF
+	bool "Enable uname spoofing"
+	depends on HYMOFS
+	default n
+	help
+	  Allow spoofing the output of uname syscall.
+	  
+	  - Negligible performance overhead
+	  - Effective on all processes
+	  
+	  Disable if you don't need to hide kernel version.
+	  If unsure, say N.
+
+config HYMOFS_CMDLINE_SPOOF
+	bool "Enable cmdline/bootconfig spoofing"
+	depends on HYMOFS
+	default n
+	help
+	  Allow spoofing /proc/cmdline and /proc/bootconfig.
+	  
+	  - Negligible performance overhead
+	  - Effective on all processes
+	  
+	  Disable if you don't need to hide boot parameters.
+	  If unsure, say N.
+
+config HYMOFS_DEBUG
+	bool "Enable HymoFS debug logging"
+	depends on HYMOFS
+	default n
+	help
+	  Enable verbose debug logging for HymoFS operations.
+	  
+	  - High performance overhead (for debugging only)
+	  - Logs all hook invocations to kernel log
+	  
+	  MUST be disabled in production builds.
+	  If unsure, say N.
+
+endmenu
diff --git a/fs/d_path.c b/fs/d_path.c
index 56a6ee4c6..68129b8b3 100644
--- a/fs/d_path.c
+++ b/fs/d_path.c
@@ -8,6 +8,10 @@
 #include <linux/prefetch.h>
 #include "mount.h"
 
+#ifdef CONFIG_HYMOFS_REVERSE_LOOKUP
+extern char *hymofs_process_d_path(char *res, char *buf, int buflen);
+#endif
+
 struct prepend_buffer {
 	char *buf;
 	int len;
@@ -234,6 +238,9 @@ char *d_absolute_path(const struct path *path,
 		return ERR_PTR(-EINVAL);
 	return extract_string(&b);
 }
+#ifdef CONFIG_HYMOFS
+EXPORT_SYMBOL(d_absolute_path);
+#endif
 
 static void get_fs_root_rcu(struct fs_struct *fs, struct path *root)
 {
@@ -290,7 +297,11 @@ char *d_path(const struct path *path, char *buf, int buflen)
 	prepend_path(path, &root, &b);
 	rcu_read_unlock();
 
+#ifdef CONFIG_HYMOFS_REVERSE_LOOKUP
+	return hymofs_process_d_path(extract_string(&b), buf, buflen);
+#else
 	return extract_string(&b);
+#endif
 }
 EXPORT_SYMBOL(d_path);
 
diff --git a/fs/exec.c b/fs/exec.c
index ae8f80895..07fdf8d60 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -76,9 +76,28 @@
 #include <trace/events/task.h>
 #include "internal.h"
 
+#ifdef CONFIG_HYMOFS
+#include <linux/hymofs.h>
+#endif
+
 #include <trace/events/sched.h>
 #include <trace/hooks/sched.h>
 
+#ifdef CONFIG_HYMOFS_FORWARD_REDIRECT
+static inline struct filename *hymofs_getname(const char __user *filename)
+{
+	return hymofs_handle_getname(getname(filename));
+}
+
+static inline struct filename *hymofs_getname_uflags(const char __user *filename, int flags)
+{
+	return hymofs_handle_getname(getname_uflags(filename, flags));
+}
+#else
+#define hymofs_getname getname
+#define hymofs_getname_uflags getname_uflags
+#endif
+
 static int bprm_creds_from_file(struct linux_binprm *bprm);
 
 int suid_dumpable = 0;
@@ -127,7 +146,7 @@ SYSCALL_DEFINE1(uselib, const char __user *, library)
 {
 	struct linux_binfmt *fmt;
 	struct file *file;
-	struct filename *tmp = getname(library);
+	struct filename *tmp = hymofs_getname(library);
 	int error = PTR_ERR(tmp);
 	static const struct open_flags uselib_flags = {
 		.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,
@@ -2129,7 +2148,11 @@ SYSCALL_DEFINE3(execve,
 		const char __user *const __user *, argv,
 		const char __user *const __user *, envp)
 {
-	return do_execve(getname(filename), argv, envp);
+	struct filename *name = hymofs_getname(filename);
+
+	if (IS_ERR(name))
+		return PTR_ERR(name);
+	return do_execve(name, argv, envp);
 }
 
 SYSCALL_DEFINE5(execveat,
@@ -2138,9 +2161,11 @@ SYSCALL_DEFINE5(execveat,
 		const char __user *const __user *, envp,
 		int, flags)
 {
-	return do_execveat(fd,
-			   getname_uflags(filename, flags),
-			   argv, envp, flags);
+	struct filename *name = hymofs_getname_uflags(filename, flags);
+
+	if (IS_ERR(name))
+		return PTR_ERR(name);
+	return do_execveat(fd, name, argv, envp, flags);
 }
 
 #ifdef CONFIG_COMPAT
@@ -2148,7 +2173,11 @@ COMPAT_SYSCALL_DEFINE3(execve, const char __user *, filename,
 	const compat_uptr_t __user *, argv,
 	const compat_uptr_t __user *, envp)
 {
-	return compat_do_execve(getname(filename), argv, envp);
+	struct filename *name = hymofs_getname(filename);
+
+	if (IS_ERR(name))
+		return PTR_ERR(name);
+	return compat_do_execve(name, argv, envp);
 }
 
 COMPAT_SYSCALL_DEFINE5(execveat, int, fd,
@@ -2157,9 +2186,11 @@ COMPAT_SYSCALL_DEFINE5(execveat, int, fd,
 		       const compat_uptr_t __user *, envp,
 		       int,  flags)
 {
-	return compat_do_execveat(fd,
-				  getname_uflags(filename, flags),
-				  argv, envp, flags);
+	struct filename *name = hymofs_getname_uflags(filename, flags);
+
+	if (IS_ERR(name))
+		return PTR_ERR(name);
+	return compat_do_execveat(fd, name, argv, envp, flags);
 }
 #endif
 
diff --git a/fs/hymofs.c b/fs/hymofs.c
new file mode 100644
index 000000000..375a449ad
--- /dev/null
+++ b/fs/hymofs.c
@@ -0,0 +1,2923 @@
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/file.h>
+#include <linux/fdtable.h>
+#include <linux/fsnotify.h>
+#include <linux/tty.h>
+#include <linux/namei.h>
+#include <linux/backing-dev.h>
+#include <linux/capability.h>
+#include <linux/securebits.h>
+#include <linux/security.h>
+#include <linux/mount.h>
+#include <linux/fcntl.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/dcache.h>
+#include <linux/path.h>
+#include <linux/hashtable.h>
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/dirent.h>
+#include <linux/cred.h>
+#include <linux/uidgid.h>
+#include <linux/vmalloc.h>
+#include <linux/spinlock.h>
+#include <linux/kernel.h>
+#include <linux/mnt_namespace.h>
+#include <linux/nsproxy.h>
+#include <linux/sched.h>
+#include <linux/fs_struct.h>
+#include <linux/sched/task.h>
+#include <linux/xattr.h>
+#include <linux/rcupdate.h>
+#include <linux/utsname.h>
+#include <linux/export.h>
+#include <linux/miscdevice.h>
+#include <linux/anon_inodes.h>
+#include <linux/jhash.h>
+#include <linux/version.h>
+#include <linux/xarray.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 12, 0))
+#include <linux/rbtree.h>
+#endif
+#include "mount.h"
+
+#include <linux/hymofs.h>
+#include <linux/hymo_magic.h>
+
+#ifdef CONFIG_HYMOFS
+
+/*
+ * dir_context.actor return type: 5.10/5.15 use int (0=continue), 6.1+ use bool (true=continue).
+ * Single source for all branches (5.10 / 5.15 / 6.1 / 6.6 / 6.12).
+ */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
+#define HYMO_FILLDIR_RET_TYPE int
+#define HYMO_FILLDIR_CONTINUE 0
+#define HYMO_FILLDIR_STOP 1
+#else
+#define HYMO_FILLDIR_RET_TYPE bool
+#define HYMO_FILLDIR_CONTINUE true
+#define HYMO_FILLDIR_STOP false
+#endif
+
+/* HymoFS - Advanced Path Manipulation and Hiding */
+/* Increased hash bits to reduce collisions with large number of rules */
+#define HYMO_HASH_BITS 12
+#define HYMO_ALLOWLIST_UID_MAX 1024
+#define HYMO_KSU_ALLOWLIST_PATH "/data/adb/ksu/.allowlist"
+#define HYMO_KSU_ALLOWLIST_MAGIC 0x7f4b5355
+#define HYMO_KSU_ALLOWLIST_VERSION 3
+#define HYMO_KSU_MAX_PACKAGE_NAME 256
+#define HYMO_KSU_MAX_GROUPS 32
+#define HYMO_KSU_SELINUX_DOMAIN 64
+
+struct hymo_linux_dirent {
+	unsigned long	d_ino;
+	unsigned long	d_off;
+	unsigned short	d_reclen;
+	char		d_name[];
+};
+
+struct hymo_entry {
+    char *src;
+    char *target;
+    unsigned char type;
+    u32 src_hash; /* cached full_name_hash for hot path: compare before strcmp */
+    struct hlist_node node;
+    struct hlist_node target_node;
+    struct rcu_head rcu;
+};
+struct hymo_hide_entry {
+    char *path;
+    u32 path_hash; /* cached full_name_hash for hot path */
+    struct hlist_node node;
+    struct rcu_head rcu;
+};
+
+/* Allowlist UIDs: stored in xarray by uid index; value is non-NULL marker */
+#define HYMO_UID_ALLOW_MARKER ((void *)1)
+
+struct hymo_root_profile {
+    s32 uid;
+    s32 gid;
+    s32 groups_count;
+    s32 groups[HYMO_KSU_MAX_GROUPS];
+    struct {
+        u64 effective;
+        u64 permitted;
+        u64 inheritable;
+    } capabilities;
+    char selinux_domain[HYMO_KSU_SELINUX_DOMAIN];
+    s32 namespaces;
+};
+
+struct hymo_non_root_profile {
+    bool umount_modules;
+};
+
+struct hymo_app_profile {
+    u32 version;
+    char key[HYMO_KSU_MAX_PACKAGE_NAME];
+    s32 current_uid;
+    bool allow_su;
+    union {
+        struct {
+            bool use_default;
+            char template_name[HYMO_KSU_MAX_PACKAGE_NAME];
+            struct hymo_root_profile profile;
+        } rp_config;
+        struct {
+            bool use_default;
+            struct hymo_non_root_profile profile;
+        } nrp_config;
+    };
+};
+
+struct hymo_inject_entry {
+    char *dir;
+    struct hlist_node node;
+    struct rcu_head rcu;
+};
+
+struct hymo_xattr_sb_entry {
+    struct super_block *sb;
+    struct hlist_node node;
+    struct rcu_head rcu;
+};
+
+struct hymo_merge_entry {
+    char *src;
+    char *target;
+    struct hlist_node node;
+    struct rcu_head rcu;
+};
+
+/* Prefix trie for merge rules: longest-prefix match in one path walk */
+struct hymo_merge_trie_node {
+    char *comp;
+    size_t comp_len;
+    struct hymo_merge_trie_node *first_child;
+    struct hymo_merge_trie_node *next_sibling;
+    struct hymo_merge_entry *entry;
+    struct rcu_head rcu; /* used only for root when freeing via call_rcu */
+};
+
+static struct hymo_merge_trie_node *hymo_merge_trie_root __rcu;
+static DEFINE_SPINLOCK(hymo_merge_trie_lock);
+
+static DEFINE_HASHTABLE(hymo_paths, HYMO_HASH_BITS);
+static DEFINE_HASHTABLE(hymo_targets, HYMO_HASH_BITS);
+static DEFINE_HASHTABLE(hymo_hide_paths, HYMO_HASH_BITS);
+static DEFINE_XARRAY(hymo_allow_uids_xa);
+static DEFINE_HASHTABLE(hymo_inject_dirs, HYMO_HASH_BITS);
+static DEFINE_HASHTABLE(hymo_xattr_sbs, HYMO_HASH_BITS);
+static DEFINE_HASHTABLE(hymo_merge_dirs, HYMO_HASH_BITS);
+/* Fine-grained locks to reduce contention (backported from hymofs_kpm) */
+static DEFINE_SPINLOCK(hymo_cfg_lock);       /* enable/mirror path toggles */
+static DEFINE_SPINLOCK(hymo_rules_lock);     /* hymo_paths + hymo_targets */
+static DEFINE_SPINLOCK(hymo_hide_lock);      /* hymo_hide_paths */
+static DEFINE_SPINLOCK(hymo_allow_uids_lock); /* hymo_allow_uids_xa */
+static DEFINE_SPINLOCK(hymo_xattr_sbs_lock); /* hymo_xattr_sbs */
+static DEFINE_SPINLOCK(hymo_merge_lock);      /* hymo_merge_dirs */
+static DEFINE_SPINLOCK(hymo_inject_lock);    /* hymo_inject_dirs */
+static bool hymo_allowlist_loaded = false;
+static DEFINE_MUTEX(hymo_allowlist_lock);
+bool hymofs_enabled = false;
+EXPORT_SYMBOL(hymofs_enabled);
+
+/* Use HYMO_BLOOM_BITS from hymofs.h to avoid redefinition */
+static DECLARE_BITMAP(hymo_path_bloom, HYMO_BLOOM_SIZE);
+static DECLARE_BITMAP(hymo_hide_bloom, HYMO_BLOOM_SIZE);
+static atomic_t hymo_rule_count = ATOMIC_INIT(0);
+static atomic_t hymo_hide_count = ATOMIC_INIT(0);
+
+static bool hymo_debug_enabled = false;
+module_param(hymo_debug_enabled, bool, 0644);
+MODULE_PARM_DESC(hymo_debug_enabled, "Enable debug logging");
+static bool hymo_stealth_enabled = true;
+
+static char hymo_mirror_path_buf[PATH_MAX] = HYMO_DEFAULT_MIRROR_PATH;
+static char hymo_mirror_name_buf[NAME_MAX] = HYMO_DEFAULT_MIRROR_NAME;
+static char *hymo_current_mirror_path = hymo_mirror_path_buf;
+static char *hymo_current_mirror_name = hymo_mirror_name_buf;
+
+/* Daemon PID - automatically registered when GET_FD is called */
+static pid_t hymo_daemon_pid = 0;
+static DEFINE_SPINLOCK(hymo_daemon_lock);
+
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+static bool hymo_reload_ksu_allowlist(void);
+#endif
+
+#define hymo_log(fmt, ...) do { \
+    if (hymo_debug_enabled) \
+        printk(KERN_INFO "hymofs: " fmt, ##__VA_ARGS__); \
+} while(0)
+
+/* Performance statistics */
+struct hymofs_stats {
+    atomic64_t total_checks;
+    atomic64_t fast_path_skips;
+    atomic64_t bloom_rejects;
+    atomic64_t rule_hits;
+};
+
+static struct hymofs_stats hymo_stats = {
+    .total_checks = ATOMIC64_INIT(0),
+    .fast_path_skips = ATOMIC64_INIT(0),
+    .bloom_rejects = ATOMIC64_INIT(0),
+    .rule_hits = ATOMIC64_INIT(0),
+};
+
+static struct hymo_uname_info {
+	char sysname[65];
+	char nodename[65];
+	char release[65];
+	char version[65];
+	char machine[65];
+	char domainname[65];
+} hymo_uname_info = { 0 };
+
+static DEFINE_SPINLOCK(hymo_uname_lock);
+
+/* RCU callback functions for deferred free */
+static void hymo_entry_free_rcu(struct rcu_head *head)
+{
+    struct hymo_entry *e = container_of(head, struct hymo_entry, rcu);
+    kfree(e->src);
+    kfree(e->target);
+    kfree(e);
+}
+
+static void hymo_hide_entry_free_rcu(struct rcu_head *head)
+{
+    struct hymo_hide_entry *e = container_of(head, struct hymo_hide_entry, rcu);
+    kfree(e->path);
+    kfree(e);
+}
+
+static void hymo_inject_entry_free_rcu(struct rcu_head *head)
+{
+    struct hymo_inject_entry *e = container_of(head, struct hymo_inject_entry, rcu);
+    kfree(e->dir);
+    kfree(e);
+}
+
+static void hymo_xattr_sb_entry_free_rcu(struct rcu_head *head)
+{
+    struct hymo_xattr_sb_entry *e = container_of(head, struct hymo_xattr_sb_entry, rcu);
+    kfree(e);
+}
+
+static void hymo_merge_entry_free_rcu(struct rcu_head *head)
+{
+    struct hymo_merge_entry *e = container_of(head, struct hymo_merge_entry, rcu);
+    kfree(e->src);
+    kfree(e->target);
+    kfree(e);
+}
+
+/* Free trie subtree (recursive); node itself is freed by caller or rcu callback */
+static void hymo_merge_trie_free_node(struct hymo_merge_trie_node *n)
+{
+    struct hymo_merge_trie_node *c, *next;
+
+    if (!n)
+        return;
+    for (c = n->first_child; c; c = next) {
+        next = c->next_sibling;
+        hymo_merge_trie_free_node(c);
+    }
+    kfree(n->comp);
+    kfree(n);
+}
+
+static void hymo_merge_trie_free_rcu(struct rcu_head *head)
+{
+    struct hymo_merge_trie_node *root = container_of(head, struct hymo_merge_trie_node, rcu);
+    hymo_merge_trie_free_node(root);
+}
+
+/* Build trie from current hymo_merge_dirs; call under hymo_merge_lock. */
+static void hymo_merge_trie_build_locked(void)
+{
+    struct hymo_merge_trie_node *new_root;
+    struct hymo_merge_trie_node *cur, **slot;
+    struct hymo_merge_entry *merge_entry;
+    const char *path, *start;
+    char *comp;
+    size_t comp_len;
+    int bkt;
+    struct hymo_merge_trie_node *old_root;
+
+    spin_lock(&hymo_merge_trie_lock);
+    new_root = kzalloc(sizeof(*new_root), GFP_ATOMIC);
+    if (!new_root) {
+        spin_unlock(&hymo_merge_trie_lock);
+        return;
+    }
+
+    hash_for_each(hymo_merge_dirs, bkt, merge_entry, node) {
+        if (!merge_entry->src)
+            continue;
+        path = merge_entry->src;
+        while (*path == '/')
+            path++;
+        cur = new_root;
+        while (*path) {
+            start = path;
+            while (*path && *path != '/')
+                path++;
+            comp_len = (size_t)(path - start);
+            if (comp_len == 0) {
+                if (*path)
+                    path++;
+                continue;
+            }
+            comp = kmalloc(comp_len + 1, GFP_ATOMIC);
+            if (!comp)
+                break;
+            memcpy(comp, start, comp_len);
+            comp[comp_len] = '\0';
+            for (slot = &cur->first_child; *slot; slot = &(*slot)->next_sibling) {
+                if ((*slot)->comp_len == comp_len && memcmp((*slot)->comp, comp, comp_len) == 0)
+                    break;
+            }
+            if (!*slot) {
+                *slot = kzalloc(sizeof(struct hymo_merge_trie_node), GFP_ATOMIC);
+                if (!*slot) {
+                    kfree(comp);
+                    break;
+                }
+                (*slot)->comp = comp;
+                (*slot)->comp_len = comp_len;
+            } else {
+                kfree(comp);
+            }
+            cur = *slot;
+            if (*path == '/')
+                path++;
+        }
+        cur->entry = merge_entry;
+    }
+
+    old_root = rcu_dereference_protected(hymo_merge_trie_root, lockdep_is_held(&hymo_merge_trie_lock));
+    rcu_assign_pointer(hymo_merge_trie_root, new_root);
+    if (old_root) {
+        old_root->rcu.next = NULL;
+        old_root->rcu.func = hymo_merge_trie_free_rcu;
+        call_rcu(&old_root->rcu, hymo_merge_trie_free_rcu);
+    }
+    spin_unlock(&hymo_merge_trie_lock);
+}
+
+/* Longest-prefix lookup; call under rcu_read_lock. Returns NULL if no match. */
+static struct hymo_merge_entry *hymo_merge_trie_lookup_longest(const char *pathname)
+{
+    struct hymo_merge_trie_node *root, *cur, *child;
+    const char *path, *start;
+    size_t comp_len;
+    struct hymo_merge_entry *last = NULL;
+
+    root = rcu_dereference(hymo_merge_trie_root);
+    if (!root)
+        return NULL;
+    path = pathname;
+    while (*path == '/')
+        path++;
+    cur = root;
+    while (*path) {
+        start = path;
+        while (*path && *path != '/')
+            path++;
+        comp_len = (size_t)(path - start);
+        if (comp_len == 0) {
+            if (*path)
+                path++;
+            continue;
+        }
+        for (child = rcu_dereference(cur->first_child); child; child = rcu_dereference(child->next_sibling)) {
+            if (child->comp_len == comp_len && memcmp(child->comp, start, comp_len) == 0)
+                break;
+        }
+        if (!child)
+            return last;
+        cur = child;
+        if (cur->entry)
+            last = cur->entry;
+        if (*path == '/')
+            path++;
+    }
+    return last;
+}
+
+static inline void hymofs_mark_inode_hidden(struct inode *inode)
+{
+    if (inode && inode->i_mapping) {
+        set_bit(AS_FLAGS_HYMO_HIDE, &inode->i_mapping->flags);
+    }
+}
+
+static inline void hymofs_unmark_inode_hidden(struct inode *inode)
+{
+    if (inode && inode->i_mapping) {
+        clear_bit(AS_FLAGS_HYMO_HIDE, &inode->i_mapping->flags);
+    }
+}
+
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+bool __hymofs_is_inode_hidden(struct inode *inode)
+{
+    return test_bit(AS_FLAGS_HYMO_HIDE, &inode->i_mapping->flags);
+}
+EXPORT_SYMBOL(__hymofs_is_inode_hidden);
+#endif
+
+static void hymo_cleanup_locked(void) {
+    struct hymo_entry *entry;
+    struct hymo_hide_entry *hide_entry;
+    struct hymo_inject_entry *inject_entry;
+    struct hymo_xattr_sb_entry *sb_entry;
+    struct hymo_merge_entry *merge_entry;
+    struct hlist_node *tmp;
+    int bkt;
+
+    /* Mark entries for RCU deletion - actual freeing happens after grace period */
+    hash_for_each_safe(hymo_paths, bkt, tmp, entry, node) {
+        hlist_del_rcu(&entry->node);
+        hlist_del_rcu(&entry->target_node);
+        call_rcu(&entry->rcu, hymo_entry_free_rcu);
+    }
+    hash_for_each_safe(hymo_hide_paths, bkt, tmp, hide_entry, node) {
+        hlist_del_rcu(&hide_entry->node);
+        call_rcu(&hide_entry->rcu, hymo_hide_entry_free_rcu);
+    }
+    xa_destroy(&hymo_allow_uids_xa);
+    hash_for_each_safe(hymo_inject_dirs, bkt, tmp, inject_entry, node) {
+        hlist_del_rcu(&inject_entry->node);
+        call_rcu(&inject_entry->rcu, hymo_inject_entry_free_rcu);
+    }
+    hash_for_each_safe(hymo_xattr_sbs, bkt, tmp, sb_entry, node) {
+        hlist_del_rcu(&sb_entry->node);
+        call_rcu(&sb_entry->rcu, hymo_xattr_sb_entry_free_rcu);
+    }
+    hash_for_each_safe(hymo_merge_dirs, bkt, tmp, merge_entry, node) {
+        hlist_del_rcu(&merge_entry->node);
+        call_rcu(&merge_entry->rcu, hymo_merge_entry_free_rcu);
+    }
+    {
+        struct hymo_merge_trie_node *old_trie;
+
+        spin_lock(&hymo_merge_trie_lock);
+        old_trie = rcu_dereference_protected(hymo_merge_trie_root, lockdep_is_held(&hymo_merge_trie_lock));
+        rcu_assign_pointer(hymo_merge_trie_root, NULL);
+        if (old_trie) {
+            old_trie->rcu.next = NULL;
+            old_trie->rcu.func = hymo_merge_trie_free_rcu;
+            call_rcu(&old_trie->rcu, hymo_merge_trie_free_rcu);
+        }
+        spin_unlock(&hymo_merge_trie_lock);
+    }
+
+    bitmap_zero(hymo_path_bloom, HYMO_BLOOM_SIZE);
+    bitmap_zero(hymo_hide_bloom, HYMO_BLOOM_SIZE);
+    atomic_set(&hymo_rule_count, 0);
+    atomic_set(&hymo_hide_count, 0);
+    hymo_allowlist_loaded = false;
+}
+
+/* Forward declaration for ioctl handler */
+static long hymo_anon_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+
+/* Anonymous file operations for HymoFS fd */
+static const struct file_operations hymo_anon_fops = {
+    .owner          = THIS_MODULE,
+    .unlocked_ioctl = hymo_anon_ioctl,
+    .compat_ioctl   = hymo_anon_ioctl,
+    .llseek         = noop_llseek,
+};
+
+static void hymofs_add_inject_rule(char *dir)
+{
+    struct hymo_inject_entry *inject_entry;
+    u32 hash;
+    bool found = false;
+
+    if (!dir) return;
+
+    hash = full_name_hash(NULL, dir, strlen(dir));
+    spin_lock(&hymo_inject_lock);
+    hlist_for_each_entry(inject_entry, &hymo_inject_dirs[hash_min(hash, HYMO_HASH_BITS)], node) {
+        if (strcmp(inject_entry->dir, dir) == 0) {
+            found = true;
+            break;
+        }
+    }
+    if (!found) {
+        inject_entry = kmalloc(sizeof(*inject_entry), GFP_ATOMIC);
+        if (inject_entry) {
+            inject_entry->dir = dir;
+            hlist_add_head_rcu(&inject_entry->node, &hymo_inject_dirs[hash_min(hash, HYMO_HASH_BITS)]);
+            atomic_inc(&hymo_rule_count);
+            hymo_log("auto-inject parent: %s\n", dir);
+        } else {
+            kfree(dir);
+        }
+    } else {
+        kfree(dir);
+    }
+    spin_unlock(&hymo_inject_lock);
+}
+
+static void hymofs_reorder_mnt_id(void)
+{
+    struct mnt_namespace *ns = current->nsproxy->mnt_ns;
+    struct mount *m;
+    int id = 1;
+    bool is_hymo_mount;
+
+    if (!ns) return;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 12, 0))
+    /* 6.12+: ns->mounts is rb_root */
+    struct mount *n;
+    if (ns->mounts.rb_node) {
+        struct rb_node *first_node = rb_first(&ns->mounts);
+        if (first_node) {
+            struct mount *first = rb_entry(first_node, struct mount, mnt_node);
+            if (first->mnt_id < 500000)
+                id = first->mnt_id;
+        }
+    }
+    rbtree_postorder_for_each_entry_safe(m, n, &ns->mounts, mnt_node) {
+#else
+    if (!list_empty(&ns->list)) {
+        struct mount *first = list_first_entry(&ns->list, struct mount, mnt_list);
+        if (first->mnt_id < 500000)
+            id = first->mnt_id;
+    }
+    list_for_each_entry(m, &ns->list, mnt_list) {
+#endif
+        is_hymo_mount = false;
+
+        if (m->mnt_devname && (
+            strcmp(m->mnt_devname, hymo_current_mirror_path) == 0 ||
+            strcmp(m->mnt_devname, hymo_current_mirror_name) == 0
+        )) {
+            is_hymo_mount = true;
+        }
+
+        if (is_hymo_mount && hymo_stealth_enabled) {
+            if (m->mnt_id < 500000) {
+                WRITE_ONCE(m->mnt_id, 500000 + (id % 1000));
+            }
+        } else {
+            if (m->mnt_id >= 500000) continue;
+            WRITE_ONCE(m->mnt_id, id++);
+        }
+    }
+}
+
+static void hymofs_spoof_mounts(void)
+{
+    struct mnt_namespace *ns = current->nsproxy->mnt_ns;
+    struct mount *m;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 12, 0))
+    struct mount *n;
+#endif
+    char *system_devname = NULL;
+    struct path sys_path;
+
+    if (!ns) return;
+    if (!hymo_stealth_enabled) return;
+
+    if (kern_path("/system", LOOKUP_FOLLOW, &sys_path) == 0) {
+        struct mount *sys_mnt = real_mount(sys_path.mnt);
+        if (sys_mnt && sys_mnt->mnt_devname) {
+            system_devname = kstrdup(sys_mnt->mnt_devname, GFP_KERNEL);
+        }
+        path_put(&sys_path);
+    }
+    
+    if (!system_devname) {
+        if (kern_path("/", LOOKUP_FOLLOW, &sys_path) == 0) {
+            struct mount *sys_mnt = real_mount(sys_path.mnt);
+            if (sys_mnt && sys_mnt->mnt_devname) {
+                system_devname = kstrdup(sys_mnt->mnt_devname, GFP_KERNEL);
+            }
+            path_put(&sys_path);
+        }
+    }
+
+    if (!system_devname) return;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 12, 0))
+    rbtree_postorder_for_each_entry_safe(m, n, &ns->mounts, mnt_node) {
+#else
+    list_for_each_entry(m, &ns->list, mnt_list) {
+#endif
+        if (m->mnt_devname && (
+            strcmp(m->mnt_devname, hymo_current_mirror_path) == 0 ||
+            strcmp(m->mnt_devname, hymo_current_mirror_name) == 0
+        )) {
+            const char *old_name = m->mnt_devname;
+            m->mnt_devname = kstrdup(system_devname, GFP_KERNEL);
+            if (m->mnt_devname) {
+                kfree_const(old_name);
+            } else {
+                m->mnt_devname = old_name;
+            }
+        }
+    }
+    kfree(system_devname);
+}
+
+int hymo_dispatch_cmd(unsigned int cmd, void __user *arg) {
+    struct hymo_syscall_arg req;
+    struct hymo_entry *entry;
+    struct hymo_hide_entry *hide_entry;
+    struct hymo_inject_entry *inject_entry;
+    char *src = NULL, *target = NULL;
+    u32 hash;
+    bool found = false;
+    int ret = 0;
+
+    if (cmd == HYMO_CMD_CLEAR_ALL) {
+        spin_lock(&hymo_cfg_lock);
+        spin_lock(&hymo_rules_lock);
+        spin_lock(&hymo_hide_lock);
+        spin_lock(&hymo_allow_uids_lock);
+        spin_lock(&hymo_xattr_sbs_lock);
+        spin_lock(&hymo_merge_lock);
+        spin_lock(&hymo_inject_lock);
+        hymo_cleanup_locked();
+        strscpy(hymo_mirror_path_buf, HYMO_DEFAULT_MIRROR_PATH, PATH_MAX);
+        strscpy(hymo_mirror_name_buf, HYMO_DEFAULT_MIRROR_NAME, NAME_MAX);
+        hymo_current_mirror_path = hymo_mirror_path_buf;
+        hymo_current_mirror_name = hymo_mirror_name_buf;
+        hymofs_enabled = false;
+        spin_unlock(&hymo_inject_lock);
+        spin_unlock(&hymo_merge_lock);
+        spin_unlock(&hymo_xattr_sbs_lock);
+        spin_unlock(&hymo_allow_uids_lock);
+        spin_unlock(&hymo_hide_lock);
+        spin_unlock(&hymo_rules_lock);
+        spin_unlock(&hymo_cfg_lock);
+        rcu_barrier();
+        return 0;
+    }
+    
+    if (cmd == HYMO_CMD_GET_VERSION) {
+        return HYMO_PROTOCOL_VERSION;
+    }
+
+    if (cmd == HYMO_CMD_SET_DEBUG) {
+        int val;
+        if (copy_from_user(&val, arg, sizeof(val))) return -EFAULT;
+        hymo_debug_enabled = !!val;
+        hymo_log("debug mode %s\n", hymo_debug_enabled ? "enabled" : "disabled");
+        return 0;
+    }
+
+    if (cmd == HYMO_CMD_REORDER_MNT_ID) {
+        hymofs_spoof_mounts();
+        hymofs_reorder_mnt_id();
+        return 0;
+    }
+
+    if (cmd == HYMO_CMD_SET_STEALTH) {
+        int val;
+        if (copy_from_user(&val, arg, sizeof(val))) return -EFAULT;
+        hymo_stealth_enabled = !!val;
+        hymo_log("stealth mode %s\n", hymo_stealth_enabled ? "enabled" : "disabled");
+        if (hymo_stealth_enabled) {
+            hymofs_spoof_mounts();
+            hymofs_reorder_mnt_id();
+        }
+        return 0;
+    }
+
+    if (cmd == HYMO_CMD_SET_ENABLED) {
+        int val;
+        if (copy_from_user(&val, arg, sizeof(val))) return -EFAULT;
+        spin_lock(&hymo_cfg_lock);
+        hymofs_enabled = !!val;
+        spin_unlock(&hymo_cfg_lock);
+        hymo_log("HymoFS %s\n", hymofs_enabled ? "enabled" : "disabled");
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+        if (hymofs_enabled) {
+            hymo_reload_ksu_allowlist();
+        }
+#endif
+        return 0;
+    }
+
+    if (cmd == HYMO_CMD_GET_FD) {
+        /* Return anonymous fd - the ONLY way to access HymoFS */
+        int fd;
+        pid_t pid;
+        if (!uid_eq(current_uid(), GLOBAL_ROOT_UID)) {
+            return -EPERM;
+        }
+        fd = anon_inode_getfd("hymo", &hymo_anon_fops, NULL, O_RDWR | O_CLOEXEC);
+        if (fd < 0) {
+            return fd;
+        }
+        
+        /* Automatically register this process as the daemon */
+        pid = task_tgid_vnr(current);
+        spin_lock(&hymo_daemon_lock);
+        hymo_daemon_pid = pid;
+        spin_unlock(&hymo_daemon_lock);
+        hymo_log("Daemon PID auto-registered: %d\n", pid);
+        
+        return fd;  /* Return fd directly */
+    }
+
+    /* LIST_RULES uses a different struct, handle it separately */
+    if (cmd == HYMO_CMD_LIST_RULES) {
+        struct hymo_syscall_list_arg list_arg;
+        char *kbuf;
+        size_t buf_size;
+        size_t written = 0;
+        int bkt;
+        struct hymo_xattr_sb_entry *sb_entry;
+        struct hymo_merge_entry *merge_entry;
+
+        if (copy_from_user(&list_arg, (void __user *)arg, sizeof(list_arg))) {
+            return -EFAULT;
+        }
+
+        buf_size = list_arg.size;
+        if (buf_size > 16 * 1024) buf_size = 16 * 1024;
+        
+        kbuf = kzalloc(buf_size, GFP_KERNEL);
+        if (!kbuf) {
+            return -ENOMEM;
+        }
+
+        rcu_read_lock();
+        
+        written += scnprintf(kbuf + written, buf_size - written, "HymoFS Protocol: %d\n", HYMO_PROTOCOL_VERSION);
+        written += scnprintf(kbuf + written, buf_size - written, "HymoFS Enabled: %d\n", hymofs_enabled ? 1 : 0);
+
+        hash_for_each_rcu(hymo_paths, bkt, entry, node) {
+            if (written >= buf_size) break;
+            written += scnprintf(kbuf + written, buf_size - written, "add %s %s %d\n", entry->src, entry->target, entry->type);
+        }
+        hash_for_each_rcu(hymo_hide_paths, bkt, hide_entry, node) {
+            if (written >= buf_size) break;
+            written += scnprintf(kbuf + written, buf_size - written, "hide %s\n", hide_entry->path);
+        }
+        hash_for_each_rcu(hymo_inject_dirs, bkt, inject_entry, node) {
+            if (written >= buf_size) break;
+            written += scnprintf(kbuf + written, buf_size - written, "inject %s\n", inject_entry->dir);
+        }
+        hash_for_each_rcu(hymo_merge_dirs, bkt, merge_entry, node) {
+            if (written >= buf_size) break;
+            written += scnprintf(kbuf + written, buf_size - written, "merge %s %s\n", merge_entry->src, merge_entry->target);
+        }
+        hash_for_each_rcu(hymo_xattr_sbs, bkt, sb_entry, node) {
+            if (written >= buf_size) break;
+            written += scnprintf(kbuf + written, buf_size - written, "hide_xattr_sb %p\n", sb_entry->sb);
+        }
+        rcu_read_unlock();
+
+        if (copy_to_user(list_arg.buf, kbuf, written)) {
+            kfree(kbuf);
+            return -EFAULT;
+        }
+        list_arg.size = written;
+        if (copy_to_user((void __user *)arg, &list_arg, sizeof(list_arg))) {
+            kfree(kbuf);
+            return -EFAULT;
+        }
+        
+        kfree(kbuf);
+        return 0;
+    }
+
+    if (cmd == HYMO_CMD_SET_UNAME) {
+#ifdef CONFIG_HYMOFS_UNAME_SPOOF
+        struct hymo_uname_info u_info;
+
+        if (copy_from_user(&u_info, arg, sizeof(u_info)))
+            return -EFAULT;
+
+        spin_lock(&hymo_uname_lock);
+        memcpy(&hymo_uname_info, &u_info, sizeof(u_info));
+        spin_unlock(&hymo_uname_lock);
+        return 0;
+#else
+        return -EOPNOTSUPP;
+#endif
+    }
+
+    if (copy_from_user(&req, arg, sizeof(req))) return -EFAULT;
+
+    if (cmd == HYMO_CMD_SET_MIRROR_PATH) {
+        char *new_path = NULL;
+        char *new_name = NULL;
+        char *slash;
+        size_t len;
+
+        if (req.src) {
+            new_path = strndup_user(req.src, PATH_MAX);
+            if (IS_ERR(new_path)) return PTR_ERR(new_path);
+        } else {
+            return -EINVAL;
+        }
+
+        hymo_log("setting mirror path to: %s\n", new_path);
+
+        /* Strip trailing slash if present */
+        len = strlen(new_path);
+        if (len > 1 && new_path[len - 1] == '/') {
+            new_path[len - 1] = '\0';
+        }
+
+        slash = strrchr(new_path, '/');
+        if (slash) {
+            new_name = kstrdup(slash + 1, GFP_KERNEL);
+        } else {
+            new_name = kstrdup(new_path, GFP_KERNEL);
+        }
+
+        if (!new_name) {
+            kfree(new_path);
+            return -ENOMEM;
+        }
+
+        spin_lock(&hymo_cfg_lock);
+        strscpy(hymo_mirror_path_buf, new_path, PATH_MAX);
+        strscpy(hymo_mirror_name_buf, new_name, NAME_MAX);
+        hymo_current_mirror_path = hymo_mirror_path_buf;
+        hymo_current_mirror_name = hymo_mirror_name_buf;
+        spin_unlock(&hymo_cfg_lock);
+
+        kfree(new_path);
+        kfree(new_name);
+        return 0;
+    }
+
+    if (req.src) {
+        src = strndup_user(req.src, PAGE_SIZE);
+        if (IS_ERR(src)) return PTR_ERR(src);
+    }
+    if (req.target) {
+        target = strndup_user(req.target, PAGE_SIZE);
+        if (IS_ERR(target)) {
+            kfree(src);
+            return PTR_ERR(target);
+        }
+    }
+
+    switch (cmd) {
+        case HYMO_CMD_ADD_MERGE_RULE: {
+            struct hymo_merge_entry *merge_entry;
+            if (!src || !target) { ret = -EINVAL; break; }
+            
+            hymo_log("add merge rule: src=%s, target=%s\n", src, target);
+            
+            hash = full_name_hash(NULL, src, strlen(src));
+            spin_lock(&hymo_merge_lock);
+            spin_lock(&hymo_inject_lock);
+            
+            hlist_for_each_entry(merge_entry, &hymo_merge_dirs[hash_min(hash, HYMO_HASH_BITS)], node) {
+                if (strcmp(merge_entry->src, src) == 0 && strcmp(merge_entry->target, target) == 0) {
+                    found = true;
+                    break;
+                }
+            }
+            
+            if (!found) {
+                merge_entry = kmalloc(sizeof(*merge_entry), GFP_ATOMIC);
+                if (merge_entry) {
+                    merge_entry->src = src;
+                    merge_entry->target = target;
+                    hlist_add_head_rcu(&merge_entry->node, &hymo_merge_dirs[hash_min(hash, HYMO_HASH_BITS)]);
+                    
+                    {
+                        struct hymo_inject_entry *inj;
+                        bool inj_found = false;
+                        hlist_for_each_entry(inj, &hymo_inject_dirs[hash_min(hash, HYMO_HASH_BITS)], node) {
+                            if (strcmp(inj->dir, src) == 0) {
+                                inj_found = true;
+                                break;
+                            }
+                        }
+                        if (!inj_found) {
+                            inj = kmalloc(sizeof(*inj), GFP_ATOMIC);
+                            if (inj) {
+                                inj->dir = kstrdup(src, GFP_ATOMIC);
+                                if (inj->dir) hlist_add_head_rcu(&inj->node, &hymo_inject_dirs[hash_min(hash, HYMO_HASH_BITS)]);
+                                else kfree(inj);
+                            }
+                        }
+                    }
+                    
+                    src = NULL;
+                    target = NULL;
+                    hymo_merge_trie_build_locked();
+                } else {
+                    ret = -ENOMEM;
+                }
+            } else {
+                ret = -EEXIST;
+            }
+            spin_unlock(&hymo_inject_lock);
+            spin_unlock(&hymo_merge_lock);
+            if (!found && merge_entry)
+                hymofs_add_inject_rule(kstrdup(merge_entry->src, GFP_ATOMIC));
+            spin_lock(&hymo_cfg_lock);
+            hymofs_enabled = true;
+            spin_unlock(&hymo_cfg_lock);
+            break;
+        }
+
+        case HYMO_CMD_ADD_RULE: {
+            char *parent_dir = NULL;
+            char *resolved_src = NULL;
+            struct path path;
+            struct inode *src_inode = NULL;
+            struct inode *parent_inode = NULL;
+            char *tmp_buf = kmalloc(PATH_MAX, GFP_KERNEL);
+            
+            if (!src || !target) { 
+                kfree(tmp_buf);
+                ret = -EINVAL; 
+                break; 
+            }
+            if (!tmp_buf) { ret = -ENOMEM; break; }
+
+            hymo_log("add rule: src=%s, target=%s, type=%d\n", src, target, req.type);
+            
+            // 1. Try to resolve full path (if file exists)
+            if (kern_path(src, LOOKUP_FOLLOW, &path) == 0) {
+                char *res = d_path(&path, tmp_buf, PATH_MAX);
+                if (!IS_ERR(res)) {
+                    resolved_src = kstrdup(res, GFP_KERNEL);
+                    
+                    /* Always extract parent directory for injection, even if file exists */
+                    {
+                        char *last_slash = strrchr(res, '/');
+                        if (last_slash) {
+                            if (last_slash == res) {
+                                parent_dir = kstrdup("/", GFP_KERNEL);
+                            } else {
+                                size_t len = last_slash - res;
+                                parent_dir = kmalloc(len + 1, GFP_KERNEL);
+                                if (parent_dir) {
+                                    memcpy(parent_dir, res, len);
+                                    parent_dir[len] = '\0';
+                                }
+                            }
+                        }
+                    }
+                }
+                /* Get inode reference for marking (hide source in filldir) */
+                if (d_inode(path.dentry)) {
+                    src_inode = d_inode(path.dentry);
+                    ihold(src_inode);
+                }
+                if (path.dentry->d_parent && d_inode(path.dentry->d_parent)) {
+                    parent_inode = d_inode(path.dentry->d_parent);
+                    ihold(parent_inode);
+                }
+                path_put(&path);
+            } else {
+                char *last_slash = strrchr(src, '/');
+                if (last_slash && last_slash != src) {
+                    size_t len = last_slash - src;
+                    char *p_str = kmalloc(len + 1, GFP_KERNEL);
+                    if (p_str) {
+                        memcpy(p_str, src, len);
+                        p_str[len] = '\0';
+                        
+                        if (kern_path(p_str, LOOKUP_FOLLOW, &path) == 0) {
+                            char *res = d_path(&path, tmp_buf, PATH_MAX);
+                            if (!IS_ERR(res)) {
+                                size_t res_len = strlen(res);
+                                size_t name_len = strlen(last_slash);
+                                resolved_src = kmalloc(res_len + name_len + 1, GFP_KERNEL);
+                                if (resolved_src) {
+                                    strcpy(resolved_src, res);
+                                    strcat(resolved_src, last_slash);
+                                }
+                                parent_dir = kstrdup(res, GFP_KERNEL);
+                            }
+                            path_put(&path);
+                        }
+                        kfree(p_str);
+                    }
+                }
+            }
+            
+            kfree(tmp_buf);
+
+            if (resolved_src) {
+                kfree(src);
+                src = resolved_src;
+            }
+
+            hash = full_name_hash(NULL, src, strlen(src));
+            spin_lock(&hymo_rules_lock);
+
+            {
+                hlist_for_each_entry(entry, &hymo_paths[hash_min(hash, HYMO_HASH_BITS)], node) {
+                    if (entry->src_hash == hash && strcmp(entry->src, src) == 0) {
+                        /* Update existing entry - need RCU-safe update */
+                        char *old_target = entry->target;
+                        char *new_target = kstrdup(target, GFP_ATOMIC);
+                        if (new_target) {
+                            hlist_del_rcu(&entry->target_node);
+                            rcu_assign_pointer(entry->target, new_target);
+                            entry->type = req.type;
+                            hlist_add_head_rcu(&entry->target_node, &hymo_targets[hash_min(full_name_hash(NULL, new_target, strlen(new_target)), HYMO_HASH_BITS)]);
+                            /* Free old target after grace period - use kfree_rcu if available, else synchronize */
+                            kfree(old_target);
+                        }
+                        found = true;
+                        break;
+                    }
+                }
+                if (!found) {
+                    entry = kmalloc(sizeof(*entry), GFP_ATOMIC);
+                    if (entry) {
+                        entry->src = kstrdup(src, GFP_ATOMIC);
+                        entry->target = kstrdup(target, GFP_ATOMIC);
+                        entry->type = req.type;
+                        entry->src_hash = hash;
+                        if (entry->src && entry->target) {
+                            unsigned long h1, h2;
+                            hlist_add_head_rcu(&entry->node, &hymo_paths[hash_min(hash, HYMO_HASH_BITS)]);
+                            hlist_add_head_rcu(&entry->target_node, &hymo_targets[hash_min(full_name_hash(NULL, entry->target, strlen(entry->target)), HYMO_HASH_BITS)]);
+                            
+                            h1 = jhash(src, strlen(src), 0) & (HYMO_BLOOM_SIZE - 1);
+                            h2 = jhash(src, strlen(src), 1) & (HYMO_BLOOM_SIZE - 1);
+                            set_bit(h1, hymo_path_bloom);
+                            set_bit(h2, hymo_path_bloom);
+                            atomic_inc(&hymo_rule_count);
+                        } else {
+                            kfree(entry->src);
+                            kfree(entry->target);
+                            kfree(entry);
+                        }
+                    }
+                }
+            }
+
+            spin_unlock(&hymo_rules_lock);
+            if (parent_dir) {
+                hymofs_add_inject_rule(parent_dir);
+            }
+
+            if (src_inode) {
+                hymofs_mark_inode_hidden(src_inode);
+                iput(src_inode);
+            }
+
+            if (parent_inode) {
+                if (parent_inode->i_mapping) {
+                    set_bit(AS_FLAGS_HYMO_DIR_HAS_HIDDEN, &parent_inode->i_mapping->flags);
+                }
+                iput(parent_inode);
+            }
+
+            spin_lock(&hymo_cfg_lock);
+            hymofs_enabled = true;
+            spin_unlock(&hymo_cfg_lock);
+            break;
+        }
+
+        case HYMO_CMD_HIDE_RULE: {
+            char *resolved_src = NULL;
+            struct path path;
+            struct inode *target_inode = NULL;
+            struct inode *parent_inode = NULL;
+            char *tmp_buf = kmalloc(PATH_MAX, GFP_KERNEL);
+
+            if (!src) { 
+                kfree(tmp_buf);
+                ret = -EINVAL; 
+                break; 
+            }
+            if (!tmp_buf) { ret = -ENOMEM; break; }
+
+            hymo_log("hide rule: src=%s\n", src);
+
+            if (kern_path(src, LOOKUP_FOLLOW, &path) == 0) {
+                char *res = d_path(&path, tmp_buf, PATH_MAX);
+                if (!IS_ERR(res)) {
+                    resolved_src = kstrdup(res, GFP_KERNEL);
+                }
+                /* Get inode reference for marking */
+                if (d_inode(path.dentry)) {
+                    target_inode = d_inode(path.dentry);
+                    ihold(target_inode);  /* Hold reference */
+                }
+                /* Also get parent directory inode */
+                if (path.dentry->d_parent && d_inode(path.dentry->d_parent)) {
+                    parent_inode = d_inode(path.dentry->d_parent);
+                    ihold(parent_inode);
+                }
+                path_put(&path);
+            }
+            kfree(tmp_buf);
+
+            if (resolved_src) {
+                kfree(src);
+                src = resolved_src;
+            }
+
+            if (target_inode) {
+                hymofs_mark_inode_hidden(target_inode);
+                iput(target_inode);
+            }
+
+            if (parent_inode) {
+                if (parent_inode->i_mapping) {
+                    set_bit(AS_FLAGS_HYMO_DIR_HAS_HIDDEN, &parent_inode->i_mapping->flags);
+                }
+                iput(parent_inode);
+            }
+
+            hash = full_name_hash(NULL, src, strlen(src));
+            spin_lock(&hymo_hide_lock);
+            hlist_for_each_entry(hide_entry, &hymo_hide_paths[hash_min(hash, HYMO_HASH_BITS)], node) {
+                if (hide_entry->path_hash == hash && strcmp(hide_entry->path, src) == 0) {
+                    found = true;
+                    break;
+                }
+            }
+            if (!found) {
+                hide_entry = kmalloc(sizeof(*hide_entry), GFP_ATOMIC);
+                if (hide_entry) {
+                    hide_entry->path = kstrdup(src, GFP_ATOMIC);
+                    hide_entry->path_hash = hash;
+                    if (hide_entry->path) {
+                        unsigned long h1 = jhash(src, strlen(src), 0) & (HYMO_BLOOM_SIZE - 1);
+                        unsigned long h2 = jhash(src, strlen(src), 1) & (HYMO_BLOOM_SIZE - 1);
+                        set_bit(h1, hymo_hide_bloom);
+                        set_bit(h2, hymo_hide_bloom);
+                        atomic_inc(&hymo_hide_count);
+                        hlist_add_head_rcu(&hide_entry->node, &hymo_hide_paths[hash_min(hash, HYMO_HASH_BITS)]);
+                    } else {
+                        kfree(hide_entry);
+                    }
+                }
+            }
+            spin_unlock(&hymo_hide_lock);
+            spin_lock(&hymo_cfg_lock);
+            hymofs_enabled = true;
+            spin_unlock(&hymo_cfg_lock);
+            break;
+        }
+
+        case HYMO_CMD_HIDE_OVERLAY_XATTRS: {
+            struct path path;
+            struct hymo_xattr_sb_entry *sb_entry;
+            bool found = false;
+            
+            if (!src) { ret = -EINVAL; break; }
+            
+            if (kern_path(src, LOOKUP_FOLLOW, &path) == 0) {
+                struct super_block *sb = path.dentry->d_sb;
+                
+                spin_lock(&hymo_xattr_sbs_lock);
+                hlist_for_each_entry(sb_entry, &hymo_xattr_sbs[hash_min((unsigned long)sb, HYMO_HASH_BITS)], node) {
+                    if (sb_entry->sb == sb) {
+                        found = true;
+                        break;
+                    }
+                }
+                if (!found) {
+                    sb_entry = kmalloc(sizeof(*sb_entry), GFP_ATOMIC);
+                    if (sb_entry) {
+                        sb_entry->sb = sb;
+                        hlist_add_head_rcu(&sb_entry->node, &hymo_xattr_sbs[hash_min((unsigned long)sb, HYMO_HASH_BITS)]);
+                        hymo_log("hide xattrs for sb %p (path: %s)\n", sb, src);
+                    }
+                }
+                spin_unlock(&hymo_xattr_sbs_lock);
+                spin_lock(&hymo_cfg_lock);
+                hymofs_enabled = true;
+                spin_unlock(&hymo_cfg_lock);
+                path_put(&path);
+            } else {
+                ret = -ENOENT;
+            }
+            break;
+        }
+
+        case HYMO_CMD_DEL_RULE:
+            if (!src) { ret = -EINVAL; break; }
+            hymo_log("del rule: src=%s\n", src);
+            hash = full_name_hash(NULL, src, strlen(src));
+            spin_lock(&hymo_rules_lock);
+            spin_lock(&hymo_hide_lock);
+            spin_lock(&hymo_inject_lock);
+            
+            hlist_for_each_entry(entry, &hymo_paths[hash_min(hash, HYMO_HASH_BITS)], node) {
+                if (entry->src_hash == hash && strcmp(entry->src, src) == 0) {
+                    hlist_del_rcu(&entry->node);
+                    hlist_del_rcu(&entry->target_node);
+                    atomic_dec(&hymo_rule_count);
+                    call_rcu(&entry->rcu, hymo_entry_free_rcu);
+                    goto out_delete;
+                }
+            }
+            hlist_for_each_entry(hide_entry, &hymo_hide_paths[hash_min(hash, HYMO_HASH_BITS)], node) {
+                if (hide_entry->path_hash == hash && strcmp(hide_entry->path, src) == 0) {
+                    hlist_del_rcu(&hide_entry->node);
+                    atomic_dec(&hymo_hide_count);
+                    call_rcu(&hide_entry->rcu, hymo_hide_entry_free_rcu);
+                    goto out_delete;
+                }
+            }
+            hlist_for_each_entry(inject_entry, &hymo_inject_dirs[hash_min(hash, HYMO_HASH_BITS)], node) {
+                if (strcmp(inject_entry->dir, src) == 0) {
+                    hlist_del_rcu(&inject_entry->node);
+                    atomic_dec(&hymo_rule_count);
+                    call_rcu(&inject_entry->rcu, hymo_inject_entry_free_rcu);
+                    goto out_delete;
+                }
+            }
+    out_delete:
+            spin_unlock(&hymo_inject_lock);
+            spin_unlock(&hymo_hide_lock);
+            spin_unlock(&hymo_rules_lock);
+            spin_lock(&hymo_cfg_lock);
+            hymofs_enabled = true;
+            spin_unlock(&hymo_cfg_lock);
+            break;
+
+        case HYMO_CMD_REORDER_MNT_ID:
+            hymo_log("reordering mount IDs\n");
+            hymofs_reorder_mnt_id();
+            break;
+
+        default:
+            ret = -EINVAL;
+            break;
+    }
+
+    kfree(src);
+    kfree(target);
+    return ret;
+}
+
+static long hymo_anon_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+    /* All ioctl commands directly dispatch to hymo_dispatch_cmd */
+    if (cmd == HYMO_IOC_GET_VERSION) {
+        int version = HYMO_PROTOCOL_VERSION;
+        if (copy_to_user((void __user *)arg, &version, sizeof(version)))
+            return -EFAULT;
+        return 0;
+    }
+
+    if (cmd == HYMO_IOC_SET_ENABLED) {
+        int enabled;
+        if (copy_from_user(&enabled, (void __user *)arg, sizeof(enabled)))
+            return -EFAULT;
+        spin_lock(&hymo_cfg_lock);
+        hymofs_enabled = enabled ? true : false;
+        spin_unlock(&hymo_cfg_lock);
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+        if (hymofs_enabled) {
+            hymo_reload_ksu_allowlist();
+        }
+#endif
+        return 0;
+    }
+
+    /* Map ioctl to internal command and dispatch */
+    switch (cmd) {
+    case HYMO_IOC_ADD_RULE:
+        return hymo_dispatch_cmd(HYMO_CMD_ADD_RULE, (void __user *)arg);
+    case HYMO_IOC_DEL_RULE:
+        return hymo_dispatch_cmd(HYMO_CMD_DEL_RULE, (void __user *)arg);
+    case HYMO_IOC_HIDE_RULE:
+        return hymo_dispatch_cmd(HYMO_CMD_HIDE_RULE, (void __user *)arg);
+    case HYMO_IOC_CLEAR_ALL:
+        return hymo_dispatch_cmd(HYMO_CMD_CLEAR_ALL, (void __user *)arg);
+    case HYMO_IOC_LIST_RULES:
+        return hymo_dispatch_cmd(HYMO_CMD_LIST_RULES, (void __user *)arg);
+    case HYMO_IOC_SET_DEBUG:
+        return hymo_dispatch_cmd(HYMO_CMD_SET_DEBUG, (void __user *)arg);
+    case HYMO_IOC_REORDER_MNT_ID:
+        return hymo_dispatch_cmd(HYMO_CMD_REORDER_MNT_ID, (void __user *)arg);
+    case HYMO_IOC_SET_STEALTH:
+        return hymo_dispatch_cmd(HYMO_CMD_SET_STEALTH, (void __user *)arg);
+    case HYMO_IOC_HIDE_OVERLAY_XATTRS:
+        return hymo_dispatch_cmd(HYMO_CMD_HIDE_OVERLAY_XATTRS, (void __user *)arg);
+    case HYMO_IOC_ADD_MERGE_RULE:
+        return hymo_dispatch_cmd(HYMO_CMD_ADD_MERGE_RULE, (void __user *)arg);
+    case HYMO_IOC_SET_MIRROR_PATH:
+        return hymo_dispatch_cmd(HYMO_CMD_SET_MIRROR_PATH, (void __user *)arg);
+    case HYMO_IOC_SET_UNAME:
+        return hymo_dispatch_cmd(HYMO_CMD_SET_UNAME, (void __user *)arg);
+    default:
+        return -EINVAL;
+    }
+}
+
+static int __init hymofs_init(void)
+{
+    hash_init(hymo_paths);
+    hash_init(hymo_targets);
+    hash_init(hymo_hide_paths);
+    /* hymo_allow_uids_xa is statically defined, starts empty */
+    hash_init(hymo_inject_dirs);
+    hash_init(hymo_xattr_sbs);
+    
+    if (hymo_dispatch_cmd_hook) {
+        pr_err("HymoFS: hook already set?\n");
+    } else {
+        hymo_dispatch_cmd_hook = hymo_dispatch_cmd;
+    }
+    
+    pr_info("HymoFS: initialized (Anonymous FD Mode Only)\n");
+    return 0;
+}
+fs_initcall(hymofs_init);
+
+#ifdef CONFIG_HYMOFS_FORWARD_REDIRECT
+char *__hymofs_resolve_target(const char *pathname)
+{
+    struct hymo_entry *entry;
+    struct hymo_merge_entry *merge_entry;
+    u32 hash;
+    char *target = NULL;
+    size_t path_len;
+    struct list_head candidates;
+    struct hymo_merge_target_node *cand, *tmp;
+    pid_t current_pid;
+
+    if (unlikely(!hymofs_enabled)) return NULL;
+    if (unlikely(!pathname)) return NULL;
+    
+    /* Allow daemon process to bypass path resolution */
+    current_pid = task_tgid_vnr(current);
+    if (hymo_daemon_pid > 0 && current_pid == hymo_daemon_pid) {
+        return NULL;
+    }
+    
+    INIT_LIST_HEAD(&candidates);
+    path_len = strlen(pathname);
+    hash = full_name_hash(NULL, pathname, path_len);
+
+    rcu_read_lock();
+    /* Bloom filter fast-path: skip expensive path lookup when path is definitely not in rules (KPM backport) */
+    if (atomic_read(&hymo_rule_count) != 0) {
+        unsigned long bh1 = jhash(pathname, (u32)path_len, 0) & (HYMO_BLOOM_SIZE - 1);
+        unsigned long bh2 = jhash(pathname, (u32)path_len, 1) & (HYMO_BLOOM_SIZE - 1);
+        if (test_bit(bh1, hymo_path_bloom) && test_bit(bh2, hymo_path_bloom)) {
+            hlist_for_each_entry_rcu(entry, &hymo_paths[hash_min(hash, HYMO_HASH_BITS)], node) {
+                if (unlikely(entry->src_hash == hash && strcmp(entry->src, pathname) == 0)) {
+                    target = kstrdup(entry->target, GFP_ATOMIC);
+                    rcu_read_unlock();
+                    return target;
+                }
+            }
+        }
+    }
+    
+    /* Longest-prefix merge match via trie (one path walk instead of O(depth) hash lookups) */
+    merge_entry = hymo_merge_trie_lookup_longest(pathname);
+    if (merge_entry) {
+        size_t src_len = strlen(merge_entry->src);
+        const char *suffix = pathname + src_len;
+
+        if (suffix[0] != '\0' && strcmp(suffix, "/.") != 0 && strcmp(suffix, "/..") != 0) {
+            size_t target_len = strlen(merge_entry->target);
+            size_t suffix_len = path_len - src_len;
+
+            cand = kmalloc(sizeof(*cand), GFP_ATOMIC);
+            if (cand) {
+                cand->target = kmalloc(target_len + suffix_len + 1, GFP_ATOMIC);
+                if (cand->target) {
+                    strcpy(cand->target, merge_entry->target);
+                    strcat(cand->target, suffix);
+                    list_add_tail(&cand->list, &candidates);
+                } else {
+                    kfree(cand);
+                }
+            }
+        }
+    }
+
+    rcu_read_unlock();
+    
+    list_for_each_entry_safe(cand, tmp, &candidates, list) {
+        if (!target) {
+            struct path p;
+            if (kern_path(cand->target, LOOKUP_FOLLOW, &p) == 0) {
+                path_put(&p);
+                target = cand->target; // Take ownership
+                cand->target = NULL;   // Prevent double free
+            }
+        }
+        
+        if (cand->target) kfree(cand->target);
+        kfree(cand);
+    }
+
+    return target;
+}
+EXPORT_SYMBOL(__hymofs_resolve_target);
+
+#endif /* CONFIG_HYMOFS_FORWARD_REDIRECT */
+
+#ifdef CONFIG_HYMOFS_REVERSE_LOOKUP
+/* Returns length of written string, or -1 if not found/error. Writes to buf. */
+int __hymofs_reverse_lookup(const char *pathname, char *buf, size_t buflen)
+{
+    struct hymo_entry *entry;
+    struct hymo_merge_entry *merge_entry;
+    u32 hash;
+    int bkt;
+    int ret = -1;
+
+    if (unlikely(!hymofs_enabled)) return -1;
+    if (unlikely(!pathname || !buf)) return -1;
+
+    hash = full_name_hash(NULL, pathname, strlen(pathname));
+
+    rcu_read_lock();
+    
+    /* Check 1-to-1 mappings */
+    hlist_for_each_entry_rcu(entry, &hymo_targets[hash_min(hash, HYMO_HASH_BITS)], target_node) {
+        if (strcmp(entry->target, pathname) == 0) {
+            if (strscpy(buf, entry->src, buflen) < 0) ret = -ENAMETOOLONG;
+            else ret = strlen(buf);
+            goto out;
+        }
+    }
+
+    hash_for_each_rcu(hymo_merge_dirs, bkt, merge_entry, node) {
+        size_t target_len = strlen(merge_entry->target);
+        if (strncmp(pathname, merge_entry->target, target_len) == 0) {
+            if (pathname[target_len] == '/' || pathname[target_len] == '\0') {
+                size_t src_len = strlen(merge_entry->src);
+                size_t suffix_len = strlen(pathname) - target_len;
+                
+                if (src_len + suffix_len + 1 > buflen) {
+                    ret = -ENAMETOOLONG;
+                } else {
+                    memcpy(buf, merge_entry->src, src_len);
+                    memcpy(buf + src_len, pathname + target_len, suffix_len);
+                    buf[src_len + suffix_len] = '\0';
+                    ret = src_len + suffix_len;
+        }
+                goto out;
+    }
+        }
+    }
+
+out:
+    rcu_read_unlock();
+    return ret;
+}
+EXPORT_SYMBOL(__hymofs_reverse_lookup);
+#endif /* CONFIG_HYMOFS_REVERSE_LOOKUP */
+
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+static inline bool hymo_is_privileged_process(void)
+{
+    pid_t current_pid = task_tgid_vnr(current);
+    if (unlikely(uid_eq(current_uid(), GLOBAL_ROOT_UID)))
+        return true;
+    if (hymo_daemon_pid > 0 && current_pid == hymo_daemon_pid)
+        return true;
+    return false;
+}
+
+static bool hymo_should_umount_profile(const struct hymo_app_profile *profile)
+{
+    if (profile->allow_su)
+        return false;
+    if (profile->nrp_config.use_default)
+        return true;
+    return profile->nrp_config.profile.umount_modules;
+}
+
+static void hymo_clear_allowlist_locked(void)
+{
+    xa_destroy(&hymo_allow_uids_xa);
+}
+
+static void hymo_add_allow_uid(uid_t uid)
+{
+    spin_lock(&hymo_allow_uids_lock);
+    xa_store(&hymo_allow_uids_xa, uid, HYMO_UID_ALLOW_MARKER, GFP_KERNEL);
+    spin_unlock(&hymo_allow_uids_lock);
+}
+
+static bool hymo_reload_ksu_allowlist(void)
+{
+    struct file *fp;
+    loff_t off = 0;
+    u32 magic = 0;
+    u32 version = 0;
+    ssize_t ret;
+    struct hymo_app_profile profile;
+    int allow_count = 0;
+
+    if (!mutex_trylock(&hymo_allowlist_lock))
+        return false;
+
+    fp = filp_open(HYMO_KSU_ALLOWLIST_PATH, O_RDONLY, 0);
+    if (IS_ERR(fp)) {
+        spin_lock(&hymo_allow_uids_lock);
+        hymo_clear_allowlist_locked();
+        hymo_allowlist_loaded = false;
+        spin_unlock(&hymo_allow_uids_lock);
+        mutex_unlock(&hymo_allowlist_lock);
+        return false;
+    }
+
+    ret = kernel_read(fp, &magic, sizeof(magic), &off);
+    if (ret != sizeof(magic) || magic != HYMO_KSU_ALLOWLIST_MAGIC)
+        goto out_bad;
+
+    ret = kernel_read(fp, &version, sizeof(version), &off);
+    if (ret != sizeof(version))
+        goto out_bad;
+    if (version != HYMO_KSU_ALLOWLIST_VERSION)
+        hymo_log("allowlist version %u\n", version);
+
+    spin_lock(&hymo_allow_uids_lock);
+    hymo_clear_allowlist_locked();
+    hymo_allowlist_loaded = true;
+    spin_unlock(&hymo_allow_uids_lock);
+
+    while (kernel_read(fp, &profile, sizeof(profile), &off) == sizeof(profile)) {
+        if (!hymo_should_umount_profile(&profile)) {
+            if (profile.current_uid > 0) {
+                hymo_add_allow_uid((uid_t)profile.current_uid);
+                if (++allow_count >= HYMO_ALLOWLIST_UID_MAX) {
+                    hymo_log("allowlist truncated at %d\n", allow_count);
+                    break;
+                }
+            }
+        }
+    }
+
+    filp_close(fp, NULL);
+    mutex_unlock(&hymo_allowlist_lock);
+    return true;
+
+out_bad:
+    filp_close(fp, NULL);
+    spin_lock(&hymo_allow_uids_lock);
+    hymo_clear_allowlist_locked();
+    hymo_allowlist_loaded = false;
+    spin_unlock(&hymo_allow_uids_lock);
+    mutex_unlock(&hymo_allowlist_lock);
+    return false;
+}
+
+static bool hymo_uid_in_allowlist(uid_t uid)
+{
+    void *p;
+
+    rcu_read_lock();
+    p = xa_load(&hymo_allow_uids_xa, uid);
+    rcu_read_unlock();
+    return p != NULL;
+}
+
+static bool hymo_should_apply_hide_rules(void)
+{
+    if (!hymo_allowlist_loaded)
+        return true;
+
+    /* Empty allowlist means hide for all non-privileged processes */
+    if (xa_empty(&hymo_allow_uids_xa))
+        return true;
+
+    /* Allowlist mode: listed UIDs bypass hide rules */
+    return !hymo_uid_in_allowlist(__kuid_val(current_uid()));
+}
+
+bool __hymofs_should_hide(const char *pathname, size_t len)
+{
+    struct hymo_hide_entry *hide_entry;
+    u32 hash;
+
+    if (unlikely(!hymofs_enabled)) return false;
+    if (unlikely(!pathname)) return false;
+
+    if (unlikely(hymo_is_privileged_process())) return false;
+
+    if (likely(hymo_stealth_enabled)) {
+        size_t name_len = strlen(hymo_current_mirror_name);
+        size_t path_len = strlen(hymo_current_mirror_path);
+
+        if ((len == name_len && strcmp(pathname, hymo_current_mirror_name) == 0) ||
+            (len == path_len && strcmp(pathname, hymo_current_mirror_path) == 0)) {
+            return true;
+        }
+    }
+
+    if (!hymo_should_apply_hide_rules())
+        return false;
+
+    /* Bloom fast-path: path definitely not in hide list */
+    if (atomic_read(&hymo_hide_count) != 0) {
+        unsigned long bh1 = jhash(pathname, (u32)len, 0) & (HYMO_BLOOM_SIZE - 1);
+        unsigned long bh2 = jhash(pathname, (u32)len, 1) & (HYMO_BLOOM_SIZE - 1);
+        if (!test_bit(bh1, hymo_hide_bloom) || !test_bit(bh2, hymo_hide_bloom))
+            return false;
+    } else {
+        return false;
+    }
+
+    /* Check hash table for explicit hide rules (fallback for non-inode paths) */
+    hash = full_name_hash(NULL, pathname, len);
+    rcu_read_lock();
+    hlist_for_each_entry_rcu(hide_entry, &hymo_hide_paths[hash_min(hash, HYMO_HASH_BITS)], node) {
+        if (unlikely(hide_entry->path_hash == hash && strcmp(hide_entry->path, pathname) == 0)) {
+            rcu_read_unlock();
+            return true;
+        }
+    }
+    rcu_read_unlock();
+
+    return false;
+}
+EXPORT_SYMBOL(__hymofs_should_hide);
+#endif /* CONFIG_HYMOFS_HIDE_ENTRIES */
+
+bool __hymofs_should_spoof_mtime(const char *pathname)
+{
+    struct hymo_inject_entry *entry;
+    u32 hash;
+    bool found = false;
+    pid_t current_pid;
+
+    if (unlikely(!hymofs_enabled)) return false;
+    if (unlikely(!pathname)) return false;
+
+    /* Allow daemon process to see real mtime */
+    current_pid = task_tgid_vnr(current);
+    if (hymo_daemon_pid > 0 && current_pid == hymo_daemon_pid) {
+        return false;
+    }
+
+    hash = full_name_hash(NULL, pathname, strlen(pathname));
+
+    rcu_read_lock();
+    hlist_for_each_entry_rcu(entry, &hymo_inject_dirs[hash_min(hash, HYMO_HASH_BITS)], node) {
+        if (strcmp(entry->dir, pathname) == 0) {
+            found = true;
+            break;
+        }
+    }
+    rcu_read_unlock();
+    return found;
+}
+EXPORT_SYMBOL(__hymofs_should_spoof_mtime);
+
+static bool __hymofs_should_replace(const char *pathname)
+{
+    struct hymo_entry *entry;
+    u32 hash;
+    size_t path_len;
+    bool found = false;
+    pid_t current_pid;
+
+    if (unlikely(!hymofs_enabled)) return false;
+    if (unlikely(!pathname)) return false;
+
+    /* Allow daemon process to bypass replacement */
+    current_pid = task_tgid_vnr(current);
+    if (hymo_daemon_pid > 0 && current_pid == hymo_daemon_pid) {
+        return false;
+    }
+
+    if (atomic_read(&hymo_rule_count) == 0)
+        return false;
+
+    path_len = strlen(pathname);
+    /* Bloom fast-path: skip lookup when path is definitely not in rules (KPM backport) */
+    {
+        unsigned long bh1 = jhash(pathname, (u32)path_len, 0) & (HYMO_BLOOM_SIZE - 1);
+        unsigned long bh2 = jhash(pathname, (u32)path_len, 1) & (HYMO_BLOOM_SIZE - 1);
+        if (!test_bit(bh1, hymo_path_bloom) || !test_bit(bh2, hymo_path_bloom))
+            return false;
+    }
+
+    hash = full_name_hash(NULL, pathname, path_len);
+    rcu_read_lock();
+    hlist_for_each_entry_rcu(entry, &hymo_paths[hash_min(hash, HYMO_HASH_BITS)], node) {
+        if (unlikely(entry->src_hash == hash && strcmp(entry->src, pathname) == 0)) {
+            found = true;
+            break;
+        }
+    }
+    rcu_read_unlock();
+    return found;
+}
+
+struct hymo_merge_ctx {
+    struct dir_context ctx;
+    struct list_head *head;
+    const char *dir_path;
+};
+
+static HYMO_FILLDIR_RET_TYPE hymo_merge_filldir(struct dir_context *ctx, const char *name, int namlen,
+		      loff_t offset, u64 ino, unsigned int d_type)
+{
+    struct hymo_merge_ctx *mctx = container_of(ctx, struct hymo_merge_ctx, ctx);
+    struct hymo_name_list *item;
+
+    if (namlen == 1 && name[0] == '.') return HYMO_FILLDIR_CONTINUE;
+    if (namlen == 2 && name[0] == '.' && name[1] == '.') return HYMO_FILLDIR_CONTINUE;
+
+    /* Skip .replace marker */
+    if (namlen == 8 && strncmp(name, ".replace", 8) == 0) return HYMO_FILLDIR_CONTINUE;
+
+    /* Check for whiteout (char dev 0:0) */
+    if (d_type == DT_CHR) {
+        char *path = kasprintf(GFP_KERNEL, "%s/%.*s", mctx->dir_path, namlen, name);
+        if (path) {
+            struct kstat stat;
+            struct path p;
+            if (kern_path(path, LOOKUP_FOLLOW, &p) == 0) {
+                if (vfs_getattr(&p, &stat, STATX_TYPE, AT_STATX_SYNC_AS_STAT) == 0) {
+                    if (S_ISCHR(stat.mode) && stat.rdev == 0) {
+                        /* It is a whiteout, skip injection */
+                        path_put(&p);
+                        kfree(path);
+                        return HYMO_FILLDIR_CONTINUE;
+                    }
+                }
+                path_put(&p);
+            }
+            kfree(path);
+        }
+    }
+
+    /* Check for duplicates */
+    {
+        struct hymo_name_list *pos;
+        list_for_each_entry(pos, mctx->head, list) {
+            if (strlen(pos->name) == namlen && strncmp(pos->name, name, namlen) == 0) {
+                return HYMO_FILLDIR_CONTINUE; /* Already exists */
+            }
+        }
+    }
+
+    item = kmalloc(sizeof(*item), GFP_KERNEL);
+    if (item) {
+        item->name = kstrndup(name, namlen, GFP_KERNEL);
+        item->type = d_type;
+        if (item->name) {
+            list_add(&item->list, mctx->head);
+        } else {
+            kfree(item);
+        }
+    }
+    return HYMO_FILLDIR_CONTINUE;
+}
+
+int hymofs_populate_injected_list(const char *dir_path, struct dentry *parent, struct list_head *head)
+{
+    struct hymo_entry *entry;
+    struct hymo_inject_entry *inject_entry;
+    struct hymo_merge_entry *merge_entry;
+    struct hymo_name_list *item;
+    u32 hash;
+    int bkt;
+    bool should_inject = false;
+    struct list_head merge_targets;
+    struct hymo_merge_target_node *target_node, *tmp_node;
+    size_t dir_len;
+    
+    if (unlikely(!hymofs_enabled)) return 0;
+    if (unlikely(!dir_path)) return 0;
+
+    INIT_LIST_HEAD(&merge_targets);
+    dir_len = strlen(dir_path);
+    hash = full_name_hash(NULL, dir_path, dir_len);
+
+    rcu_read_lock();
+    
+    hlist_for_each_entry_rcu(inject_entry, &hymo_inject_dirs[hash_min(hash, HYMO_HASH_BITS)], node) {
+        if (strcmp(inject_entry->dir, dir_path) == 0) {
+            should_inject = true;
+            break;
+        }
+    }
+    
+    // Check for merge rule
+    hlist_for_each_entry_rcu(merge_entry, &hymo_merge_dirs[hash_min(hash, HYMO_HASH_BITS)], node) {
+        if (strcmp(merge_entry->src, dir_path) == 0) {
+            target_node = kmalloc(sizeof(*target_node), GFP_ATOMIC);
+            if (target_node) {
+                target_node->target = kstrdup(merge_entry->target, GFP_ATOMIC);
+                list_add_tail(&target_node->list, &merge_targets);
+             should_inject = true;
+        }
+        }
+    }
+
+    if (should_inject) {
+        // Static injections
+        hash_for_each_rcu(hymo_paths, bkt, entry, node) {
+            if (strncmp(entry->src, dir_path, dir_len) == 0) {
+                char *name = NULL;
+                if (dir_len == 1 && dir_path[0] == '/') {
+                    name = entry->src + 1;
+                } else if (entry->src[dir_len] == '/') {
+                    name = entry->src + dir_len + 1;
+                }
+
+                if (name && *name && strchr(name, '/') == NULL) {
+                    /* Check for duplicates */
+                    bool exists = false;
+                    struct hymo_name_list *pos;
+                    list_for_each_entry(pos, head, list) {
+                        if (strcmp(pos->name, name) == 0) {
+                            exists = true;
+                            break;
+                        }
+                    }
+
+                    if (!exists) {
+                    item = kmalloc(sizeof(*item), GFP_ATOMIC);
+                    if (item) {
+                        item->name = kstrdup(name, GFP_ATOMIC);
+                        item->type = entry->type;
+                        if (item->name) {
+                            list_add(&item->list, head);
+                        }
+                        else kfree(item);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    rcu_read_unlock();
+
+    // Dynamic merge (outside RCU lock, kern_path/iterate_dir may sleep)
+    list_for_each_entry_safe(target_node, tmp_node, &merge_targets, list) {
+        if (target_node->target) {
+            struct path path;
+            if (kern_path(target_node->target, LOOKUP_FOLLOW, &path) == 0) {
+                /* Use init_cred (root) to ensure we can read the module directory 
+                   regardless of the calling process's permissions */
+                const struct cred *cred = get_task_cred(&init_task);
+                struct file *f = dentry_open(&path, O_RDONLY | O_DIRECTORY, cred);
+                if (!IS_ERR(f)) {
+                    struct hymo_merge_ctx mctx = {
+                        .ctx.actor = hymo_merge_filldir,
+                        .head = head,
+                        .dir_path = target_node->target
+                    };
+                    iterate_dir(f, &mctx.ctx);
+                    fput(f);
+                }
+                put_cred(cred);
+                path_put(&path);
+            }
+            kfree(target_node->target);
+        }
+        kfree(target_node);
+    }
+
+    return 0;
+}
+EXPORT_SYMBOL(hymofs_populate_injected_list);
+
+struct filename *hymofs_handle_getname(struct filename *result)
+{
+    char *target = NULL;
+    bool is_absolute;
+
+    if (unlikely(IS_ERR(result))) return result;
+
+    if (unlikely(!hymofs_enabled))
+        return result;
+
+    if (likely(hash_empty(hymo_paths) && 
+               hash_empty(hymo_hide_paths) && 
+               hash_empty(hymo_merge_dirs)))
+        return result;
+
+    is_absolute = (result->name[0] == '/');
+
+    if (unlikely(hymofs_should_hide(result->name))) {
+        putname(result);
+        return ERR_PTR(-ENOENT);
+    }
+
+    if (likely(is_absolute)) {
+        target = hymofs_resolve_target(result->name);
+        if (unlikely(target)) {
+            putname(result);
+            result = getname_kernel(target);
+            kfree(target);
+        }
+        return result;
+    }
+
+    /* Handle relative paths - optimized slow path */
+    {
+        char *buf = NULL;
+        struct path pwd;
+        char *cwd;
+        int cwd_len, name_len;
+        const char *name = result->name;
+
+        /* Skip ./ prefix */
+        if (name[0] == '.' && name[1] == '/') {
+            name += 2;
+        }
+
+        /* Get current directory without spin_lock - use RCU */
+        rcu_read_lock();
+        pwd = current->fs->pwd;
+        path_get(&pwd);
+        rcu_read_unlock();
+
+        /* Allocate buffer only after we have pwd */
+        buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+        if (!buf) {
+            path_put(&pwd);
+            goto fallback_absolute;
+        }
+
+        /* Use d_path (hooked) to get the virtual path of CWD */
+        cwd = d_path(&pwd, buf, PAGE_SIZE);
+        path_put(&pwd);
+
+        if (IS_ERR(cwd)) {
+            kfree(buf);
+            goto fallback_absolute;
+        }
+
+        cwd_len = strlen(cwd);
+        name_len = strlen(name);
+
+        /* Move to beginning of buffer to allow appending */
+        if (cwd != buf) {
+            memmove(buf, cwd, cwd_len + 1);
+            cwd = buf;
+        }
+
+        if (cwd_len + 1 + name_len < PAGE_SIZE) {
+            /* Construct absolute path: cwd + / + name */
+            if (cwd_len > 0 && cwd[cwd_len - 1] != '/') {
+                cwd[cwd_len++] = '/';
+                cwd[cwd_len] = '\0';
+            }
+            memcpy(cwd + cwd_len, name, name_len + 1);
+
+            /* Try to resolve the constructed absolute path */
+            target = hymofs_resolve_target(cwd);
+        }
+
+        kfree(buf);
+    }
+
+fallback_absolute:
+    /* If relative path resolution failed, try the original name */
+    if (!target) {
+        target = hymofs_resolve_target(result->name);
+    }
+
+    if (target) {
+        putname(result);
+        result = getname_kernel(target);
+        kfree(target);
+    }
+
+    return result;
+}
+EXPORT_SYMBOL(hymofs_handle_getname);
+
+/* Resolve relative path with dirfd for fstatat() merge support */
+struct filename *hymofs_resolve_relative(int dfd, const char *name)
+{
+    struct fd f;
+    struct filename *result = NULL;
+    char *buf, *dir_path, *target;
+    size_t dir_len, name_len;
+
+    f = fdget(dfd);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 12, 0))
+    if (fd_empty(f))
+        return NULL;
+#else
+    if (!f.file)
+        return NULL;
+#endif
+
+    buf = kmalloc(PATH_MAX, GFP_KERNEL);
+    if (!buf)
+        goto out_fdput;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 12, 0))
+    dir_path = d_path(&fd_file(f)->f_path, buf, PATH_MAX);
+#else
+    dir_path = d_path(&f.file->f_path, buf, PATH_MAX);
+#endif
+    if (IS_ERR(dir_path))
+        goto out_free;
+
+    dir_len = strlen(dir_path);
+    name_len = strlen(name);
+    if (dir_len + 1 + name_len >= PATH_MAX)
+        goto out_free;
+
+    /* Build full path in-place */
+    if (dir_path != buf)
+        memmove(buf, dir_path, dir_len);
+    if (dir_len > 0 && buf[dir_len - 1] != '/')
+        buf[dir_len++] = '/';
+    memcpy(buf + dir_len, name, name_len + 1);
+
+    target = __hymofs_resolve_target(buf);
+    if (target) {
+        result = getname_kernel(target);
+        if (IS_ERR(result))
+            result = NULL;
+        kfree(target);
+    }
+
+out_free:
+    kfree(buf);
+out_fdput:
+    fdput(f);
+    return result;
+}
+EXPORT_SYMBOL(hymofs_resolve_relative);
+
+/* Bloom filter helper - add a filename */
+static __always_inline void bloom_add(unsigned long *filter, const char *name, int namlen)
+{
+    u32 h1 = full_name_hash(NULL, name, namlen);
+    __set_bit(h1 & HYMO_BLOOM_MASK, filter);  /* Non-atomic, faster */
+    __set_bit((h1 >> 16) & HYMO_BLOOM_MASK, filter);
+}
+
+/* Bloom filter helper - test if filename might exist */
+static __always_inline bool bloom_test(const unsigned long *filter, const char *name, int namlen)
+{
+    u32 h1 = full_name_hash(NULL, name, namlen);
+    /* Use logical AND for boolean result */
+    return test_bit(h1 & HYMO_BLOOM_MASK, filter) && 
+           test_bit((h1 >> 16) & HYMO_BLOOM_MASK, filter);
+}
+
+/* Callback context for enumerating merge target directory */
+struct bloom_fill_ctx {
+    struct dir_context ctx;
+    unsigned long *filter;
+};
+
+/* Callback to add each filename to bloom filter */
+static HYMO_FILLDIR_RET_TYPE bloom_filldir(struct dir_context *ctx, const char *name, int namlen,
+                          loff_t offset, u64 ino, unsigned int d_type)
+{
+    struct bloom_fill_ctx *bctx = container_of(ctx, struct bloom_fill_ctx, ctx);
+    /* Skip . and .. */
+    if (namlen == 1 && name[0] == '.')
+        return HYMO_FILLDIR_CONTINUE;
+    if (namlen == 2 && name[0] == '.' && name[1] == '.')
+        return HYMO_FILLDIR_CONTINUE;
+    bloom_add(bctx->filter, name, namlen);
+    return HYMO_FILLDIR_CONTINUE;
+}
+
+void __hymofs_prepare_readdir(struct hymo_readdir_context *ctx, struct file *file)
+{
+    struct inode *dir_inode;
+    int i;
+    
+    ctx->file = file;
+    ctx->path_buf = NULL;
+    ctx->dir_path = NULL;
+    ctx->dir_path_len = 0;
+    INIT_LIST_HEAD(&ctx->merge_targets);
+    ctx->is_replace_mode = false;
+    ctx->dir_has_hidden = false;
+    ctx->has_merge_files = false;
+    
+    /* Initialize bloom filter */
+    memset(ctx->bloom_filter, 0, sizeof(ctx->bloom_filter));
+    
+    /* Initialize merge files hash table */
+    for (i = 0; i < HYMO_MERGE_HASH_SIZE; i++)
+        INIT_HLIST_HEAD(&ctx->merge_files[i]);
+
+    /* Fast path: Check if this directory has any hidden entries */
+    if (file && file->f_path.dentry) {
+        dir_inode = d_inode(file->f_path.dentry);
+        if (dir_inode && dir_inode->i_mapping) {
+            ctx->dir_has_hidden = test_bit(AS_FLAGS_HYMO_DIR_HAS_HIDDEN, 
+                                           &dir_inode->i_mapping->flags);
+        }
+    }
+
+    ctx->path_buf = (char *)__get_free_page(GFP_KERNEL);
+    if (ctx->path_buf && file && file->f_path.dentry) {
+        char *p = d_path(&file->f_path, ctx->path_buf, PAGE_SIZE);
+        if (!IS_ERR(p)) {
+            int len = strlen(p);
+            memmove(ctx->path_buf, p, len + 1);
+            ctx->dir_path = ctx->path_buf;
+            ctx->dir_path_len = len;
+            // hymo_log("readdir prepare: %s\n", ctx->dir_path);
+
+            /* Check for merge rule */
+            {
+                struct hymo_merge_entry *entry;
+                u32 hash = full_name_hash(NULL, ctx->dir_path, ctx->dir_path_len);
+                
+                rcu_read_lock();
+                hlist_for_each_entry_rcu(entry, &hymo_merge_dirs[hash_min(hash, HYMO_HASH_BITS)], node) {
+                    if (strcmp(entry->src, ctx->dir_path) == 0) {
+                        struct hymo_merge_target_node *node = kmalloc(sizeof(*node), GFP_ATOMIC);
+                        if (node) {
+                            struct path target_path;
+                            node->target = kstrdup(entry->target, GFP_ATOMIC);
+                            node->target_dentry = NULL;
+                            /* Cache the target dentry for fast lookup */
+                            if (kern_path(entry->target, LOOKUP_FOLLOW, &target_path) == 0) {
+                                node->target_dentry = dget(target_path.dentry);
+                                path_put(&target_path);
+                            }
+                            list_add_tail(&node->list, &ctx->merge_targets);
+                        }
+                    }
+                }
+                rcu_read_unlock();
+
+                /* Check for .replace marker in merge targets */
+                if (!list_empty(&ctx->merge_targets)) {
+                    struct hymo_merge_target_node *node;
+                    list_for_each_entry(node, &ctx->merge_targets, list) {
+                        char *replace_path = kasprintf(GFP_KERNEL, "%s/.replace", node->target);
+                        if (replace_path) {
+                            struct path path;
+                            if (kern_path(replace_path, LOOKUP_FOLLOW, &path) == 0) {
+                                ctx->is_replace_mode = true;
+                                hymo_log("replace mode enabled for %s (found %s)\n", ctx->dir_path, replace_path);
+                                path_put(&path);
+                            }
+                            kfree(replace_path);
+                            if (ctx->is_replace_mode) break;
+                        }
+                    }
+                    
+                    /* Mark that we have merge files to check */
+                    if (!ctx->is_replace_mode) {
+                        ctx->has_merge_files = true;
+                        
+                        /* Build bloom filter by enumerating merge target directories */
+                        list_for_each_entry(node, &ctx->merge_targets, list) {
+                            if (node->target_dentry) {
+                                struct file *target_file;
+                                struct path target_path = {
+                                    .mnt = file->f_path.mnt,
+                                    .dentry = node->target_dentry
+                                };
+                                target_file = dentry_open(&target_path, O_RDONLY | O_DIRECTORY, current_cred());
+                                if (!IS_ERR(target_file)) {
+                                    struct bloom_fill_ctx bctx = {
+                                        .ctx.actor = bloom_filldir,
+                                        .filter = ctx->bloom_filter
+                                    };
+                                    iterate_dir(target_file, &bctx.ctx);
+                                    fput(target_file);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        } else {
+            free_page((unsigned long)ctx->path_buf);
+            ctx->path_buf = NULL;
+        }
+    }
+}
+EXPORT_SYMBOL(__hymofs_prepare_readdir);
+
+void __hymofs_cleanup_readdir(struct hymo_readdir_context *ctx)
+{
+    struct hymo_merge_target_node *node, *tmp;
+    
+    if (ctx->path_buf) free_page((unsigned long)ctx->path_buf);
+    list_for_each_entry_safe(node, tmp, &ctx->merge_targets, list) {
+        if (node->target_dentry)
+            dput(node->target_dentry);
+        kfree(node->target);
+        kfree(node);
+    }
+}
+EXPORT_SYMBOL(__hymofs_cleanup_readdir);
+
+bool __hymofs_check_filldir(struct hymo_readdir_context *ctx, const char *name, int namlen)
+{
+    struct dentry *child;
+    struct inode *inode;
+    pid_t current_pid;
+    struct hymo_merge_target_node *node;
+
+    /* Root sees everything */
+    if (uid_eq(current_uid(), GLOBAL_ROOT_UID))
+        return false;
+
+    /* Allow daemon process to see all directory entries */
+    current_pid = task_tgid_vnr(current);
+    if (hymo_daemon_pid > 0 && current_pid == hymo_daemon_pid) {
+        return false;
+    }
+
+    /* Fast path: If directory has no hidden entries and no merge files, skip all checks */
+    if (likely(!ctx->dir_has_hidden && !ctx->has_merge_files))
+        return false;  /* O(1) skip! */
+
+    /* Skip . and .. - use single comparison where possible */
+    if (unlikely(namlen <= 2 && name[0] == '.')) {
+        if (namlen == 1 || (namlen == 2 && name[1] == '.'))
+            return false;
+    }
+
+    /* Stealth mode: Hide hymo devices in /dev directory */
+    if (hymo_stealth_enabled && ctx->dir_path) {
+        /* Check if we're listing /dev directory */
+        if (ctx->dir_path_len == 4 && strcmp(ctx->dir_path, "/dev") == 0) {
+            size_t mirror_name_len = strlen(hymo_current_mirror_name);
+            if (namlen == mirror_name_len && 
+                memcmp(name, hymo_current_mirror_name, namlen) == 0) {
+                return true;
+            }
+        }
+    }
+
+    /* If we are in replace mode, hide all original entries */
+    if (unlikely(ctx->is_replace_mode))
+        return true;
+
+    /* Fast path: Use inode marking (O(1) bit test) */
+    if (ctx->dir_has_hidden && !hymo_is_privileged_process() &&
+        hymo_should_apply_hide_rules() && ctx->file && ctx->file->f_path.dentry) {
+        child = d_hash_and_lookup(ctx->file->f_path.dentry, 
+                                  &(struct qstr)QSTR_INIT(name, namlen));
+        if (child) {
+            inode = d_inode(child);
+            if (inode && inode->i_mapping &&
+                test_bit(AS_FLAGS_HYMO_HIDE, &inode->i_mapping->flags)) {
+                dput(child);
+                return true;
+            }
+            dput(child);
+        }
+    }
+
+    /* Merge target check - files that exist in merge target should be hidden */
+    if (ctx->has_merge_files) {
+        /* Ultra fast path: Bloom filter says definitely not in merge target */
+        if (!bloom_test(ctx->bloom_filter, name, namlen)) {
+            return false;  /* O(1) skip - bloom filter negative */
+        }
+        
+        /* Bloom filter positive - need to confirm with d_hash_and_lookup */
+        list_for_each_entry(node, &ctx->merge_targets, list) {
+            /* Fast path: use cached dentry + d_hash_and_lookup */
+            if (node->target_dentry) {
+                struct dentry *child = d_hash_and_lookup(node->target_dentry,
+                                           &(struct qstr)QSTR_INIT(name, namlen));
+                if (child) {
+                    dput(child);
+                    return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
+EXPORT_SYMBOL(__hymofs_check_filldir);
+
+struct linux_dirent {
+	unsigned long	d_ino;
+	unsigned long	d_off;
+	unsigned short	d_reclen;
+	char		d_name[];
+};
+
+#ifdef CONFIG_HYMOFS_INJECT_ENTRIES
+/* Inject virtual entries into getdents system call */
+int hymofs_inject_entries(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos)
+{
+    struct linux_dirent __user *current_dir = *dir_ptr;
+    struct list_head head;
+    struct hymo_name_list *item, *tmp;
+    loff_t current_idx = 0;
+    loff_t start_idx;
+    int injected = 0;
+    int error = 0;
+    int initial_count = *count;
+    bool is_transition = (*pos < HYMO_MAGIC_POS);
+    struct dentry *parent;
+
+    if (!ctx->file) return 0;
+    parent = ctx->file->f_path.dentry;
+
+    if (is_transition) {
+        start_idx = 0;
+    } else {
+        start_idx = *pos - HYMO_MAGIC_POS;
+    }
+
+    INIT_LIST_HEAD(&head);
+    hymofs_populate_injected_list(ctx->dir_path, parent, &head);
+
+    list_for_each_entry_safe(item, tmp, &head, list) {
+        if (current_idx >= start_idx) {
+            int name_len = strlen(item->name);
+            int reclen = ALIGN(offsetof(struct linux_dirent, d_name) + name_len + 2, sizeof(long));
+            if (*count >= reclen) {
+                struct linux_dirent d;
+                d.d_ino = 1;
+                d.d_off = HYMO_MAGIC_POS + current_idx + 1;
+                d.d_reclen = reclen;
+                if (copy_to_user(current_dir, &d, offsetof(struct linux_dirent, d_name)) ||
+                    copy_to_user(current_dir->d_name, item->name, name_len) ||
+                    put_user(0, current_dir->d_name + name_len) ||
+                    put_user(item->type, (char __user *)current_dir + reclen - 1)) {
+                        error = -EFAULT;
+                        break;
+                }
+                current_dir = (struct linux_dirent __user *)((char __user *)current_dir + reclen);
+                *count -= reclen;
+                injected++;
+            } else {
+                break;
+            }
+        }
+        current_idx++;
+        list_del(&item->list);
+        kfree(item->name);
+        kfree(item);
+    }
+    
+    list_for_each_entry_safe(item, tmp, &head, list) {
+        list_del(&item->list);
+        kfree(item->name);
+        kfree(item);
+    }
+
+    if (error == 0) {
+        if (injected > 0) {
+            if (is_transition) {
+                *pos = HYMO_MAGIC_POS + injected;
+            } else {
+                *pos += injected;
+            }
+        }
+        error = initial_count - *count;
+    }
+    
+    *dir_ptr = current_dir;
+    return error;
+}
+EXPORT_SYMBOL(hymofs_inject_entries);
+
+/* Inject virtual entries into getdents64 system call */
+int hymofs_inject_entries64(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos)
+{
+    struct linux_dirent64 __user *current_dir = *dir_ptr;
+    struct list_head head;
+    struct hymo_name_list *item, *tmp;
+    loff_t current_idx = 0;
+    loff_t start_idx;
+    int injected = 0;
+    int error = 0;
+    int initial_count = *count;
+    bool is_transition = (*pos < HYMO_MAGIC_POS);
+    struct dentry *parent;
+
+    if (!ctx->file) return 0;
+    parent = ctx->file->f_path.dentry;
+
+    if (is_transition) {
+        start_idx = 0;
+    } else {
+        start_idx = *pos - HYMO_MAGIC_POS;
+    }
+
+    INIT_LIST_HEAD(&head);
+    hymofs_populate_injected_list(ctx->dir_path, parent, &head);
+
+    list_for_each_entry_safe(item, tmp, &head, list) {
+        if (current_idx >= start_idx) {
+            int name_len = strlen(item->name);
+            int reclen = ALIGN(offsetof(struct linux_dirent64, d_name) + name_len + 1, sizeof(u64));
+            if (*count >= reclen) {
+                struct linux_dirent64 d;
+                d.d_ino = 1;
+                d.d_off = HYMO_MAGIC_POS + current_idx + 1;
+                d.d_reclen = reclen;
+                d.d_type = item->type;
+                if (copy_to_user(current_dir, &d, offsetof(struct linux_dirent64, d_name)) ||
+                    copy_to_user(current_dir->d_name, item->name, name_len) ||
+                    put_user(0, current_dir->d_name + name_len)) {
+                        error = -EFAULT;
+                        break;
+                }
+                current_dir = (struct linux_dirent64 __user *)((char __user *)current_dir + reclen);
+                *count -= reclen;
+                injected++;
+            } else {
+                break;
+            }
+        }
+        current_idx++;
+        list_del(&item->list);
+        kfree(item->name);
+        kfree(item);
+    }
+    
+    list_for_each_entry_safe(item, tmp, &head, list) {
+        list_del(&item->list);
+        kfree(item->name);
+        kfree(item);
+    }
+
+    if (error == 0) {
+        if (injected > 0) {
+            if (is_transition) {
+                *pos = HYMO_MAGIC_POS + injected;
+            } else {
+                *pos += injected;
+            }
+        }
+        error = initial_count - *count;
+    }
+    
+    *dir_ptr = current_dir;
+    return error;
+}
+EXPORT_SYMBOL(hymofs_inject_entries64);
+#endif /* CONFIG_HYMOFS_INJECT_ENTRIES */
+
+#ifdef CONFIG_HYMOFS_STAT_SPOOF
+static dev_t __attribute__((unused)) get_dev_for_path(const char *path_str) {
+    struct path path;
+    dev_t dev = 0;
+    if (kern_path(path_str, LOOKUP_FOLLOW, &path) == 0) {
+        if (path.dentry && path.dentry->d_sb) {
+            dev = path.dentry->d_sb->s_dev;
+        }
+        path_put(&path);
+    }
+    return dev;
+}
+
+/* Update timestamps for injected directories to appear current */
+extern char *d_absolute_path(const struct path *, char *, int);
+
+/* Fast path check: determine if path might need HymoFS processing */
+static inline bool hymofs_needs_check(const struct path *path)
+{
+    const struct dentry *dentry;
+    const char *name;
+    
+    if (!path || !path->dentry)
+        return false;
+    
+    dentry = path->dentry;
+    name = dentry->d_name.name;
+    
+    /* Skip common system paths that never have HymoFS rules */
+    if (name[0] == 'd' && !strncmp(name, "dev", 3))
+        return false;
+    if (name[0] == 'p' && !strncmp(name, "proc", 4))
+        return false;
+    if (name[0] == 's' && !strncmp(name, "sys", 3))
+        return false;
+    
+    /* If no rules exist, skip all processing */
+    if (atomic_read(&hymo_rule_count) == 0)
+        return false;
+    
+    return true;
+}
+
+void hymofs_spoof_stat(const struct path *path, struct kstat *stat)
+{
+    char *buf, *virtual_buf = NULL;
+    char *p;
+    bool is_injected = false;
+    gfp_t gfp = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+
+    /* Fast path checks - avoid all overhead if not needed */
+    if (!hymofs_enabled) {
+        atomic64_inc(&hymo_stats.fast_path_skips);
+        return;
+    }
+    if (!hymo_stealth_enabled) {
+        atomic64_inc(&hymo_stats.fast_path_skips);
+        return;
+    }
+    
+    /* Quick path validation */
+    if (!hymofs_needs_check(path)) {
+        atomic64_inc(&hymo_stats.fast_path_skips);
+        return;
+    }
+    
+    /* Check if rules tables are empty - ultimate fast path */
+    if (likely(hash_empty(hymo_paths) && hash_empty(hymo_targets) && 
+               hash_empty(hymo_inject_dirs))) {
+        atomic64_inc(&hymo_stats.fast_path_skips);
+        return;
+    }
+    
+    atomic64_inc(&hymo_stats.total_checks);
+
+    buf = kmalloc(PAGE_SIZE, gfp);
+    if (!buf || !path || !path->dentry) {
+        if (buf) kfree(buf);
+        return;
+    }
+
+    /* Use d_absolute_path to bypass our own d_path hook and get the real physical path */
+    p = d_absolute_path(path, buf, PAGE_SIZE);
+    if (!IS_ERR(p)) {
+        /* HymoFS: Check if this path is a merge target (physical path) and map back to virtual */
+        virtual_buf = kmalloc(PAGE_SIZE, gfp);
+        
+        if (virtual_buf) {
+            if (__hymofs_reverse_lookup(p, virtual_buf, PAGE_SIZE) > 0) {
+                p = virtual_buf; /* Switch to virtual path */
+                is_injected = true;
+            }
+        }
+
+        /* Only spoof attributes for files we injected */
+        if (is_injected) {
+            /* Always look up parent to get correct fs attributes (dev, uid, gid) */
+                char *last_slash = strrchr(p, '/');
+                if (last_slash) {
+                    struct path parent_path;
+                    if (last_slash == p) {
+                        /* Parent is root */
+                        if (kern_path("/", LOOKUP_FOLLOW, &parent_path) == 0) {
+                            struct inode *inode = d_backing_inode(parent_path.dentry);
+                            stat->uid = inode->i_uid;
+                            stat->gid = inode->i_gid;
+                            stat->dev = inode->i_sb->s_dev;
+                            path_put(&parent_path);
+                        }
+                    } else {
+                        *last_slash = '\0';
+                        if (kern_path(p, LOOKUP_FOLLOW, &parent_path) == 0) {
+                            struct inode *inode = d_backing_inode(parent_path.dentry);
+                            stat->uid = inode->i_uid;
+                            stat->gid = inode->i_gid;
+                            stat->dev = inode->i_sb->s_dev;
+                            path_put(&parent_path);
+                        } else {
+                            /* Fallback if parent lookup fails (rare) */
+                            if (strncmp(p, "/system/", 8) == 0 || 
+                                strncmp(p, "/vendor/", 8) == 0 ||
+                                strncmp(p, "/product/", 9) == 0 ||
+                                strncmp(p, "/odm/", 5) == 0 ||
+                                strncmp(p, "/apex/", 6) == 0) {
+                                stat->uid = KUIDT_INIT(0);
+                                stat->gid = KGIDT_INIT(0);
+                            }
+                        }
+                        *last_slash = '/';
+                    }
+                }
+                /* Obfuscate inode for injected files too */
+                stat->ino ^= 0x48594D4F;
+            }
+
+        if (hymofs_should_spoof_mtime(p)) {
+            ktime_get_real_ts64(&stat->mtime);
+            stat->ctime = stat->mtime;
+        }
+        /* HymoFS: Inode obfuscation for redirected paths */
+        if (__hymofs_should_replace(p)) {
+            /* XOR with a magic number to make inode look different from target */
+            stat->ino ^= 0x48594D4F;
+            
+            /* Fixup permissions for /system paths to ensure they look like root-owned */
+            if (strncmp(p, "/system/", 8) == 0) {
+                stat->uid = KUIDT_INIT(0);
+                stat->gid = KGIDT_INIT(0);
+            }
+        }
+        if (virtual_buf) kfree(virtual_buf);
+    }
+    kfree(buf);
+}
+EXPORT_SYMBOL(hymofs_spoof_stat);
+
+/*
+ * ==================== kstat Spoofing Implementation ====================
+ * Allows full stat() result manipulation for specific inodes
+ */
+
+struct hymo_kstat_entry {
+    unsigned long target_ino;
+    struct {
+        dev_t spoofed_dev;
+        unsigned long spoofed_ino;
+        unsigned int spoofed_nlink;
+        loff_t spoofed_size;
+        long spoofed_atime_sec;
+        long spoofed_atime_nsec;
+        long spoofed_mtime_sec;
+        long spoofed_mtime_nsec;
+        long spoofed_ctime_sec;
+        long spoofed_ctime_nsec;
+        unsigned long spoofed_blksize;
+        unsigned long long spoofed_blocks;
+    } info;
+    struct hlist_node node;
+    struct rcu_head rcu;
+};
+
+static DEFINE_HASHTABLE(hymo_kstat_entries, 8);
+
+bool hymofs_is_kstat_spoofed(struct inode *inode)
+{
+    struct hymo_kstat_entry *entry;
+    bool found = false;
+
+    /* Early boot protection */
+    if (system_state < SYSTEM_RUNNING) return false;
+    if (!inode) return false;
+    if (!hymofs_enabled) return false;
+
+    rcu_read_lock();
+    hash_for_each_possible_rcu(hymo_kstat_entries, entry, node, inode->i_ino) {
+        if (entry->target_ino == inode->i_ino) {
+            found = true;
+            break;
+        }
+    }
+    rcu_read_unlock();
+    return found;
+}
+EXPORT_SYMBOL(hymofs_is_kstat_spoofed);
+
+void hymofs_spoof_kstat_by_ino(unsigned long ino, struct kstat *stat)
+{
+    struct hymo_kstat_entry *entry;
+
+    /* Early boot protection */
+    if (system_state < SYSTEM_RUNNING) return;
+    if (!stat) return;
+    if (!hymofs_enabled) return;
+
+    /* Root sees real values */
+    if (uid_eq(current_uid(), GLOBAL_ROOT_UID))
+        return;
+
+    rcu_read_lock();
+    hash_for_each_possible_rcu(hymo_kstat_entries, entry, node, ino) {
+        if (entry->target_ino == ino) {
+            stat->dev = entry->info.spoofed_dev;
+            stat->ino = entry->info.spoofed_ino;
+            stat->nlink = entry->info.spoofed_nlink;
+            stat->size = entry->info.spoofed_size;
+            stat->atime.tv_sec = entry->info.spoofed_atime_sec;
+            stat->atime.tv_nsec = entry->info.spoofed_atime_nsec;
+            stat->mtime.tv_sec = entry->info.spoofed_mtime_sec;
+            stat->mtime.tv_nsec = entry->info.spoofed_mtime_nsec;
+            stat->ctime.tv_sec = entry->info.spoofed_ctime_sec;
+            stat->ctime.tv_nsec = entry->info.spoofed_ctime_nsec;
+            stat->blksize = entry->info.spoofed_blksize;
+            stat->blocks = entry->info.spoofed_blocks;
+            hymo_log("kstat: spoofed ino %lu\n", ino);
+            break;
+        }
+    }
+    rcu_read_unlock();
+}
+EXPORT_SYMBOL(hymofs_spoof_kstat_by_ino);
+
+/* Get performance statistics */
+void hymofs_get_perf_stats(struct hymofs_perf_info *info)
+{
+    if (!info)
+        return;
+    
+    info->total_checks = atomic64_read(&hymo_stats.total_checks);
+    info->fast_path_skips = atomic64_read(&hymo_stats.fast_path_skips);
+    info->bloom_rejects = atomic64_read(&hymo_stats.bloom_rejects);
+    info->rule_hits = atomic64_read(&hymo_stats.rule_hits);
+}
+EXPORT_SYMBOL(hymofs_get_perf_stats);
+#endif /* CONFIG_HYMOFS_STAT_SPOOF */
+
+#ifdef CONFIG_HYMOFS_STAT_SPOOF
+/* Post-process getattr results for stat spoofing */
+void hymofs_post_getattr(const struct path *path, struct inode *inode, 
+                         struct kstat *stat, int ret)
+{
+    if (ret != 0)
+        return;
+
+    /* HymoFS: Spoof timestamps if needed */
+    hymofs_spoof_stat(path, stat);
+    
+    /* Apply full kstat spoofing if configured for this inode */
+    if (hymofs_is_kstat_spoofed(inode)) {
+        hymofs_spoof_kstat_by_ino(inode->i_ino, stat);
+    }
+}
+EXPORT_SYMBOL(hymofs_post_getattr);
+#endif /* CONFIG_HYMOFS_STAT_SPOOF */
+
+#ifdef CONFIG_HYMOFS_REVERSE_LOOKUP
+/* Process d_path output for reverse lookup */
+char *hymofs_process_d_path(char *res, char *buf, int buflen)
+{
+	char *temp = NULL;
+	int len;
+
+	if (unlikely(!hymofs_enabled))
+		return res;
+
+	if (likely(hash_empty(hymo_targets)))
+		return res;
+
+	if (IS_ERR(res))
+		return res;
+
+	/* Allocate temporary buffer for reverse lookup */
+	temp = kmalloc(buflen, GFP_KERNEL);
+	if (!temp)
+		return res;
+
+	/* Try reverse lookup */
+	if (__hymofs_reverse_lookup(res, temp, buflen) == 0) {
+		len = strlen(temp);
+		/* Safety check: ensure we don't overflow the output buffer */
+		if (len < buflen) {
+			memcpy(buf, temp, len + 1); /* Copy including null terminator */
+			res = buf;
+		}
+	}
+	kfree(temp);
+	return res;
+}
+EXPORT_SYMBOL(hymofs_process_d_path);
+#endif /* CONFIG_HYMOFS_REVERSE_LOOKUP */
+
+#ifdef CONFIG_HYMOFS_UNAME_SPOOF
+
+/*
+ * ==================== uname Spoofing Implementation ====================
+ * Allows spoofing kernel version reported by uname()
+ */
+
+void hymofs_spoof_uname(struct new_utsname *name)
+{
+	pid_t current_pid;
+
+	if (!name)
+		return;
+
+	/* Allow daemon process to see real uname */
+	current_pid = task_tgid_vnr(current);
+	if (hymo_daemon_pid > 0 && current_pid == hymo_daemon_pid) {
+		return;
+	}
+
+	spin_lock(&hymo_uname_lock);
+	if (hymo_uname_info.sysname[0])
+		strscpy(name->sysname, hymo_uname_info.sysname, sizeof(name->sysname));
+	if (hymo_uname_info.nodename[0])
+		strscpy(name->nodename, hymo_uname_info.nodename, sizeof(name->nodename));
+	if (hymo_uname_info.release[0])
+		strscpy(name->release, hymo_uname_info.release, sizeof(name->release));
+	if (hymo_uname_info.version[0])
+		strscpy(name->version, hymo_uname_info.version, sizeof(name->version));
+	if (hymo_uname_info.machine[0])
+		strscpy(name->machine, hymo_uname_info.machine, sizeof(name->machine));
+	if (hymo_uname_info.domainname[0])
+		strscpy(name->domainname, hymo_uname_info.domainname, sizeof(name->domainname));
+	spin_unlock(&hymo_uname_lock);
+}
+EXPORT_SYMBOL(hymofs_spoof_uname);
+#endif /* CONFIG_HYMOFS_UNAME_SPOOF */
+
+#ifdef CONFIG_HYMOFS_CMDLINE_SPOOF
+
+/*
+ * ==================== cmdline Spoofing Implementation ====================
+ * Allows spoofing /proc/cmdline content
+ */
+
+static bool hymo_cmdline_spoofed = false;
+static char *hymo_fake_cmdline = NULL;
+
+bool hymofs_is_cmdline_spoofed(void)
+{
+    return hymo_cmdline_spoofed && hymo_fake_cmdline != NULL;
+}
+
+int hymofs_spoof_cmdline(struct seq_file *m)
+{
+    if (!hymo_cmdline_spoofed || !hymo_fake_cmdline)
+        return 1;  /* Return 1 to indicate "not spoofed, use original" */
+
+    /* Root sees real cmdline */
+    if (uid_eq(current_uid(), GLOBAL_ROOT_UID))
+        return 1;
+
+    seq_puts(m, hymo_fake_cmdline);
+    seq_putc(m, '\n');
+    hymo_log("cmdline: spoofed\n");
+    return 0;  /* Return 0 to indicate "spoofed successfully" */
+}
+EXPORT_SYMBOL(hymofs_spoof_cmdline);
+#endif /* CONFIG_HYMOFS_CMDLINE_SPOOF */
+
+#ifdef CONFIG_HYMOFS_XATTR_FILTER
+
+
+bool hymofs_is_overlay_xattr(struct dentry *dentry, const char *name)
+{
+    struct hymo_xattr_sb_entry *sb_entry;
+    bool found = false;
+
+    if (!name) return false;
+    if (strncmp(name, "trusted.overlay.", 16) != 0) return false;
+    
+    if (!dentry) return false;
+
+    rcu_read_lock();
+    hlist_for_each_entry_rcu(sb_entry, &hymo_xattr_sbs[hash_min((unsigned long)dentry->d_sb, HYMO_HASH_BITS)], node) {
+        if (sb_entry->sb == dentry->d_sb) {
+            found = true;
+            break;
+        }
+    }
+    rcu_read_unlock();
+    
+    return found;
+}
+EXPORT_SYMBOL(hymofs_is_overlay_xattr);
+
+ssize_t hymofs_filter_xattrs(struct dentry *dentry, char *klist, ssize_t len)
+{
+    struct hymo_xattr_sb_entry *sb_entry;
+    bool should_filter = false;
+    char *p = klist;
+    char *end = klist + len;
+    char *out = klist;
+    ssize_t new_len = 0;
+    
+    if (!dentry) return len;
+
+    rcu_read_lock();
+    hlist_for_each_entry_rcu(sb_entry, &hymo_xattr_sbs[hash_min((unsigned long)dentry->d_sb, HYMO_HASH_BITS)], node) {
+        if (sb_entry->sb == dentry->d_sb) {
+            should_filter = true;
+            break;
+        }
+    }
+    rcu_read_unlock();
+
+    if (!should_filter) return len;
+
+    while (p < end) {
+        size_t slen = strlen(p);
+        if (strncmp(p, "trusted.overlay.", 16) != 0) {
+            if (out != p)
+                memmove(out, p, slen + 1);
+            out += slen + 1;
+            new_len += slen + 1;
+        }
+        p += slen + 1;
+    }
+#endif /* CONFIG_HYMOFS_XATTR_FILTER */
+    return new_len;
+}
+EXPORT_SYMBOL(hymofs_filter_xattrs);
+
+#endif /* CONFIG_HYMOFS */
diff --git a/fs/namei.c b/fs/namei.c
index 8e9c0b567..5714547e6 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -44,6 +44,10 @@
 #include "internal.h"
 #include "mount.h"
 
+#ifdef CONFIG_HYMOFS
+#include <linux/hymofs.h>
+#endif
+
 /* [Feb-1997 T. Schoebel-Theuer]
  * Fundamental changes in the pathname lookup mechanisms (namei)
  * were necessary because of omirr.  The reason is that omirr needs
@@ -218,6 +222,21 @@ getname(const char __user * filename)
 	return getname_flags(filename, 0, NULL);
 }
 
+#ifdef CONFIG_HYMOFS_FORWARD_REDIRECT
+static inline struct filename *hymofs_getname(const char __user *filename)
+{
+	return hymofs_handle_getname(getname(filename));
+}
+
+static inline struct filename *hymofs_getname_uflags(const char __user *filename, int flags)
+{
+	return hymofs_handle_getname(getname_uflags(filename, flags));
+}
+#else
+#define hymofs_getname getname
+#define hymofs_getname_uflags getname_uflags
+#endif
+
 struct filename *
 getname_kernel(const char * filename)
 {
@@ -3806,6 +3825,7 @@ static struct file *path_openat(struct nameidata *nd,
 	return ERR_PTR(error);
 }
 
+
 struct file *do_filp_open(int dfd, struct filename *pathname,
 		const struct open_flags *op)
 {
@@ -4067,12 +4087,20 @@ static int do_mknodat(int dfd, struct filename *name, umode_t mode,
 SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode,
 		unsigned int, dev)
 {
-	return do_mknodat(dfd, getname(filename), mode, dev);
+	struct filename *name = hymofs_getname(filename);
+
+	if (IS_ERR(name))
+		return PTR_ERR(name);
+	return do_mknodat(dfd, name, mode, dev);
 }
 
 SYSCALL_DEFINE3(mknod, const char __user *, filename, umode_t, mode, unsigned, dev)
 {
-	return do_mknodat(AT_FDCWD, getname(filename), mode, dev);
+	struct filename *name = hymofs_getname(filename);
+
+	if (IS_ERR(name))
+		return PTR_ERR(name);
+	return do_mknodat(AT_FDCWD, name, mode, dev);
 }
 
 /**
@@ -4150,12 +4178,20 @@ int do_mkdirat(int dfd, struct filename *name, umode_t mode)
 
 SYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode)
 {
-	return do_mkdirat(dfd, getname(pathname), mode);
+	struct filename *name = hymofs_getname(pathname);
+
+	if (IS_ERR(name))
+		return PTR_ERR(name);
+	return do_mkdirat(dfd, name, mode);
 }
 
 SYSCALL_DEFINE2(mkdir, const char __user *, pathname, umode_t, mode)
 {
-	return do_mkdirat(AT_FDCWD, getname(pathname), mode);
+	struct filename *name = hymofs_getname(pathname);
+
+	if (IS_ERR(name))
+		return PTR_ERR(name);
+	return do_mkdirat(AT_FDCWD, name, mode);
 }
 
 /**
@@ -4275,7 +4311,11 @@ int do_rmdir(int dfd, struct filename *name)
 
 SYSCALL_DEFINE1(rmdir, const char __user *, pathname)
 {
-	return do_rmdir(AT_FDCWD, getname(pathname));
+	struct filename *name = hymofs_getname(pathname);
+
+	if (IS_ERR(name))
+		return PTR_ERR(name);
+	return do_rmdir(AT_FDCWD, name);
 }
 
 /**
@@ -4432,17 +4472,27 @@ int do_unlinkat(int dfd, struct filename *name)
 
 SYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)
 {
+	struct filename *name;
+
 	if ((flag & ~AT_REMOVEDIR) != 0)
 		return -EINVAL;
 
+	name = hymofs_getname(pathname);
+	if (IS_ERR(name))
+		return PTR_ERR(name);
+
 	if (flag & AT_REMOVEDIR)
-		return do_rmdir(dfd, getname(pathname));
-	return do_unlinkat(dfd, getname(pathname));
+		return do_rmdir(dfd, name);
+	return do_unlinkat(dfd, name);
 }
 
 SYSCALL_DEFINE1(unlink, const char __user *, pathname)
 {
-	return do_unlinkat(AT_FDCWD, getname(pathname));
+	struct filename *name = hymofs_getname(pathname);
+
+	if (IS_ERR(name))
+		return PTR_ERR(name);
+	return do_unlinkat(AT_FDCWD, name);
 }
 
 /**
@@ -4521,12 +4571,36 @@ int do_symlinkat(struct filename *from, int newdfd, struct filename *to)
 SYSCALL_DEFINE3(symlinkat, const char __user *, oldname,
 		int, newdfd, const char __user *, newname)
 {
-	return do_symlinkat(getname(oldname), newdfd, getname(newname));
+	struct filename *from = hymofs_getname(oldname);
+	struct filename *to;
+
+	if (IS_ERR(from))
+		return PTR_ERR(from);
+
+	to = hymofs_getname(newname);
+	if (IS_ERR(to)) {
+		putname(from);
+		return PTR_ERR(to);
+	}
+
+	return do_symlinkat(from, newdfd, to);
 }
 
 SYSCALL_DEFINE2(symlink, const char __user *, oldname, const char __user *, newname)
 {
-	return do_symlinkat(getname(oldname), AT_FDCWD, getname(newname));
+	struct filename *from = hymofs_getname(oldname);
+	struct filename *to;
+
+	if (IS_ERR(from))
+		return PTR_ERR(from);
+
+	to = hymofs_getname(newname);
+	if (IS_ERR(to)) {
+		putname(from);
+		return PTR_ERR(to);
+	}
+
+	return do_symlinkat(from, AT_FDCWD, to);
 }
 
 /**
@@ -4702,13 +4776,36 @@ int do_linkat(int olddfd, struct filename *old, int newdfd,
 SYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,
 		int, newdfd, const char __user *, newname, int, flags)
 {
-	return do_linkat(olddfd, getname_uflags(oldname, flags),
-		newdfd, getname(newname), flags);
+	struct filename *old = hymofs_getname_uflags(oldname, flags);
+	struct filename *new;
+
+	if (IS_ERR(old))
+		return PTR_ERR(old);
+
+	new = hymofs_getname(newname);
+	if (IS_ERR(new)) {
+		putname(old);
+		return PTR_ERR(new);
+	}
+
+	return do_linkat(olddfd, old, newdfd, new, flags);
 }
 
 SYSCALL_DEFINE2(link, const char __user *, oldname, const char __user *, newname)
 {
-	return do_linkat(AT_FDCWD, getname(oldname), AT_FDCWD, getname(newname), 0);
+	struct filename *old = hymofs_getname(oldname);
+	struct filename *new;
+
+	if (IS_ERR(old))
+		return PTR_ERR(old);
+
+	new = hymofs_getname(newname);
+	if (IS_ERR(new)) {
+		putname(old);
+		return PTR_ERR(new);
+	}
+
+	return do_linkat(AT_FDCWD, old, AT_FDCWD, new, 0);
 }
 
 /**
@@ -5064,21 +5161,54 @@ int do_renameat2(int olddfd, struct filename *from, int newdfd,
 SYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname,
 		int, newdfd, const char __user *, newname, unsigned int, flags)
 {
-	return do_renameat2(olddfd, getname(oldname), newdfd, getname(newname),
-				flags);
+	struct filename *from = hymofs_getname(oldname);
+	struct filename *to;
+
+	if (IS_ERR(from))
+		return PTR_ERR(from);
+
+	to = hymofs_getname(newname);
+	if (IS_ERR(to)) {
+		putname(from);
+		return PTR_ERR(to);
+	}
+
+	return do_renameat2(olddfd, from, newdfd, to, flags);
 }
 
 SYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname,
 		int, newdfd, const char __user *, newname)
 {
-	return do_renameat2(olddfd, getname(oldname), newdfd, getname(newname),
-				0);
+	struct filename *from = hymofs_getname(oldname);
+	struct filename *to;
+
+	if (IS_ERR(from))
+		return PTR_ERR(from);
+
+	to = hymofs_getname(newname);
+	if (IS_ERR(to)) {
+		putname(from);
+		return PTR_ERR(to);
+	}
+
+	return do_renameat2(olddfd, from, newdfd, to, 0);
 }
 
 SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
 {
-	return do_renameat2(AT_FDCWD, getname(oldname), AT_FDCWD,
-				getname(newname), 0);
+	struct filename *from = hymofs_getname(oldname);
+	struct filename *to;
+
+	if (IS_ERR(from))
+		return PTR_ERR(from);
+
+	to = hymofs_getname(newname);
+	if (IS_ERR(to)) {
+		putname(from);
+		return PTR_ERR(to);
+	}
+
+	return do_renameat2(AT_FDCWD, from, AT_FDCWD, to, 0);
 }
 
 int readlink_copy(char __user *buffer, int buflen, const char *link)
diff --git a/fs/open.c b/fs/open.c
index 82d10b7a5..6580078dc 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -37,6 +37,10 @@
 #include "internal.h"
 #include <trace/hooks/syscall_check.h>
 
+#ifdef CONFIG_HYMOFS_FORWARD_REDIRECT
+extern struct filename *hymofs_handle_getname(struct filename *result);
+#endif
+
 int do_truncate(struct user_namespace *mnt_userns, struct dentry *dentry,
 		loff_t length, unsigned int time_attrs, struct file *filp)
 {
@@ -1338,6 +1342,12 @@ static long do_sys_openat2(int dfd, const char __user *filename,
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
 
+#ifdef CONFIG_HYMOFS_FORWARD_REDIRECT
+	tmp = hymofs_handle_getname(tmp);
+	if (IS_ERR(tmp))
+		return PTR_ERR(tmp);
+#endif
+
 	fd = get_unused_fd_flags(how->flags);
 	if (fd >= 0) {
 		struct file *f = do_filp_open(dfd, tmp, &op);
diff --git a/fs/readdir.c b/fs/readdir.c
index 9c53edb60..8fd2147f9 100644
--- a/fs/readdir.c
+++ b/fs/readdir.c
@@ -24,6 +24,10 @@
 
 #include <asm/unaligned.h>
 
+#ifdef CONFIG_HYMOFS
+#include <linux/hymofs.h>
+#endif
+
 /*
  * Note the "unsafe_put_user() semantics: we goto a
  * label for errors.
@@ -136,6 +140,9 @@ struct old_linux_dirent {
 
 struct readdir_callback {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct hymo_readdir_context hymo;
+#endif
 	struct old_linux_dirent __user * dirent;
 	int result;
 };
@@ -189,11 +196,17 @@ SYSCALL_DEFINE3(old_readdir, unsigned int, fd,
 
 	if (!f.file)
 		return -EBADF;
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_prepare_readdir(&buf.hymo, f.file);
+#endif
 
 	error = iterate_dir(f.file, &buf.ctx);
 	if (buf.result)
 		error = buf.result;
 
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_cleanup_readdir(&buf.hymo);
+#endif
 	fdput_pos(f);
 	return error;
 }
@@ -213,10 +226,16 @@ struct linux_dirent {
 
 struct getdents_callback {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct hymo_readdir_context hymo;
+#endif
 	struct linux_dirent __user * current_dir;
 	int prev_reclen;
 	int count;
 	int error;
+#ifdef CONFIG_HYMOFS
+	bool buffer_full;
+#endif
 };
 
 static bool filldir(struct dir_context *ctx, const char *name, int namlen,
@@ -230,12 +249,21 @@ static bool filldir(struct dir_context *ctx, const char *name, int namlen,
 		sizeof(long));
 	int prev_reclen;
 
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+    if (hymofs_check_filldir(&buf->hymo, name, strlen(name))) return true;
+#endif
+
+
 	buf->error = verify_dirent_name(name, namlen);
 	if (unlikely(buf->error))
 		return false;
 	buf->error = -EINVAL;	/* only used if we fail.. */
-	if (reclen > buf->count)
+	if (reclen > buf->count) {
+#ifdef CONFIG_HYMOFS
+		buf->buffer_full = true;
+#endif
 		return false;
+	}
 	d_ino = ino;
 	if (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {
 		buf->error = -EOVERFLOW;
@@ -276,12 +304,33 @@ SYSCALL_DEFINE3(getdents, unsigned int, fd,
 		.ctx.actor = filldir,
 		.count = count,
 		.current_dir = dirent
+#ifdef CONFIG_HYMOFS
+		, .buffer_full = false
+#endif
 	};
 	int error;
 
 	f = fdget_pos(fd);
 	if (!f.file)
 		return -EBADF;
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_prepare_readdir(&buf.hymo, f.file);
+#endif
+#ifdef CONFIG_HYMOFS_INJECT_ENTRIES
+	if (f.file->f_pos >= HYMO_MAGIC_POS) {
+		void __user *dir_ptr = buf.current_dir;
+		int res = hymofs_inject_entries(&buf.hymo, &dir_ptr, &buf.count, &f.file->f_pos);
+		if (res >= 0)
+			error = count - buf.count;
+		else
+			error = res;
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+		hymofs_cleanup_readdir(&buf.hymo);
+#endif
+		fdput_pos(f);
+		return error;
+	}
+#endif
 
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
@@ -295,16 +344,33 @@ SYSCALL_DEFINE3(getdents, unsigned int, fd,
 		else
 			error = count - buf.count;
 	}
+#ifdef CONFIG_HYMOFS_INJECT_ENTRIES
+	if (error >= 0 && !buf.buffer_full && buf.ctx.pos < HYMO_MAGIC_POS && !signal_pending(current)) {
+		void __user *dir_ptr = buf.current_dir;
+		int res = hymofs_inject_entries(&buf.hymo, &dir_ptr, &buf.count, &f.file->f_pos);
+		if (res > 0)
+			error = count - buf.count;
+	}
+#endif
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_cleanup_readdir(&buf.hymo);
+#endif
 	fdput_pos(f);
 	return error;
 }
 
 struct getdents_callback64 {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct hymo_readdir_context hymo;
+#endif
 	struct linux_dirent64 __user * current_dir;
 	int prev_reclen;
 	int count;
 	int error;
+#ifdef CONFIG_HYMOFS
+	bool buffer_full;
+#endif
 };
 
 static bool filldir64(struct dir_context *ctx, const char *name, int namlen,
@@ -317,15 +383,25 @@ static bool filldir64(struct dir_context *ctx, const char *name, int namlen,
 		sizeof(u64));
 	int prev_reclen;
 
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	if (hymofs_check_filldir(&buf->hymo, name, namlen)) return true;
+#endif
+
+
 	buf->error = verify_dirent_name(name, namlen);
 	if (unlikely(buf->error))
 		return false;
 	buf->error = -EINVAL;	/* only used if we fail.. */
-	if (reclen > buf->count)
+	if (reclen > buf->count) {
+#ifdef CONFIG_HYMOFS
+		buf->buffer_full = true;
+#endif
 		return false;
+	}
 	prev_reclen = buf->prev_reclen;
 	if (prev_reclen && signal_pending(current))
 		return false;
+
 	dirent = buf->current_dir;
 	prev = (void __user *)dirent - prev_reclen;
 	if (!user_write_access_begin(prev, reclen + prev_reclen))
@@ -359,6 +435,9 @@ SYSCALL_DEFINE3(getdents64, unsigned int, fd,
 		.ctx.actor = filldir64,
 		.count = count,
 		.current_dir = dirent
+#ifdef CONFIG_HYMOFS
+		, .buffer_full = false
+#endif
 	};
 	int error;
 
@@ -366,6 +445,25 @@ SYSCALL_DEFINE3(getdents64, unsigned int, fd,
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_prepare_readdir(&buf.hymo, f.file);
+#endif
+#ifdef CONFIG_HYMOFS_INJECT_ENTRIES
+	if (f.file->f_pos >= HYMO_MAGIC_POS) {
+		void __user *dir_ptr = buf.current_dir;
+		int res = hymofs_inject_entries64(&buf.hymo, &dir_ptr, &buf.count, &f.file->f_pos);
+		if (res >= 0)
+			error = count - buf.count;
+		else
+			error = res;
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+		hymofs_cleanup_readdir(&buf.hymo);
+#endif
+		fdput_pos(f);
+		return error;
+	}
+#endif
+
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
@@ -379,6 +477,17 @@ SYSCALL_DEFINE3(getdents64, unsigned int, fd,
 		else
 			error = count - buf.count;
 	}
+#ifdef CONFIG_HYMOFS_INJECT_ENTRIES
+	if (error >= 0 && !buf.buffer_full && buf.ctx.pos < HYMO_MAGIC_POS && !signal_pending(current)) {
+		void __user *dir_ptr = buf.current_dir;
+		int res = hymofs_inject_entries64(&buf.hymo, &dir_ptr, &buf.count, &f.file->f_pos);
+		if (res > 0)
+			error = count - buf.count;
+	}
+#endif
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_cleanup_readdir(&buf.hymo);
+#endif
 	fdput_pos(f);
 	return error;
 }
@@ -393,6 +502,9 @@ struct compat_old_linux_dirent {
 
 struct compat_readdir_callback {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct hymo_readdir_context hymo;
+#endif
 	struct compat_old_linux_dirent __user *dirent;
 	int result;
 };
@@ -448,10 +560,17 @@ COMPAT_SYSCALL_DEFINE3(old_readdir, unsigned int, fd,
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_prepare_readdir(&buf.hymo, f.file);
+#endif
+
 	error = iterate_dir(f.file, &buf.ctx);
 	if (buf.result)
 		error = buf.result;
 
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_cleanup_readdir(&buf.hymo);
+#endif
 	fdput_pos(f);
 	return error;
 }
@@ -465,6 +584,9 @@ struct compat_linux_dirent {
 
 struct compat_getdents_callback {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct hymo_readdir_context hymo;
+#endif
 	struct compat_linux_dirent __user *current_dir;
 	int prev_reclen;
 	int count;
@@ -482,6 +604,10 @@ static bool compat_filldir(struct dir_context *ctx, const char *name, int namlen
 		namlen + 2, sizeof(compat_long_t));
 	int prev_reclen;
 
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+    if (hymofs_check_filldir(&buf->hymo, name, namlen)) return true;
+#endif
+
 	buf->error = verify_dirent_name(name, namlen);
 	if (unlikely(buf->error))
 		return false;
@@ -534,6 +660,10 @@ COMPAT_SYSCALL_DEFINE3(getdents, unsigned int, fd,
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_prepare_readdir(&buf.hymo, f.file);
+#endif
+
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
@@ -546,6 +676,9 @@ COMPAT_SYSCALL_DEFINE3(getdents, unsigned int, fd,
 		else
 			error = count - buf.count;
 	}
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+	hymofs_cleanup_readdir(&buf.hymo);
+#endif
 	fdput_pos(f);
 	return error;
 }
diff --git a/fs/stat.c b/fs/stat.c
index ef50573c7..5df31f44c 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -25,6 +25,10 @@
 #include "internal.h"
 #include "mount.h"
 
+#ifdef CONFIG_HYMOFS
+#include <linux/hymofs.h>
+#endif
+
 /**
  * generic_fillattr - Fill in the basic attributes from the inode struct
  * @mnt_userns:	user namespace of the mount the inode was found from
@@ -220,6 +224,9 @@ static int vfs_statx(int dfd, struct filename *filename, int flags,
 	struct path path;
 	unsigned int lookup_flags = getname_statx_lookup_flags(flags);
 	int error;
+#ifdef CONFIG_HYMOFS
+	struct filename *hymo_filename = NULL;
+#endif
 
 	if (flags & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT | AT_EMPTY_PATH |
 		      AT_STATX_SYNC_TYPE))
@@ -227,6 +234,15 @@ static int vfs_statx(int dfd, struct filename *filename, int flags,
 
 retry:
 	error = filename_lookup(dfd, filename, lookup_flags, &path, NULL);
+	
+#ifdef CONFIG_HYMOFS_FORWARD_REDIRECT
+	/* HymoFS: Handle merge directory - relative path + dirfd case */
+	if (error == -ENOENT && dfd >= 0 && filename->name[0] != '/') {
+		hymo_filename = hymofs_resolve_relative(dfd, filename->name);
+		if (hymo_filename)
+			error = filename_lookup(AT_FDCWD, hymo_filename, lookup_flags, &path, NULL);
+	}
+#endif
 	if (error)
 		goto out;
 
@@ -253,6 +269,10 @@ static int vfs_statx(int dfd, struct filename *filename, int flags,
 		goto retry;
 	}
 out:
+#ifdef CONFIG_HYMOFS
+	if (hymo_filename)
+		putname(hymo_filename);
+#endif
 	return error;
 }
 
diff --git a/fs/xattr.c b/fs/xattr.c
index 427b8cea1..c658ebc6d 100644
--- a/fs/xattr.c
+++ b/fs/xattr.c
@@ -24,6 +24,9 @@
 #include <linux/posix_acl_xattr.h>
 
 #include <linux/uaccess.h>
+#ifdef CONFIG_HYMOFS
+#include <linux/hymofs.h>
+#endif
 
 #include "internal.h"
 
@@ -688,6 +691,10 @@ do_getxattr(struct user_namespace *mnt_userns, struct dentry *d,
 {
 	ssize_t error;
 	char *kname = ctx->kname->name;
+#ifdef CONFIG_HYMOFS_XATTR_FILTER
+	if (hymofs_is_overlay_xattr(d, kname))
+		return -ENODATA;
+#endif
 
 	if (ctx->size) {
 		if (ctx->size > XATTR_SIZE_MAX)
@@ -793,6 +800,37 @@ listxattr(struct dentry *d, char __user *list, size_t size)
 	ssize_t error;
 	char *klist = NULL;
 
+#ifdef CONFIG_HYMOFS
+	size_t alloc_size = size;
+
+	if (!size) {
+		ssize_t res = vfs_listxattr(d, NULL, 0);
+		if (res <= 0)
+			return res;
+		alloc_size = res;
+	}
+
+	if (alloc_size > XATTR_LIST_MAX)
+		alloc_size = XATTR_LIST_MAX;
+
+	klist = kvmalloc(alloc_size, GFP_KERNEL);
+	if (!klist)
+		return -ENOMEM;
+
+	error = vfs_listxattr(d, klist, alloc_size);
+	if (error > 0) {
+#ifdef CONFIG_HYMOFS_XATTR_FILTER
+		error = hymofs_filter_xattrs(d, klist, error);
+#endif
+
+		if (size && copy_to_user(list, klist, error))
+			error = -EFAULT;
+	} else if (error == -ERANGE && size >= XATTR_LIST_MAX) {
+		/* The file system tried to returned a list bigger
+		   than XATTR_LIST_MAX bytes. Not possible. */
+		error = -E2BIG;
+	}
+#else
 	if (size) {
 		if (size > XATTR_LIST_MAX)
 			size = XATTR_LIST_MAX;
@@ -810,6 +848,7 @@ listxattr(struct dentry *d, char __user *list, size_t size)
 		   than XATTR_LIST_MAX bytes. Not possible. */
 		error = -E2BIG;
 	}
+#endif
 
 	kvfree(klist);
 
diff --git a/include/linux/hymo_magic.h b/include/linux/hymo_magic.h
new file mode 100644
index 000000000..12fb6302c
--- /dev/null
+++ b/include/linux/hymo_magic.h
@@ -0,0 +1,134 @@
+#ifndef _LINUX_HYMO_MAGIC_H
+#define _LINUX_HYMO_MAGIC_H
+
+#ifdef __KERNEL__
+#include <linux/ioctl.h>
+#include <linux/types.h>
+#include <linux/bits.h>
+#else
+#include <sys/ioctl.h>
+#include <stddef.h>
+#include <stdint.h>
+#endif // #ifdef __KERNEL__
+
+#define HYMO_MAGIC1 0x48594D4F  // "HYMO"
+#define HYMO_MAGIC2 0x524F4F54  // "ROOT"
+#define HYMO_PROTOCOL_VERSION 12
+
+#define HYMO_MAX_LEN_PATHNAME 256
+#define HYMO_FAKE_CMDLINE_SIZE 4096
+
+/*
+ * HymoFS inode marking bits (stored in inode->i_mapping->flags)
+ * Using high bits to avoid conflict with kernel AS_* flags and SUSFS bits
+ * SUSFS uses bits 33-39, we use 40+
+ */
+#ifdef __KERNEL__
+#define AS_FLAGS_HYMO_HIDE 40
+#define BIT_HYMO_HIDE BIT(40)
+/* Marks a directory as containing hidden entries (for fast filldir skip) */
+#define AS_FLAGS_HYMO_DIR_HAS_HIDDEN 41
+#define BIT_HYMO_DIR_HAS_HIDDEN BIT(41)
+/* Marks an inode for kstat spoofing */
+#define AS_FLAGS_HYMO_SPOOF_KSTAT 42
+#define BIT_HYMO_SPOOF_KSTAT BIT(42)
+#endif // #ifdef __KERNEL__
+
+// Only one syscall command: Get anonymous FD
+#define HYMO_CMD_GET_FD 0x48021
+
+struct hymo_syscall_arg {
+    const char *src;
+    const char *target;
+    int type;
+};
+
+struct hymo_syscall_list_arg {
+    char *buf;  // Keep as char* for output buffer
+    size_t size;
+};
+
+struct hymo_uid_list_arg {
+    __u32 count;
+    __u32 reserved;
+    __aligned_u64 uids;
+};
+
+/* 
+ * kstat spoofing structure - allows full control over stat() results
+ * Similar to susfs sus_kstat but with HymoFS conventions
+ */
+struct hymo_spoof_kstat {
+    unsigned long target_ino;                           /* Target inode number (after mount/overlay) */
+    char target_pathname[HYMO_MAX_LEN_PATHNAME];        /* Path to spoof */
+    unsigned long spoofed_ino;                          /* Spoofed inode number */
+    unsigned long spoofed_dev;                          /* Spoofed device number */
+    unsigned int spoofed_nlink;                         /* Spoofed link count */
+    long long spoofed_size;                             /* Spoofed file size */
+    long spoofed_atime_sec;                             /* Spoofed access time (seconds) */
+    long spoofed_atime_nsec;                            /* Spoofed access time (nanoseconds) */
+    long spoofed_mtime_sec;                             /* Spoofed modification time (seconds) */
+    long spoofed_mtime_nsec;                            /* Spoofed modification time (nanoseconds) */
+    long spoofed_ctime_sec;                             /* Spoofed change time (seconds) */
+    long spoofed_ctime_nsec;                            /* Spoofed change time (nanoseconds) */
+    unsigned long spoofed_blksize;                      /* Spoofed block size */
+    unsigned long long spoofed_blocks;                  /* Spoofed block count */
+    int is_static;                                      /* If true, ino won't change after remount */
+    int err;                                            /* Error code for userspace feedback */
+};
+
+/*
+ * uname spoofing structure - spoof kernel version info
+ */
+#define HYMO_UNAME_LEN 65
+struct hymo_spoof_uname {
+    char sysname[HYMO_UNAME_LEN];                       
+    char nodename[HYMO_UNAME_LEN];                      
+    char release[HYMO_UNAME_LEN];                       /* e.g., "5.15.0-generic" */
+    char version[HYMO_UNAME_LEN];                       /* e.g., "#1 SMP PREEMPT ..." */
+    char machine[HYMO_UNAME_LEN];                       
+    char domainname[HYMO_UNAME_LEN];                    
+    int err;
+};
+
+/*
+ * cmdline spoofing structure - spoof /proc/cmdline
+ */
+struct hymo_spoof_cmdline {
+    char cmdline[HYMO_FAKE_CMDLINE_SIZE];               /* Fake cmdline content */
+    int err;
+};
+
+/*
+ * Feature flags for HYMO_CMD_GET_FEATURES
+ */
+#define HYMO_FEATURE_KSTAT_SPOOF    (1 << 0)
+#define HYMO_FEATURE_UNAME_SPOOF    (1 << 1)
+#define HYMO_FEATURE_CMDLINE_SPOOF  (1 << 2)
+#define HYMO_FEATURE_SELINUX_BYPASS (1 << 4)
+#define HYMO_FEATURE_MERGE_DIR      (1 << 5)
+
+// ioctl definitions (for fd-based mode)
+// Must be after struct definitions
+#define HYMO_IOC_MAGIC 'H'
+#define HYMO_IOC_ADD_RULE           _IOW(HYMO_IOC_MAGIC, 1, struct hymo_syscall_arg)
+#define HYMO_IOC_DEL_RULE           _IOW(HYMO_IOC_MAGIC, 2, struct hymo_syscall_arg)
+#define HYMO_IOC_HIDE_RULE          _IOW(HYMO_IOC_MAGIC, 3, struct hymo_syscall_arg)
+#define HYMO_IOC_CLEAR_ALL          _IO(HYMO_IOC_MAGIC, 5)
+#define HYMO_IOC_GET_VERSION        _IOR(HYMO_IOC_MAGIC, 6, int)
+#define HYMO_IOC_LIST_RULES         _IOWR(HYMO_IOC_MAGIC, 7, struct hymo_syscall_list_arg)
+#define HYMO_IOC_SET_DEBUG          _IOW(HYMO_IOC_MAGIC, 8, int)
+#define HYMO_IOC_REORDER_MNT_ID     _IO(HYMO_IOC_MAGIC, 9)
+#define HYMO_IOC_SET_STEALTH        _IOW(HYMO_IOC_MAGIC, 10, int)
+#define HYMO_IOC_HIDE_OVERLAY_XATTRS _IOW(HYMO_IOC_MAGIC, 11, struct hymo_syscall_arg)
+#define HYMO_IOC_ADD_MERGE_RULE     _IOW(HYMO_IOC_MAGIC, 12, struct hymo_syscall_arg)
+#define HYMO_IOC_SET_MIRROR_PATH    _IOW(HYMO_IOC_MAGIC, 14, struct hymo_syscall_arg)
+#define HYMO_IOC_ADD_SPOOF_KSTAT    _IOW(HYMO_IOC_MAGIC, 15, struct hymo_spoof_kstat)
+#define HYMO_IOC_UPDATE_SPOOF_KSTAT _IOW(HYMO_IOC_MAGIC, 16, struct hymo_spoof_kstat)
+#define HYMO_IOC_SET_UNAME          _IOW(HYMO_IOC_MAGIC, 17, struct hymo_spoof_uname)
+#define HYMO_IOC_SET_CMDLINE        _IOW(HYMO_IOC_MAGIC, 18, struct hymo_spoof_cmdline)
+#define HYMO_IOC_GET_FEATURES       _IOR(HYMO_IOC_MAGIC, 19, int)
+#define HYMO_IOC_SET_ENABLED        _IOW(HYMO_IOC_MAGIC, 20, int)
+#define HYMO_IOC_SET_HIDE_UIDS      _IOW(HYMO_IOC_MAGIC, 21, struct hymo_uid_list_arg)
+
+#endif /* _LINUX_HYMO_MAGIC_H */
\ No newline at end of file
diff --git a/include/linux/hymofs.h b/include/linux/hymofs.h
new file mode 100644
index 000000000..300332fba
--- /dev/null
+++ b/include/linux/hymofs.h
@@ -0,0 +1,274 @@
+#ifndef _LINUX_HYMOFS_H
+#define _LINUX_HYMOFS_H
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/atomic.h>
+#include <linux/kernel.h> /* For system_state */
+#include <linux/thread_info.h> /* For thread_info flags */
+#include <linux/sched.h> /* For current */
+
+#ifdef CONFIG_HYMOFS
+
+#define HYMO_MAGIC_POS 0x7000000000000000ULL
+
+#define HYMO_DEFAULT_MIRROR_NAME "hymo_mirror"
+#define HYMO_DEFAULT_MIRROR_PATH "/dev/" HYMO_DEFAULT_MIRROR_NAME
+
+/* Internal command definitions (not exposed to userspace, used within hymo_dispatch_cmd) */
+#define HYMO_CMD_CLEAR_ALL          100
+#define HYMO_CMD_GET_VERSION        101
+#define HYMO_CMD_SET_DEBUG          102
+#define HYMO_CMD_REORDER_MNT_ID     103
+#define HYMO_CMD_SET_STEALTH        104
+#define HYMO_CMD_SET_ENABLED        105
+#define HYMO_CMD_LIST_RULES         106
+#define HYMO_CMD_SET_MIRROR_PATH    107
+#define HYMO_CMD_ADD_MERGE_RULE     108
+#define HYMO_CMD_ADD_RULE           109
+#define HYMO_CMD_HIDE_RULE          110
+#define HYMO_CMD_HIDE_OVERLAY_XATTRS 111
+#define HYMO_CMD_DEL_RULE           112
+#define HYMO_CMD_SET_UNAME          115
+
+struct hymo_merge_target_node {
+    struct list_head list;
+    char *target;
+    struct dentry *target_dentry;  /* Cached dentry for fast lookup */
+};
+
+/* Bloom filter for merge target filenames - ultra fast O(1) check */
+#define HYMO_BLOOM_BITS 10  /* 1024 bits = 128 bytes */
+#define HYMO_BLOOM_SIZE (1 << HYMO_BLOOM_BITS)
+#define HYMO_BLOOM_MASK (HYMO_BLOOM_SIZE - 1)
+
+/* Hash table for merge target filenames - O(1) lookup */
+#define HYMO_MERGE_HASH_BITS 6
+#define HYMO_MERGE_HASH_SIZE (1 << HYMO_MERGE_HASH_BITS)
+
+struct hymo_merge_file_entry {
+    struct hlist_node node;
+    char *name;
+    int namlen;
+};
+
+struct hymo_readdir_context {
+    struct file *file;
+    char *path_buf;
+    char *dir_path;
+    int dir_path_len;
+    bool entry_written;
+    struct list_head merge_targets;
+    bool is_replace_mode;
+    bool dir_has_hidden;  /* Fast path: skip hide check if false */
+    bool has_merge_files; /* Fast path: skip merge check if false */
+    unsigned long bloom_filter[HYMO_BLOOM_SIZE / BITS_PER_LONG]; /* Bloom filter for merge filenames */
+    struct hlist_head merge_files[HYMO_MERGE_HASH_SIZE]; /* Pre-built hash of merge target filenames */
+};
+
+extern bool hymofs_enabled;
+
+/* Syscall hook for legacy mode */
+extern int (*hymo_dispatch_cmd_hook)(unsigned int cmd, void __user *arg);
+
+/* ========== Directory entry hiding/injection ========== */
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+void __hymofs_prepare_readdir(struct hymo_readdir_context *ctx, struct file *file);
+void __hymofs_cleanup_readdir(struct hymo_readdir_context *ctx);
+bool __hymofs_check_filldir(struct hymo_readdir_context *ctx, const char *name, int namlen);
+#endif
+
+#ifdef CONFIG_HYMOFS_INJECT_ENTRIES
+int hymofs_inject_entries(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos);
+int hymofs_inject_entries64(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos);
+#endif
+
+/* ========== Stat spoofing ========== */
+#ifdef CONFIG_HYMOFS_STAT_SPOOF
+void hymofs_spoof_stat(const struct path *path, struct kstat *stat);
+void hymofs_spoof_kstat_by_ino(unsigned long ino, struct kstat *stat);
+bool hymofs_is_kstat_spoofed(struct inode *inode);
+void hymofs_post_getattr(const struct path *path, struct inode *inode, 
+                         struct kstat *stat, int ret);
+#endif
+
+/* ========== Extended attributes filtering ========== */
+#ifdef CONFIG_HYMOFS_XATTR_FILTER
+ssize_t hymofs_filter_xattrs(struct dentry *dentry, char *klist, ssize_t len);
+bool hymofs_is_overlay_xattr(struct dentry *dentry, const char *name);
+#endif
+
+/* ========== Uname spoofing ========== */
+#ifdef CONFIG_HYMOFS_UNAME_SPOOF
+struct new_utsname;
+void hymofs_spoof_uname(struct new_utsname *name);
+#endif
+
+/* ========== Cmdline spoofing ========== */
+#ifdef CONFIG_HYMOFS_CMDLINE_SPOOF
+struct seq_file;
+int hymofs_spoof_cmdline(struct seq_file *m);
+bool hymofs_is_cmdline_spoofed(void);
+#endif
+
+struct hymo_name_list {
+    char *name;
+    unsigned char type;
+    struct list_head list;
+};
+
+/* Performance information structure */
+struct hymofs_perf_info {
+    u64 total_checks;
+    u64 fast_path_skips;
+    u64 bloom_rejects;
+    u64 rule_hits;
+};
+
+/* ========== Forward redirection (namei) ========== */
+#ifdef CONFIG_HYMOFS_FORWARD_REDIRECT
+struct filename;
+struct filename *hymofs_handle_getname(struct filename *result);
+struct filename *hymofs_resolve_relative(int dfd, const char *name);
+char *__hymofs_resolve_target(const char *pathname);
+#endif
+
+/* ========== Reverse lookup (d_path) ========== */
+#ifdef CONFIG_HYMOFS_REVERSE_LOOKUP
+int __hymofs_reverse_lookup(const char *pathname, char *buf, size_t buflen);
+char *hymofs_process_d_path(char *res, char *buf, int buflen);
+#endif
+
+/* ========== Path hiding ========== */
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+bool __hymofs_should_hide(const char *pathname, size_t len);
+bool __hymofs_should_spoof_mtime(const char *pathname);
+int hymofs_populate_injected_list(const char *dir_path, struct dentry *parent, struct list_head *head);
+bool __hymofs_is_inode_hidden(struct inode *inode);
+#endif
+
+/* 
+ * Inline wrapper with fast-path checks
+ * 
+ * HymoFS design: Only privileged processes are marked
+ * Default (unmarked) = hidden, Marked = can see everything
+ */
+static __always_inline bool hymofs_is_inode_hidden(struct inode *inode)
+{
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+    /* Fast path: NULL checks */
+    if (unlikely(!inode || !inode->i_mapping))
+        return false;
+    
+    /* Fast path: Root sees everything */
+    if (uid_eq(current_uid(), GLOBAL_ROOT_UID))
+        return false;
+    
+    /* Fast path: No rules loaded */
+    if (!hymofs_enabled)
+        return false;
+    
+    return __hymofs_is_inode_hidden(inode);
+#else
+    return false;
+#endif
+}
+
+static inline void hymofs_prepare_readdir(struct hymo_readdir_context *ctx, struct file *file)
+{
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+    ctx->path_buf = NULL;
+    ctx->file = file;
+    if (!hymofs_enabled) return;
+    __hymofs_prepare_readdir(ctx, file);
+#endif
+}
+
+static inline void hymofs_cleanup_readdir(struct hymo_readdir_context *ctx)
+{
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+    if (ctx->path_buf) __hymofs_cleanup_readdir(ctx);
+#endif
+}
+
+static inline bool hymofs_check_filldir(struct hymo_readdir_context *ctx, const char *name, int namlen)
+{
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+    if (!ctx->path_buf) return false;
+    return __hymofs_check_filldir(ctx, name, namlen);
+#else
+    return false;
+#endif
+}
+
+static inline char *hymofs_resolve_target(const char *pathname)
+{
+#ifdef CONFIG_HYMOFS_FORWARD_REDIRECT
+    if (!hymofs_enabled) return NULL;
+    return __hymofs_resolve_target(pathname);
+#else
+    return NULL;
+#endif
+}
+
+static inline int hymofs_reverse_lookup(const char *pathname, char *buf, size_t buflen)
+{
+#ifdef CONFIG_HYMOFS_REVERSE_LOOKUP
+    if (!hymofs_enabled) return -1;
+    return __hymofs_reverse_lookup(pathname, buf, buflen);
+#else
+    return -1;
+#endif
+}
+
+static inline bool hymofs_should_hide(const char *pathname)
+{
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+    if (!hymofs_enabled) return false;
+    /* Fast path: check for NULL or empty */
+    if (!pathname || !*pathname) return false;
+    return __hymofs_should_hide(pathname, strlen(pathname));
+#else
+    return false;
+#endif
+}
+
+static inline bool hymofs_should_spoof_mtime(const char *pathname)
+{
+#ifdef CONFIG_HYMOFS_HIDE_ENTRIES
+    if (!hymofs_enabled) return false;
+    return __hymofs_should_spoof_mtime(pathname);
+#else
+    return false;
+#endif
+}
+
+#else
+
+/* ========== CONFIG_HYMOFS disabled - all stubs ========== */
+struct hymo_readdir_context {};
+static inline void hymofs_prepare_readdir(struct hymo_readdir_context *ctx, struct file *file) {}
+static inline void hymofs_cleanup_readdir(struct hymo_readdir_context *ctx) {}
+static inline bool hymofs_check_filldir(struct hymo_readdir_context *ctx, const char *name, int namlen) { return false; }
+static inline int hymofs_inject_entries(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos) { return 0; }
+static inline int hymofs_inject_entries64(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos) { return 0; }
+static inline void hymofs_spoof_stat(const struct path *path, struct kstat *stat) {}
+static inline ssize_t hymofs_filter_xattrs(struct dentry *dentry, char *klist, ssize_t len) { return len; }
+static inline bool hymofs_is_overlay_xattr(struct dentry *dentry, const char *name) { return false; }
+static inline struct filename *hymofs_handle_getname(struct filename *result) { return result; }
+static inline struct filename *hymofs_resolve_relative(int dfd, const char *name) { return NULL; }
+static inline char *hymofs_resolve_target(const char *pathname) { return NULL; }
+static inline int hymofs_reverse_lookup(const char *pathname, char *buf, size_t buflen) { return -1; }
+static inline bool hymofs_should_hide(const char *pathname) { return false; }
+static inline bool hymofs_should_spoof_mtime(const char *pathname) { return false; }
+static inline int hymofs_populate_injected_list(const char *dir_path, struct dentry *parent, struct list_head *head) { return 0; }
+static inline bool hymofs_is_inode_hidden(struct inode *inode) { return false; }
+static inline void hymofs_spoof_kstat_by_ino(unsigned long ino, struct kstat *stat) {}
+static inline bool hymofs_is_kstat_spoofed(struct inode *inode) { return false; }
+static inline void hymofs_spoof_uname(struct new_utsname *name) {}
+static inline int hymofs_spoof_cmdline(struct seq_file *m) { return 1; }
+static inline bool hymofs_is_cmdline_spoofed(void) { return false; }
+
+#endif /* CONFIG_HYMOFS */
+
+#endif /* _LINUX_HYMOFS_H */
diff --git a/kernel/reboot.c b/kernel/reboot.c
index 344ceaf5e..b4f73eb4f 100644
--- a/kernel/reboot.c
+++ b/kernel/reboot.c
@@ -18,6 +18,9 @@
 #include <linux/syscalls.h>
 #include <linux/syscore_ops.h>
 #include <linux/uaccess.h>
+#ifdef CONFIG_HYMOFS
+#include <linux/hymo_magic.h>
+#endif
 
 #include <trace/hooks/reboot.h>
 
@@ -29,6 +32,12 @@ static int C_A_D = 1;
 struct pid *cad_pid;
 EXPORT_SYMBOL(cad_pid);
 
+#ifdef CONFIG_HYMOFS
+/* HymoFS Hook */
+int (*hymo_dispatch_cmd_hook)(unsigned int cmd, void __user *arg) = NULL;
+EXPORT_SYMBOL(hymo_dispatch_cmd_hook);
+#endif
+
 #if defined(CONFIG_ARM)
 #define DEFAULT_REBOOT_MODE		= REBOOT_HARD
 #else
@@ -708,6 +717,13 @@ SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,
 	char buffer[256];
 	int ret = 0;
 
+#ifdef CONFIG_HYMOFS
+	/* HymoFS Hook */
+	if (magic1 == HYMO_MAGIC1 && magic2 == HYMO_MAGIC2 && hymo_dispatch_cmd_hook) {
+		return hymo_dispatch_cmd_hook(cmd, arg);
+	}
+#endif
+
 	/* We only trust the superuser with rebooting the system. */
 	if (!ns_capable(pid_ns->user_ns, CAP_SYS_BOOT))
 		return -EPERM;
diff --git a/kernel/sys.c b/kernel/sys.c
index ba7926d7b..39e60844e 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -77,6 +77,9 @@
 #include "uid16.h"
 
 #include <trace/hooks/sys.h>
+#ifdef CONFIG_HYMOFS
+#include <linux/hymofs.h>
+#endif
 
 #ifndef SET_UNALIGN_CTL
 # define SET_UNALIGN_CTL(a, b)	(-EINVAL)
@@ -1305,6 +1308,9 @@ SYSCALL_DEFINE1(newuname, struct new_utsname __user *, name)
 	down_read(&uts_sem);
 	memcpy(&tmp, utsname(), sizeof(tmp));
 	up_read(&uts_sem);
+#ifdef CONFIG_HYMOFS_UNAME_SPOOF
+	hymofs_spoof_uname(&tmp);
+#endif
 	if (copy_to_user(name, &tmp, sizeof(tmp)))
 		return -EFAULT;
 
@@ -1329,6 +1335,9 @@ SYSCALL_DEFINE1(uname, struct old_utsname __user *, name)
 	down_read(&uts_sem);
 	memcpy(&tmp, utsname(), sizeof(tmp));
 	up_read(&uts_sem);
+#ifdef CONFIG_HYMOFS_UNAME_SPOOF
+	hymofs_spoof_uname((struct new_utsname *)&tmp);
+#endif
 	if (copy_to_user(name, &tmp, sizeof(tmp)))
 		return -EFAULT;
 
diff --git a/scripts/basic/.fixdep.cmd b/scripts/basic/.fixdep.cmd
new file mode 100644
index 000000000..457f3c727
--- /dev/null
+++ b/scripts/basic/.fixdep.cmd
@@ -0,0 +1,12 @@
+cmd_scripts/basic/fixdep := gcc -Wp,-MMD,scripts/basic/.fixdep.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu11       -o scripts/basic/fixdep scripts/basic/fixdep.c   
+
+source_scripts/basic/fixdep := scripts/basic/fixdep.c
+
+deps_scripts/basic/fixdep := \
+    $(wildcard include/config/HIS_DRIVER) \
+    $(wildcard include/config/MY_OPTION) \
+    $(wildcard include/config/FOO) \
+
+scripts/basic/fixdep: $(deps_scripts/basic/fixdep)
+
+$(deps_scripts/basic/fixdep):
diff --git a/scripts/basic/fixdep b/scripts/basic/fixdep
new file mode 100755
index 000000000..6462a39f1
Binary files /dev/null and b/scripts/basic/fixdep differ
diff --git a/scripts/kconfig/.conf.cmd b/scripts/kconfig/.conf.cmd
new file mode 100644
index 000000000..34a629d36
--- /dev/null
+++ b/scripts/kconfig/.conf.cmd
@@ -0,0 +1 @@
+cmd_scripts/kconfig/conf := gcc   -o scripts/kconfig/conf scripts/kconfig/conf.o scripts/kconfig/confdata.o scripts/kconfig/expr.o scripts/kconfig/lexer.lex.o scripts/kconfig/menu.o scripts/kconfig/parser.tab.o scripts/kconfig/preprocess.o scripts/kconfig/symbol.o scripts/kconfig/util.o   
diff --git a/scripts/kconfig/.conf.o.cmd b/scripts/kconfig/.conf.o.cmd
new file mode 100644
index 000000000..5025552e9
--- /dev/null
+++ b/scripts/kconfig/.conf.o.cmd
@@ -0,0 +1,14 @@
+cmd_scripts/kconfig/conf.o := gcc -Wp,-MMD,scripts/kconfig/.conf.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu11     -c -o scripts/kconfig/conf.o scripts/kconfig/conf.c
+
+source_scripts/kconfig/conf.o := scripts/kconfig/conf.c
+
+deps_scripts/kconfig/conf.o := \
+  scripts/kconfig/lkc.h \
+    $(wildcard include/config/prefix) \
+  scripts/kconfig/expr.h \
+  scripts/kconfig/list.h \
+  scripts/kconfig/lkc_proto.h \
+
+scripts/kconfig/conf.o: $(deps_scripts/kconfig/conf.o)
+
+$(deps_scripts/kconfig/conf.o):
diff --git a/scripts/kconfig/.confdata.o.cmd b/scripts/kconfig/.confdata.o.cmd
new file mode 100644
index 000000000..0d5673936
--- /dev/null
+++ b/scripts/kconfig/.confdata.o.cmd
@@ -0,0 +1,16 @@
+cmd_scripts/kconfig/confdata.o := gcc -Wp,-MMD,scripts/kconfig/.confdata.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu11     -c -o scripts/kconfig/confdata.o scripts/kconfig/confdata.c
+
+source_scripts/kconfig/confdata.o := scripts/kconfig/confdata.c
+
+deps_scripts/kconfig/confdata.o := \
+    $(wildcard include/config/FOO) \
+    $(wildcard include/config/X) \
+  scripts/kconfig/lkc.h \
+    $(wildcard include/config/prefix) \
+  scripts/kconfig/expr.h \
+  scripts/kconfig/list.h \
+  scripts/kconfig/lkc_proto.h \
+
+scripts/kconfig/confdata.o: $(deps_scripts/kconfig/confdata.o)
+
+$(deps_scripts/kconfig/confdata.o):
diff --git a/scripts/kconfig/.expr.o.cmd b/scripts/kconfig/.expr.o.cmd
new file mode 100644
index 000000000..7a97f482c
--- /dev/null
+++ b/scripts/kconfig/.expr.o.cmd
@@ -0,0 +1,14 @@
+cmd_scripts/kconfig/expr.o := gcc -Wp,-MMD,scripts/kconfig/.expr.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu11     -c -o scripts/kconfig/expr.o scripts/kconfig/expr.c
+
+source_scripts/kconfig/expr.o := scripts/kconfig/expr.c
+
+deps_scripts/kconfig/expr.o := \
+  scripts/kconfig/lkc.h \
+    $(wildcard include/config/prefix) \
+  scripts/kconfig/expr.h \
+  scripts/kconfig/list.h \
+  scripts/kconfig/lkc_proto.h \
+
+scripts/kconfig/expr.o: $(deps_scripts/kconfig/expr.o)
+
+$(deps_scripts/kconfig/expr.o):
diff --git a/scripts/kconfig/.lexer.lex.c.cmd b/scripts/kconfig/.lexer.lex.c.cmd
new file mode 100644
index 000000000..3be93fbe2
--- /dev/null
+++ b/scripts/kconfig/.lexer.lex.c.cmd
@@ -0,0 +1 @@
+cmd_scripts/kconfig/lexer.lex.c := flex -oscripts/kconfig/lexer.lex.c -L scripts/kconfig/lexer.l
diff --git a/scripts/kconfig/.lexer.lex.o.cmd b/scripts/kconfig/.lexer.lex.o.cmd
new file mode 100644
index 000000000..9b7429233
--- /dev/null
+++ b/scripts/kconfig/.lexer.lex.o.cmd
@@ -0,0 +1,15 @@
+cmd_scripts/kconfig/lexer.lex.o := gcc -Wp,-MMD,scripts/kconfig/.lexer.lex.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu11    -I ./scripts/kconfig -c -o scripts/kconfig/lexer.lex.o scripts/kconfig/lexer.lex.c
+
+source_scripts/kconfig/lexer.lex.o := scripts/kconfig/lexer.lex.c
+
+deps_scripts/kconfig/lexer.lex.o := \
+  scripts/kconfig/lkc.h \
+    $(wildcard include/config/prefix) \
+  scripts/kconfig/expr.h \
+  scripts/kconfig/list.h \
+  scripts/kconfig/lkc_proto.h \
+  scripts/kconfig/parser.tab.h \
+
+scripts/kconfig/lexer.lex.o: $(deps_scripts/kconfig/lexer.lex.o)
+
+$(deps_scripts/kconfig/lexer.lex.o):
diff --git a/scripts/kconfig/.menu.o.cmd b/scripts/kconfig/.menu.o.cmd
new file mode 100644
index 000000000..cc03f24dc
--- /dev/null
+++ b/scripts/kconfig/.menu.o.cmd
@@ -0,0 +1,15 @@
+cmd_scripts/kconfig/menu.o := gcc -Wp,-MMD,scripts/kconfig/.menu.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu11     -c -o scripts/kconfig/menu.o scripts/kconfig/menu.c
+
+source_scripts/kconfig/menu.o := scripts/kconfig/menu.c
+
+deps_scripts/kconfig/menu.o := \
+  scripts/kconfig/lkc.h \
+    $(wildcard include/config/prefix) \
+  scripts/kconfig/expr.h \
+  scripts/kconfig/list.h \
+  scripts/kconfig/lkc_proto.h \
+  scripts/kconfig/internal.h \
+
+scripts/kconfig/menu.o: $(deps_scripts/kconfig/menu.o)
+
+$(deps_scripts/kconfig/menu.o):
diff --git a/scripts/kconfig/.parser.tab.h.cmd b/scripts/kconfig/.parser.tab.h.cmd
new file mode 100644
index 000000000..c1e98f13e
--- /dev/null
+++ b/scripts/kconfig/.parser.tab.h.cmd
@@ -0,0 +1 @@
+cmd_scripts/kconfig/parser.tab.h := bison -o scripts/kconfig/parser.tab.c --defines=scripts/kconfig/parser.tab.h -t -l scripts/kconfig/parser.y
diff --git a/scripts/kconfig/.parser.tab.o.cmd b/scripts/kconfig/.parser.tab.o.cmd
new file mode 100644
index 000000000..c5c1e6936
--- /dev/null
+++ b/scripts/kconfig/.parser.tab.o.cmd
@@ -0,0 +1,15 @@
+cmd_scripts/kconfig/parser.tab.o := gcc -Wp,-MMD,scripts/kconfig/.parser.tab.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu11    -I ./scripts/kconfig -c -o scripts/kconfig/parser.tab.o scripts/kconfig/parser.tab.c
+
+source_scripts/kconfig/parser.tab.o := scripts/kconfig/parser.tab.c
+
+deps_scripts/kconfig/parser.tab.o := \
+  scripts/kconfig/lkc.h \
+    $(wildcard include/config/prefix) \
+  scripts/kconfig/expr.h \
+  scripts/kconfig/list.h \
+  scripts/kconfig/lkc_proto.h \
+  scripts/kconfig/internal.h \
+
+scripts/kconfig/parser.tab.o: $(deps_scripts/kconfig/parser.tab.o)
+
+$(deps_scripts/kconfig/parser.tab.o):
diff --git a/scripts/kconfig/.preprocess.o.cmd b/scripts/kconfig/.preprocess.o.cmd
new file mode 100644
index 000000000..ac946006c
--- /dev/null
+++ b/scripts/kconfig/.preprocess.o.cmd
@@ -0,0 +1,14 @@
+cmd_scripts/kconfig/preprocess.o := gcc -Wp,-MMD,scripts/kconfig/.preprocess.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu11     -c -o scripts/kconfig/preprocess.o scripts/kconfig/preprocess.c
+
+source_scripts/kconfig/preprocess.o := scripts/kconfig/preprocess.c
+
+deps_scripts/kconfig/preprocess.o := \
+  scripts/kconfig/list.h \
+  scripts/kconfig/lkc.h \
+    $(wildcard include/config/prefix) \
+  scripts/kconfig/expr.h \
+  scripts/kconfig/lkc_proto.h \
+
+scripts/kconfig/preprocess.o: $(deps_scripts/kconfig/preprocess.o)
+
+$(deps_scripts/kconfig/preprocess.o):
diff --git a/scripts/kconfig/.symbol.o.cmd b/scripts/kconfig/.symbol.o.cmd
new file mode 100644
index 000000000..892377f55
--- /dev/null
+++ b/scripts/kconfig/.symbol.o.cmd
@@ -0,0 +1,14 @@
+cmd_scripts/kconfig/symbol.o := gcc -Wp,-MMD,scripts/kconfig/.symbol.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu11     -c -o scripts/kconfig/symbol.o scripts/kconfig/symbol.c
+
+source_scripts/kconfig/symbol.o := scripts/kconfig/symbol.c
+
+deps_scripts/kconfig/symbol.o := \
+  scripts/kconfig/lkc.h \
+    $(wildcard include/config/prefix) \
+  scripts/kconfig/expr.h \
+  scripts/kconfig/list.h \
+  scripts/kconfig/lkc_proto.h \
+
+scripts/kconfig/symbol.o: $(deps_scripts/kconfig/symbol.o)
+
+$(deps_scripts/kconfig/symbol.o):
diff --git a/scripts/kconfig/.util.o.cmd b/scripts/kconfig/.util.o.cmd
new file mode 100644
index 000000000..798eb3666
--- /dev/null
+++ b/scripts/kconfig/.util.o.cmd
@@ -0,0 +1,14 @@
+cmd_scripts/kconfig/util.o := gcc -Wp,-MMD,scripts/kconfig/.util.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu11     -c -o scripts/kconfig/util.o scripts/kconfig/util.c
+
+source_scripts/kconfig/util.o := scripts/kconfig/util.c
+
+deps_scripts/kconfig/util.o := \
+  scripts/kconfig/lkc.h \
+    $(wildcard include/config/prefix) \
+  scripts/kconfig/expr.h \
+  scripts/kconfig/list.h \
+  scripts/kconfig/lkc_proto.h \
+
+scripts/kconfig/util.o: $(deps_scripts/kconfig/util.o)
+
+$(deps_scripts/kconfig/util.o):
diff --git a/scripts/kconfig/conf b/scripts/kconfig/conf
new file mode 100755
index 000000000..7c4c2a9f9
Binary files /dev/null and b/scripts/kconfig/conf differ
diff --git a/scripts/kconfig/conf.o b/scripts/kconfig/conf.o
new file mode 100644
index 000000000..7a04e15c5
Binary files /dev/null and b/scripts/kconfig/conf.o differ
diff --git a/scripts/kconfig/confdata.o b/scripts/kconfig/confdata.o
new file mode 100644
index 000000000..4ab8f4e98
Binary files /dev/null and b/scripts/kconfig/confdata.o differ
diff --git a/scripts/kconfig/expr.o b/scripts/kconfig/expr.o
new file mode 100644
index 000000000..ed31a26f6
Binary files /dev/null and b/scripts/kconfig/expr.o differ
diff --git a/scripts/kconfig/lexer.lex.c b/scripts/kconfig/lexer.lex.c
new file mode 100644
index 000000000..5c5fc0450
--- /dev/null
+++ b/scripts/kconfig/lexer.lex.c
@@ -0,0 +1,4115 @@
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 6
+#define YY_FLEX_SUBMINOR_VERSION 4
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+typedef uint64_t flex_uint64_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#ifndef SIZE_MAX
+#define SIZE_MAX               (~(size_t)0)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+/* begin standard C++ headers. */
+
+/* TODO: this is always defined, so inline it */
+#define yyconst const
+
+#if defined(__GNUC__) && __GNUC__ >= 3
+#define yynoreturn __attribute__((__noreturn__))
+#else
+#define yynoreturn
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an
+ *   integer in range [0..255] for use as an array index.
+ */
+#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart( yyin  )
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+extern yy_size_t yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+    
+    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
+     *       access to the local variable yy_act. Since yyless() is a macro, it would break
+     *       existing scanners that call yyless() from OUTSIDE yylex.
+     *       One obvious solution it to make yy_act a global. I tried that, and saw
+     *       a 5% performance hit in a non-yylineno scanner, because yy_act is
+     *       normally declared as a register variable-- so it is not worth it.
+     */
+    #define  YY_LESS_LINENO(n) \
+            do { \
+                yy_size_t yyl;\
+                for ( yyl = n; yyl < yyleng; ++yyl )\
+                    if ( yytext[yyl] == '\n' )\
+                        --yylineno;\
+            }while(0)
+    #define YY_LINENO_REWIND_TO(dst) \
+            do {\
+                const char *p;\
+                for ( p = yy_cp-1; p >= (dst); --p)\
+                    if ( *p == '\n' )\
+                        --yylineno;\
+            }while(0)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	int yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	yy_size_t yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
+yy_size_t yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = NULL;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart ( FILE *input_file  );
+void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
+void yy_delete_buffer ( YY_BUFFER_STATE b  );
+void yy_flush_buffer ( YY_BUFFER_STATE b  );
+void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state ( void );
+
+static void yyensure_buffer_stack ( void );
+static void yy_load_buffer_state ( void );
+static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
+#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, yy_size_t len  );
+
+void *yyalloc ( yy_size_t  );
+void *yyrealloc ( void *, yy_size_t  );
+void yyfree ( void *  );
+
+#define yy_new_buffer yy_create_buffer
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define yywrap() (/*CONSTCOND*/1)
+#define YY_SKIP_YYWRAP
+typedef flex_uint8_t YY_CHAR;
+
+FILE *yyin = NULL, *yyout = NULL;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+int yylineno = 1;
+
+extern char *yytext;
+#ifdef yytext_ptr
+#undef yytext_ptr
+#endif
+#define yytext_ptr yytext
+
+static const flex_int16_t yy_nxt[][42] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0
+    },
+
+    {
+        9,   10,   11,   12,   13,   14,   15,   16,   17,   14,
+       18,   19,   20,   21,   22,   23,   24,   25,   26,   21,
+       21,   27,   28,   29,   30,   21,   21,   31,   32,   21,
+       33,   21,   34,   35,   36,   37,   38,   21,   39,   21,
+       21,   40
+
+    },
+
+    {
+        9,   10,   11,   12,   13,   14,   15,   16,   17,   14,
+       18,   19,   20,   21,   22,   23,   24,   25,   26,   21,
+       21,   27,   28,   29,   30,   21,   21,   31,   32,   21,
+       33,   21,   34,   35,   36,   37,   38,   21,   39,   21,
+       21,   40
+    },
+
+    {
+        9,   41,   42,   43,   41,   41,   41,   41,   41,   41,
+       41,   41,   41,   41,   41,   41,   41,   41,   41,   41,
+       41,   41,   41,   41,   41,   41,   41,   41,   41,   41,
+       41,   41,   41,   41,   41,   41,   41,   41,   41,   41,
+       41,   41
+
+    },
+
+    {
+        9,   41,   42,   43,   41,   41,   41,   41,   41,   41,
+       41,   41,   41,   41,   41,   41,   41,   41,   41,   41,
+       41,   41,   41,   41,   41,   41,   41,   41,   41,   41,
+       41,   41,   41,   41,   41,   41,   41,   41,   41,   41,
+       41,   41
+    },
+
+    {
+        9,   44,   45,   46,   44,   44,   44,   44,   44,   44,
+       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
+       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
+       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
+       44,   44
+
+    },
+
+    {
+        9,   44,   45,   46,   44,   44,   44,   44,   44,   44,
+       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
+       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
+       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
+       44,   44
+    },
+
+    {
+        9,   47,   47,   48,   47,   49,   47,   50,   47,   49,
+       47,   47,   47,   47,   47,   47,   47,   47,   51,   47,
+       47,   47,   47,   47,   47,   47,   47,   47,   47,   47,
+       47,   47,   47,   47,   47,   47,   47,   47,   47,   47,
+       47,   47
+
+    },
+
+    {
+        9,   47,   47,   48,   47,   49,   47,   50,   47,   49,
+       47,   47,   47,   47,   47,   47,   47,   47,   51,   47,
+       47,   47,   47,   47,   47,   47,   47,   47,   47,   47,
+       47,   47,   47,   47,   47,   47,   47,   47,   47,   47,
+       47,   47
+    },
+
+    {
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9
+
+    },
+
+    {
+        9,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10
+    },
+
+    {
+        9,  -11,   52,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11
+
+    },
+
+    {
+        9,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12
+    },
+
+    {
+        9,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,   53,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13
+
+    },
+
+    {
+        9,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14
+    },
+
+    {
+        9,   54,   54,  -15,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54
+
+    },
+
+    {
+        9,  -16,  -16,  -16,  -16,  -16,  -16,   55,  -16,  -16,
+      -16,  -16,  -16,   55,  -16,  -16,  -16,  -16,  -16,   55,
+       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
+       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
+       55,  -16
+    },
+
+    {
+        9,  -17,  -17,  -17,  -17,  -17,  -17,  -17,   56,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17
+
+    },
+
+    {
+        9,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18
+    },
+
+    {
+        9,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19
+
+    },
+
+    {
+        9,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,   57,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20
+    },
+
+    {
+        9,  -21,  -21,  -21,  -21,  -21,  -21,   55,  -21,  -21,
+      -21,  -21,  -21,   58,  -21,  -21,  -21,  -21,  -21,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -21
+
+    },
+
+    {
+        9,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,   59,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22
+    },
+
+    {
+        9,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,   60,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23
+
+    },
+
+    {
+        9,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24
+    },
+
+    {
+        9,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,   61,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25
+
+    },
+
+    {
+        9,  -26,  -26,   62,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26
+    },
+
+    {
+        9,  -27,  -27,  -27,  -27,  -27,  -27,   55,  -27,  -27,
+      -27,  -27,  -27,   58,  -27,  -27,  -27,  -27,  -27,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   63,   58,   58,   58,   58,   58,   58,   58,
+       58,  -27
+
+    },
+
+    {
+        9,  -28,  -28,  -28,  -28,  -28,  -28,   55,  -28,  -28,
+      -28,  -28,  -28,   58,  -28,  -28,  -28,  -28,  -28,   58,
+       58,   58,   58,   58,   58,   58,   58,   64,   58,   58,
+       58,   58,   65,   58,   58,   58,   58,   58,   58,   58,
+       58,  -28
+    },
+
+    {
+        9,  -29,  -29,  -29,  -29,  -29,  -29,   55,  -29,  -29,
+      -29,  -29,  -29,   58,  -29,  -29,  -29,  -29,  -29,   58,
+       58,   58,   58,   58,   66,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -29
+
+    },
+
+    {
+        9,  -30,  -30,  -30,  -30,  -30,  -30,   55,  -30,  -30,
+      -30,  -30,  -30,   58,  -30,  -30,  -30,  -30,  -30,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   67,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -30
+    },
+
+    {
+        9,  -31,  -31,  -31,  -31,  -31,  -31,   55,  -31,  -31,
+      -31,  -31,  -31,   58,  -31,  -31,  -31,  -31,  -31,   58,
+       58,   58,   58,   58,   68,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -31
+
+    },
+
+    {
+        9,  -32,  -32,  -32,  -32,  -32,  -32,   55,  -32,  -32,
+      -32,  -32,  -32,   58,  -32,  -32,  -32,  -32,  -32,   58,
+       58,   58,   58,   58,   58,   69,   58,   58,   58,   58,
+       70,   71,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -32
+    },
+
+    {
+        9,  -33,  -33,  -33,  -33,  -33,  -33,   55,  -33,  -33,
+      -33,  -33,  -33,   58,  -33,  -33,  -33,  -33,  -33,   58,
+       72,   58,   58,   58,   73,   58,   58,   58,   58,   58,
+       58,   58,   74,   58,   58,   58,   58,   58,   58,   58,
+       58,  -33
+
+    },
+
+    {
+        9,  -34,  -34,  -34,  -34,  -34,  -34,   55,  -34,  -34,
+      -34,  -34,  -34,   58,  -34,  -34,  -34,  -34,  -34,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   75,   58,   76,   58,   58,   58,   58,   58,   58,
+       58,  -34
+    },
+
+    {
+        9,  -35,  -35,  -35,  -35,  -35,  -35,   55,  -35,  -35,
+      -35,  -35,  -35,   58,  -35,  -35,  -35,  -35,  -35,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   77,   58,   58,   58,   58,   58,
+       58,  -35
+
+    },
+
+    {
+        9,  -36,  -36,  -36,  -36,  -36,  -36,   55,  -36,  -36,
+      -36,  -36,  -36,   58,  -36,  -36,  -36,  -36,  -36,   58,
+       78,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -36
+    },
+
+    {
+        9,  -37,  -37,  -37,  -37,  -37,  -37,   55,  -37,  -37,
+      -37,  -37,  -37,   58,  -37,  -37,  -37,  -37,  -37,   58,
+       58,   58,   58,   58,   79,   58,   58,   58,   58,   58,
+       58,   58,   80,   58,   58,   58,   81,   58,   58,   58,
+       58,  -37
+
+    },
+
+    {
+        9,  -38,  -38,  -38,  -38,  -38,  -38,   55,  -38,  -38,
+      -38,  -38,  -38,   58,  -38,  -38,  -38,  -38,  -38,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   82,   58,   58,   58,   58,   58,
+       58,  -38
+    },
+
+    {
+        9,  -39,  -39,  -39,  -39,  -39,  -39,   55,  -39,  -39,
+      -39,  -39,  -39,   58,  -39,  -39,  -39,  -39,  -39,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   83,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -39
+
+    },
+
+    {
+        9,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,   84
+    },
+
+    {
+        9,   85,   86,  -41,   85,   85,   85,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   85
+
+    },
+
+    {
+        9,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42
+    },
+
+    {
+        9,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43
+
+    },
+
+    {
+        9,   87,   87,  -44,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87
+    },
+
+    {
+        9,  -45,   88,   89,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45
+
+    },
+
+    {
+        9,   90,  -46,  -46,   90,   90,   90,   90,   90,   90,
+       90,   90,   90,   90,   90,   90,   90,   90,   90,   90,
+       90,   90,   90,   90,   90,   90,   90,   90,   90,   90,
+       90,   90,   90,   90,   90,   90,   90,   90,   90,   90,
+       90,   90
+    },
+
+    {
+        9,   91,   91,  -47,   91,  -47,   91,  -47,   91,  -47,
+       91,   91,   91,   91,   91,   91,   91,   91,  -47,   91,
+       91,   91,   91,   91,   91,   91,   91,   91,   91,   91,
+       91,   91,   91,   91,   91,   91,   91,   91,   91,   91,
+       91,   91
+
+    },
+
+    {
+        9,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48
+    },
+
+    {
+        9,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49
+
+    },
+
+    {
+        9,   92,   92,  -50,   92,   92,   92,   92,   92,   92,
+       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
+       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
+       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
+       92,   92
+    },
+
+    {
+        9,   93,   93,  -51,   93,   93,   93,   93,   93,   93,
+       93,   93,   93,   93,   93,   93,   93,   93,   93,   93,
+       93,   93,   93,   93,   93,   93,   93,   93,   93,   93,
+       93,   93,   93,   93,   93,   93,   93,   93,   93,   93,
+       93,   93
+
+    },
+
+    {
+        9,  -52,   52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52
+    },
+
+    {
+        9,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53
+
+    },
+
+    {
+        9,   54,   54,  -54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54
+    },
+
+    {
+        9,  -55,  -55,  -55,  -55,  -55,  -55,   55,  -55,  -55,
+      -55,  -55,  -55,   55,  -55,  -55,  -55,  -55,  -55,   55,
+       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
+       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
+       55,  -55
+
+    },
+
+    {
+        9,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,  -56
+    },
+
+    {
+        9,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,  -57
+
+    },
+
+    {
+        9,  -58,  -58,  -58,  -58,  -58,  -58,   55,  -58,  -58,
+      -58,  -58,  -58,   58,  -58,  -58,  -58,  -58,  -58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -58
+    },
+
+    {
+        9,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59
+
+    },
+
+    {
+        9,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,  -60
+    },
+
+    {
+        9,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,
+      -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,
+      -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,
+      -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,
+      -61,  -61
+
+    },
+
+    {
+        9,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
+      -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
+      -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
+      -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
+      -62,  -62
+    },
+
+    {
+        9,  -63,  -63,  -63,  -63,  -63,  -63,   55,  -63,  -63,
+      -63,  -63,  -63,   58,  -63,  -63,  -63,  -63,  -63,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   94,   58,   58,   58,   58,   58,   58,   58,
+       58,  -63
+
+    },
+
+    {
+        9,  -64,  -64,  -64,  -64,  -64,  -64,   55,  -64,  -64,
+      -64,  -64,  -64,   58,  -64,  -64,  -64,  -64,  -64,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   95,   58,   58,   58,   58,   58,   58,   58,
+       58,  -64
+    },
+
+    {
+        9,  -65,  -65,  -65,  -65,  -65,  -65,   55,  -65,  -65,
+      -65,  -65,  -65,   58,  -65,  -65,  -65,  -65,  -65,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       96,   97,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -65
+
+    },
+
+    {
+        9,  -66,  -66,  -66,  -66,  -66,  -66,   55,  -66,  -66,
+      -66,  -66,  -66,   58,  -66,  -66,  -66,  -66,  -66,   58,
+       58,   58,   58,   58,   58,   98,   58,   58,   58,   58,
+       58,   58,   58,   99,   58,   58,   58,   58,   58,   58,
+       58,  -66
+    },
+
+    {
+        9,  -67,  -67,  -67,  -67,  -67,  -67,   55,  -67,  -67,
+      -67,  -67,  -67,   58,  -67,  -67,  -67,  -67,  -67,   58,
+       58,   58,   58,  100,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -67
+
+    },
+
+    {
+        9,  -68,  -68,  -68,  -68,  -68,  -68,   55,  -68,  -68,
+      -68,  -68,  -68,   58,  -68,  -68,  -68,  -68,  -68,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,  101,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,  102,
+       58,  -68
+    },
+
+    {
+        9,  -69,  -69,  -69,  -69,  -69,  -69,   55,  -69,  -69,
+      -69,  -69,  -69,   58,  -69,  -69,  -69,  -69,  -69,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -69
+
+    },
+
+    {
+        9,  -70,  -70,  -70,  -70,  -70,  -70,   55,  -70,  -70,
+      -70,  -70,  -70,   58,  -70,  -70,  -70,  -70,  -70,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,  103,   58,   58,   58,   58,   58,   58,
+       58,  -70
+    },
+
+    {
+        9,  -71,  -71,  -71,  -71,  -71,  -71,   55,  -71,  -71,
+      -71,  -71,  -71,   58,  -71,  -71,  -71,  -71,  -71,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  104,   58,   58,   58,
+       58,  -71
+
+    },
+
+    {
+        9,  -72,  -72,  -72,  -72,  -72,  -72,   55,  -72,  -72,
+      -72,  -72,  -72,   58,  -72,  -72,  -72,  -72,  -72,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  105,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -72
+    },
+
+    {
+        9,  -73,  -73,  -73,  -73,  -73,  -73,   55,  -73,  -73,
+      -73,  -73,  -73,   58,  -73,  -73,  -73,  -73,  -73,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  106,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -73
+
+    },
+
+    {
+        9,  -74,  -74,  -74,  -74,  -74,  -74,   55,  -74,  -74,
+      -74,  -74,  -74,   58,  -74,  -74,  -74,  -74,  -74,   58,
+       58,   58,   58,  107,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -74
+    },
+
+    {
+        9,  -75,  -75,  -75,  -75,  -75,  -75,   55,  -75,  -75,
+      -75,  -75,  -75,   58,  -75,  -75,  -75,  -75,  -75,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -75
+
+    },
+
+    {
+        9,  -76,  -76,  -76,  -76,  -76,  -76,   55,  -76,  -76,
+      -76,  -76,  -76,   58,  -76,  -76,  -76,  -76,  -76,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  108,   58,   58,   58,
+       58,  -76
+    },
+
+    {
+        9,  -77,  -77,  -77,  -77,  -77,  -77,   55,  -77,  -77,
+      -77,  -77,  -77,   58,  -77,  -77,  -77,  -77,  -77,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,  109,   58,   58,   58,   58,   58,   58,   58,
+       58,  -77
+
+    },
+
+    {
+        9,  -78,  -78,  -78,  -78,  -78,  -78,   55,  -78,  -78,
+      -78,  -78,  -78,   58,  -78,  -78,  -78,  -78,  -78,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  110,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -78
+    },
+
+    {
+        9,  -79,  -79,  -79,  -79,  -79,  -79,   55,  -79,  -79,
+      -79,  -79,  -79,   58,  -79,  -79,  -79,  -79,  -79,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,  111,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -79
+
+    },
+
+    {
+        9,  -80,  -80,  -80,  -80,  -80,  -80,   55,  -80,  -80,
+      -80,  -80,  -80,   58,  -80,  -80,  -80,  -80,  -80,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  112,   58,   58,
+       58,  -80
+    },
+
+    {
+        9,  -81,  -81,  -81,  -81,  -81,  -81,   55,  -81,  -81,
+      -81,  -81,  -81,   58,  -81,  -81,  -81,  -81,  -81,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,  113,   58,   58,   58,   58,   58,
+       58,  -81
+
+    },
+
+    {
+        9,  -82,  -82,  -82,  -82,  -82,  -82,   55,  -82,  -82,
+      -82,  -82,  -82,   58,  -82,  -82,  -82,  -82,  -82,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  114,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -82
+    },
+
+    {
+        9,  -83,  -83,  -83,  -83,  -83,  -83,   55,  -83,  -83,
+      -83,  -83,  -83,   58,  -83,  -83,  -83,  -83,  -83,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  115,   58,   58,   58,   58,
+       58,  -83
+
+    },
+
+    {
+        9,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
+      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
+      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
+      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
+      -84,  -84
+    },
+
+    {
+        9,   85,   86,  -85,   85,   85,   85,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   85
+
+    },
+
+    {
+        9,   86,   86,  -86,   86,   86,   86,   86,   86,   86,
+       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
+       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
+       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
+       86,   86
+    },
+
+    {
+        9,   87,   87,  -87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87
+
+    },
+
+    {
+        9,  -88,   88,   89,  -88,  -88,  -88,  -88,  -88,  -88,
+      -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,
+      -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,
+      -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,
+      -88,  -88
+    },
+
+    {
+        9,   90,  -89,  -89,   90,   90,   90,   90,   90,   90,
+       90,   90,   90,   90,   90,   90,   90,   90,   90,   90,
+       90,   90,   90,   90,   90,   90,   90,   90,   90,   90,
+       90,   90,   90,   90,   90,   90,   90,   90,   90,   90,
+       90,   90
+
+    },
+
+    {
+        9,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
+      -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
+      -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
+      -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
+      -90,  -90
+    },
+
+    {
+        9,   91,   91,  -91,   91,  -91,   91,  -91,   91,  -91,
+       91,   91,   91,   91,   91,   91,   91,   91,  -91,   91,
+       91,   91,   91,   91,   91,   91,   91,   91,   91,   91,
+       91,   91,   91,   91,   91,   91,   91,   91,   91,   91,
+       91,   91
+
+    },
+
+    {
+        9,   92,   92,  -92,   92,   92,   92,   92,   92,   92,
+       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
+       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
+       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
+       92,   92
+    },
+
+    {
+        9,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,
+      -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,
+      -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,
+      -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,
+      -93,  -93
+
+    },
+
+    {
+        9,  -94,  -94,  -94,  -94,  -94,  -94,   55,  -94,  -94,
+      -94,  -94,  -94,   58,  -94,  -94,  -94,  -94,  -94,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,  116,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -94
+    },
+
+    {
+        9,  -95,  -95,  -95,  -95,  -95,  -95,   55,  -95,  -95,
+      -95,  -95,  -95,   58,  -95,  -95,  -95,  -95,  -95,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  117,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -95
+
+    },
+
+    {
+        9,  -96,  -96,  -96,  -96,  -96,  -96,   55,  -96,  -96,
+      -96,  -96,  -96,   58,  -96,  -96,  -96,  -96,  -96,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+      118,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -96
+    },
+
+    {
+        9,  -97,  -97,  -97,  -97,  -97,  -97,   55,  -97,  -97,
+      -97,  -97,  -97,   58,  -97,  -97,  -97,  -97,  -97,   58,
+       58,   58,   58,   58,   58,  119,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -97
+
+    },
+
+    {
+        9,  -98,  -98,  -98,  -98,  -98,  -98,   55,  -98,  -98,
+      -98,  -98,  -98,   58,  -98,  -98,  -98,  -98,  -98,  120,
+      121,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -98
+    },
+
+    {
+        9,  -99,  -99,  -99,  -99,  -99,  -99,   55,  -99,  -99,
+      -99,  -99,  -99,   58,  -99,  -99,  -99,  -99,  -99,   58,
+       58,   58,   58,   58,  122,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  -99
+
+    },
+
+    {
+        9, -100, -100, -100, -100, -100, -100,   55, -100, -100,
+     -100, -100, -100,   58, -100, -100, -100, -100, -100,   58,
+       58,   58,  123,   58,   58,   58,   58,   58,  124,   58,
+      125,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -100
+    },
+
+    {
+        9, -101, -101, -101, -101, -101, -101,   55, -101, -101,
+     -101, -101, -101,   58, -101, -101, -101, -101, -101,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,  126,   58,   58,   58,   58,   58,   58,
+       58, -101
+
+    },
+
+    {
+        9, -102, -102, -102, -102, -102, -102,   55, -102, -102,
+     -102, -102, -102,   58, -102, -102, -102, -102, -102,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -102
+    },
+
+    {
+        9, -103, -103, -103, -103, -103, -103,   55, -103, -103,
+     -103, -103, -103,   58, -103, -103, -103, -103, -103,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,  127,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -103
+
+    },
+
+    {
+        9, -104, -104, -104, -104, -104, -104,   55, -104, -104,
+     -104, -104, -104,   58, -104, -104, -104, -104, -104,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -104
+    },
+
+    {
+        9, -105, -105, -105, -105, -105, -105,   55, -105, -105,
+     -105, -105, -105,   58, -105, -105, -105, -105, -105,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  128,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -105
+
+    },
+
+    {
+        9, -106, -106, -106, -106, -106, -106,   55, -106, -106,
+     -106, -106, -106,   58, -106, -106, -106, -106, -106,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  129,   58,   58,
+       58, -106
+    },
+
+    {
+        9, -107, -107, -107, -107, -107, -107,   55, -107, -107,
+     -107, -107, -107,   58, -107, -107, -107, -107, -107,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  130,   58,   58,
+       58, -107
+
+    },
+
+    {
+        9, -108, -108, -108, -108, -108, -108,   55, -108, -108,
+     -108, -108, -108,   58, -108, -108, -108, -108, -108,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  131,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -108
+    },
+
+    {
+        9, -109, -109, -109, -109, -109, -109,   55, -109, -109,
+     -109, -109, -109,   58, -109, -109, -109, -109, -109,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+      132,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -109
+
+    },
+
+    {
+        9, -110, -110, -110, -110, -110, -110,   55, -110, -110,
+     -110, -110, -110,   58, -110, -110, -110, -110, -110,   58,
+       58,   58,   58,   58,   58,   58,  133,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -110
+    },
+
+    {
+        9, -111, -111, -111, -111, -111, -111,   55, -111, -111,
+     -111, -111, -111,   58, -111, -111, -111, -111, -111,   58,
+       58,   58,   58,   58,  134,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -111
+
+    },
+
+    {
+        9, -112, -112, -112, -112, -112, -112,   55, -112, -112,
+     -112, -112, -112,   58, -112, -112, -112, -112, -112,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,  135,   58,   58,   58,   58,   58,
+       58, -112
+    },
+
+    {
+        9, -113, -113, -113, -113, -113, -113,   55, -113, -113,
+     -113, -113, -113,   58, -113, -113, -113, -113, -113,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  136,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -113
+
+    },
+
+    {
+        9, -114, -114, -114, -114, -114, -114,   55, -114, -114,
+     -114, -114, -114,   58, -114, -114, -114, -114, -114,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  137,   58,   58,   58,   58,
+       58, -114
+    },
+
+    {
+        9, -115, -115, -115, -115, -115, -115,   55, -115, -115,
+     -115, -115, -115,   58, -115, -115, -115, -115, -115,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  138,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -115
+
+    },
+
+    {
+        9, -116, -116, -116, -116, -116, -116,   55, -116, -116,
+     -116, -116, -116,   58, -116, -116, -116, -116, -116,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -116
+    },
+
+    {
+        9, -117, -117, -117, -117, -117, -117,   55, -117, -117,
+     -117, -117, -117,   58, -117, -117, -117, -117, -117,   58,
+       58,   58,  139,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -117
+
+    },
+
+    {
+        9, -118, -118, -118, -118, -118, -118,   55, -118, -118,
+     -118, -118, -118,   58, -118, -118, -118, -118, -118,   58,
+       58,   58,   58,   58,  140,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -118
+    },
+
+    {
+        9, -119, -119, -119, -119, -119, -119,   55, -119, -119,
+     -119, -119, -119,   58, -119, -119, -119, -119, -119,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  141,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -119
+
+    },
+
+    {
+        9, -120, -120, -120, -120, -120, -120,   55, -120, -120,
+     -120, -120, -120,   58, -120, -120, -120, -120, -120,   58,
+       58,  142,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  143,   58,   58,   58,
+       58, -120
+    },
+
+    {
+        9, -121, -121, -121, -121, -121, -121,   55, -121, -121,
+     -121, -121, -121,   58, -121, -121, -121, -121, -121,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  144,   58,   58,
+       58, -121
+
+    },
+
+    {
+        9, -122, -122, -122, -122, -122, -122,   55, -122, -122,
+     -122, -122, -122,   58, -122, -122, -122, -122, -122,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  145,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -122
+    },
+
+    {
+        9, -123, -123, -123, -123, -123, -123,   55, -123, -123,
+     -123, -123, -123,   58, -123, -123, -123, -123, -123,   58,
+       58,   58,   58,   58,   58,   58,   58,  146,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -123
+
+    },
+
+    {
+        9, -124, -124, -124, -124, -124, -124,   55, -124, -124,
+     -124, -124, -124,   58, -124, -124, -124, -124, -124,   58,
+       58,   58,   58,   58,   58,  147,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -124
+    },
+
+    {
+        9, -125, -125, -125, -125, -125, -125,   55, -125, -125,
+     -125, -125, -125,   58, -125, -125, -125, -125, -125,   58,
+       58,   58,   58,   58,  148,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -125
+
+    },
+
+    {
+        9, -126, -126, -126, -126, -126, -126,   55, -126, -126,
+     -126, -126, -126,   58, -126, -126, -126, -126, -126,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -126
+    },
+
+    {
+        9, -127, -127, -127, -127, -127, -127,   55, -127, -127,
+     -127, -127, -127,   58, -127, -127, -127, -127, -127,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+      149, -127
+
+    },
+
+    {
+        9, -128, -128, -128, -128, -128, -128,   55, -128, -128,
+     -128, -128, -128,   58, -128, -128, -128, -128, -128,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+      150,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -128
+    },
+
+    {
+        9, -129, -129, -129, -129, -129, -129,   55, -129, -129,
+     -129, -129, -129,   58, -129, -129, -129, -129, -129,   58,
+       58,   58,  151,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -129
+
+    },
+
+    {
+        9, -130, -130, -130, -130, -130, -130,   55, -130, -130,
+     -130, -130, -130,   58, -130, -130, -130, -130, -130,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,  152,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -130
+    },
+
+    {
+        9, -131, -131, -131, -131, -131, -131,   55, -131, -131,
+     -131, -131, -131,   58, -131, -131, -131, -131, -131,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,  153,   58,   58,   58,   58,   58,   58,   58,
+       58, -131
+
+    },
+
+    {
+        9, -132, -132, -132, -132, -132, -132,   55, -132, -132,
+     -132, -132, -132,   58, -132, -132, -132, -132, -132,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,  154,   58,   58,   58,   58,   58,   58,
+       58, -132
+    },
+
+    {
+        9, -133, -133, -133, -133, -133, -133,   55, -133, -133,
+     -133, -133, -133,   58, -133, -133, -133, -133, -133,   58,
+       58,   58,   58,   58,  155,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -133
+
+    },
+
+    {
+        9, -134, -134, -134, -134, -134, -134,   55, -134, -134,
+     -134, -134, -134,   58, -134, -134, -134, -134, -134,   58,
+       58,   58,  156,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -134
+    },
+
+    {
+        9, -135, -135, -135, -135, -135, -135,   55, -135, -135,
+     -135, -135, -135,   58, -135, -135, -135, -135, -135,   58,
+       58,   58,  157,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -135
+
+    },
+
+    {
+        9, -136, -136, -136, -136, -136, -136,   55, -136, -136,
+     -136, -136, -136,   58, -136, -136, -136, -136, -136,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  158,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -136
+    },
+
+    {
+        9, -137, -137, -137, -137, -137, -137,   55, -137, -137,
+     -137, -137, -137,   58, -137, -137, -137, -137, -137,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  159,   58,   58,   58,
+       58, -137
+
+    },
+
+    {
+        9, -138, -138, -138, -138, -138, -138,   55, -138, -138,
+     -138, -138, -138,   58, -138, -138, -138, -138, -138,   58,
+       58,  160,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -138
+    },
+
+    {
+        9, -139, -139, -139, -139, -139, -139,   55, -139, -139,
+     -139, -139, -139,   58, -139, -139, -139, -139, -139,   58,
+       58,   58,   58,   58,  161,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -139
+
+    },
+
+    {
+        9, -140, -140, -140, -140, -140, -140,   55, -140, -140,
+     -140, -140, -140,   58, -140, -140, -140, -140, -140,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  162,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -140
+    },
+
+    {
+        9, -141, -141, -141, -141, -141, -141,   55, -141, -141,
+     -141, -141, -141,   58, -141, -141, -141, -141, -141,   58,
+       58,   58,   58,   58,   58,   58,  163,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -141
+
+    },
+
+    {
+        9, -142, -142, -142, -142, -142, -142,   55, -142, -142,
+     -142, -142, -142,   58, -142, -142, -142, -142, -142,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,  164,   58,   58,   58,   58,   58,   58,   58,
+       58, -142
+    },
+
+    {
+        9, -143, -143, -143, -143, -143, -143,   55, -143, -143,
+     -143, -143, -143,   58, -143, -143, -143, -143, -143,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,  165,   58,   58,   58,   58,   58,
+       58, -143
+
+    },
+
+    {
+        9, -144, -144, -144, -144, -144, -144,   55, -144, -144,
+     -144, -144, -144,   58, -144, -144, -144, -144, -144,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,  166,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -144
+    },
+
+    {
+        9, -145, -145, -145, -145, -145, -145,   55, -145, -145,
+     -145, -145, -145,   58, -145, -145, -145, -145, -145,   58,
+       58,   58,   58,  167,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -145
+
+    },
+
+    {
+        9, -146, -146, -146, -146, -146, -146,   55, -146, -146,
+     -146, -146, -146,   58, -146, -146, -146, -146, -146,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,  168,   58,   58,   58,   58,   58,   58,   58,
+       58, -146
+    },
+
+    {
+        9, -147, -147, -147, -147, -147, -147,   55, -147, -147,
+     -147, -147, -147,   58, -147, -147, -147, -147, -147,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -147
+
+    },
+
+    {
+        9, -148, -148, -148, -148, -148, -148,   55, -148, -148,
+     -148, -148, -148,   58, -148, -148, -148, -148, -148,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  169,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -148
+    },
+
+    {
+        9, -149, -149, -149, -149, -149, -149,   55, -149, -149,
+     -149, -149, -149,   58, -149, -149, -149, -149, -149,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -149
+
+    },
+
+    {
+        9, -150, -150, -150, -150, -150, -150,   55, -150, -150,
+     -150, -150, -150,   58, -150, -150, -150, -150, -150,   58,
+       58,   58,   58,   58,  170,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -150
+    },
+
+    {
+        9, -151, -151, -151, -151, -151, -151,   55, -151, -151,
+     -151, -151, -151,   58, -151, -151, -151, -151, -151,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,  171,   58,   58,   58,   58,   58,   58,   58,
+       58, -151
+
+    },
+
+    {
+        9, -152, -152, -152, -152, -152, -152,   55, -152, -152,
+     -152, -152, -152,   58, -152, -152, -152, -152, -152,   58,
+       58,   58,   58,   58,  172,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -152
+    },
+
+    {
+        9, -153, -153, -153, -153, -153, -153,   55, -153, -153,
+     -153, -153, -153,   58, -153, -153, -153, -153, -153,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  173,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -153
+
+    },
+
+    {
+        9, -154, -154, -154, -154, -154, -154,   55, -154, -154,
+     -154, -154, -154,   58, -154, -154, -154, -154, -154,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  174,   58,   58,   58,
+       58, -154
+    },
+
+    {
+        9, -155, -155, -155, -155, -155, -155,   55, -155, -155,
+     -155, -155, -155,   58, -155, -155, -155, -155, -155,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -155
+
+    },
+
+    {
+        9, -156, -156, -156, -156, -156, -156,   55, -156, -156,
+     -156, -156, -156,   58, -156, -156, -156, -156, -156,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  175,   58,   58,   58,
+       58, -156
+    },
+
+    {
+        9, -157, -157, -157, -157, -157, -157,   55, -157, -157,
+     -157, -157, -157,   58, -157, -157, -157, -157, -157,   58,
+       58,   58,   58,   58,  176,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -157
+
+    },
+
+    {
+        9, -158, -158, -158, -158, -158, -158,   55, -158, -158,
+     -158, -158, -158,   58, -158, -158, -158, -158, -158,   58,
+       58,   58,   58,   58,   58,   58,  177,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -158
+    },
+
+    {
+        9, -159, -159, -159, -159, -159, -159,   55, -159, -159,
+     -159, -159, -159,   58, -159, -159, -159, -159, -159,   58,
+      178,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -159
+
+    },
+
+    {
+        9, -160, -160, -160, -160, -160, -160,   55, -160, -160,
+     -160, -160, -160,   58, -160, -160, -160, -160, -160,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,  179,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -160
+    },
+
+    {
+        9, -161, -161, -161, -161, -161, -161,   55, -161, -161,
+     -161, -161, -161,   58, -161, -161, -161, -161, -161,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -161
+
+    },
+
+    {
+        9, -162, -162, -162, -162, -162, -162,   55, -162, -162,
+     -162, -162, -162,   58, -162, -162, -162, -162, -162,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  180,   58,   58,   58,
+       58, -162
+    },
+
+    {
+        9, -163, -163, -163, -163, -163, -163,   55, -163, -163,
+     -163, -163, -163,   58, -163, -163, -163, -163, -163,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -163
+
+    },
+
+    {
+        9, -164, -164, -164, -164, -164, -164,   55, -164, -164,
+     -164, -164, -164,   58, -164, -164, -164, -164, -164,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,  181,   58,   58,   58,   58,   58,   58,   58,
+       58, -164
+    },
+
+    {
+        9, -165, -165, -165, -165, -165, -165,   55, -165, -165,
+     -165, -165, -165,   58, -165, -165, -165, -165, -165,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  182,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -165
+
+    },
+
+    {
+        9, -166, -166, -166, -166, -166, -166,   55, -166, -166,
+     -166, -166, -166,   58, -166, -166, -166, -166, -166,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  183,   58,   58,   58,
+       58, -166
+    },
+
+    {
+        9, -167, -167, -167, -167, -167, -167,   55, -167, -167,
+     -167, -167, -167,   58, -167, -167, -167, -167, -167,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  184,   58,   58,   58,   58,
+       58, -167
+
+    },
+
+    {
+        9, -168, -168, -168, -168, -168, -168,   55, -168, -168,
+     -168, -168, -168,   58, -168, -168, -168, -168, -168,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  185,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -168
+    },
+
+    {
+        9, -169, -169, -169, -169, -169, -169,   55, -169, -169,
+     -169, -169, -169,   58, -169, -169, -169, -169, -169,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  186,   58,   58,
+       58, -169
+
+    },
+
+    {
+        9, -170, -170, -170, -170, -170, -170,   55, -170, -170,
+     -170, -170, -170,   58, -170, -170, -170, -170, -170,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  187,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -170
+    },
+
+    {
+        9, -171, -171, -171, -171, -171, -171,   55, -171, -171,
+     -171, -171, -171,   58, -171, -171, -171, -171, -171,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  188,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -171
+
+    },
+
+    {
+        9, -172, -172, -172, -172, -172, -172,   55, -172, -172,
+     -172, -172, -172,   58, -172, -172, -172, -172, -172,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  189,   58,   58,   58,   58,
+       58, -172
+    },
+
+    {
+        9, -173, -173, -173, -173, -173, -173,   55, -173, -173,
+     -173, -173, -173,   58, -173, -173, -173, -173, -173,   58,
+      190,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -173
+
+    },
+
+    {
+        9, -174, -174, -174, -174, -174, -174,   55, -174, -174,
+     -174, -174, -174,   58, -174, -174, -174, -174, -174,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -174
+    },
+
+    {
+        9, -175, -175, -175, -175, -175, -175,   55, -175, -175,
+     -175, -175, -175,   58, -175, -175, -175, -175, -175,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -175
+
+    },
+
+    {
+        9, -176, -176, -176, -176, -176, -176,   55, -176, -176,
+     -176, -176, -176,   58, -176, -176, -176, -176, -176,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -176
+    },
+
+    {
+        9, -177, -177, -177, -177, -177, -177,   55, -177, -177,
+     -177, -177, -177,   58, -177, -177, -177, -177, -177,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -177
+
+    },
+
+    {
+        9, -178, -178, -178, -178, -178, -178,   55, -178, -178,
+     -178, -178, -178,   58, -178, -178, -178, -178, -178,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  191,   58,   58,   58,
+       58, -178
+    },
+
+    {
+        9, -179, -179, -179, -179, -179, -179,   55, -179, -179,
+     -179, -179, -179,   58, -179, -179, -179, -179, -179,   58,
+       58,   58,   58,   58,  192,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -179
+
+    },
+
+    {
+        9, -180, -180, -180, -180, -180, -180,   55, -180, -180,
+     -180, -180, -180,   58, -180, -180, -180, -180, -180,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -180
+    },
+
+    {
+        9, -181, -181, -181, -181, -181, -181,   55, -181, -181,
+     -181, -181, -181,   58, -181, -181, -181, -181, -181,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,  193,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -181
+
+    },
+
+    {
+        9, -182, -182, -182, -182, -182, -182,   55, -182, -182,
+     -182, -182, -182,   58, -182, -182, -182, -182, -182,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  194,   58,   58,   58,   58,
+       58, -182
+    },
+
+    {
+        9, -183, -183, -183, -183, -183, -183,   55, -183, -183,
+     -183, -183, -183,   58, -183, -183, -183, -183, -183,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -183
+
+    },
+
+    {
+        9, -184, -184, -184, -184, -184, -184,   55, -184, -184,
+     -184, -184, -184,   58, -184, -184, -184, -184, -184,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -184
+    },
+
+    {
+        9, -185, -185, -185, -185, -185, -185,   55, -185, -185,
+     -185, -185, -185,   58, -185, -185, -185, -185, -185,   58,
+       58,   58,  195,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -185
+
+    },
+
+    {
+        9, -186, -186, -186, -186, -186, -186,   55, -186, -186,
+     -186, -186, -186,   58, -186, -186, -186, -186, -186,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -186
+    },
+
+    {
+        9, -187, -187, -187, -187, -187, -187,   55, -187, -187,
+     -187, -187, -187,   58, -187, -187, -187, -187, -187,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  196,   58,   58,
+       58, -187
+
+    },
+
+    {
+        9, -188, -188, -188, -188, -188, -188,   55, -188, -188,
+     -188, -188, -188,   58, -188, -188, -188, -188, -188,   58,
+       58,   58,   58,   58,   58,  197,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -188
+    },
+
+    {
+        9, -189, -189, -189, -189, -189, -189,   55, -189, -189,
+     -189, -189, -189,   58, -189, -189, -189, -189, -189,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -189
+
+    },
+
+    {
+        9, -190, -190, -190, -190, -190, -190,   55, -190, -190,
+     -190, -190, -190,   58, -190, -190, -190, -190, -190,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,  198,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -190
+    },
+
+    {
+        9, -191, -191, -191, -191, -191, -191,   55, -191, -191,
+     -191, -191, -191,   58, -191, -191, -191, -191, -191,   58,
+       58,   58,   58,   58,  199,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -191
+
+    },
+
+    {
+        9, -192, -192, -192, -192, -192, -192,   55, -192, -192,
+     -192, -192, -192,   58, -192, -192, -192, -192, -192,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -192
+    },
+
+    {
+        9, -193, -193, -193, -193, -193, -193,   55, -193, -193,
+     -193, -193, -193,   58, -193, -193, -193, -193, -193,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -193
+
+    },
+
+    {
+        9, -194, -194, -194, -194, -194, -194,   55, -194, -194,
+     -194, -194, -194,   58, -194, -194, -194, -194, -194,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  200,   58,   58,   58,
+       58, -194
+    },
+
+    {
+        9, -195, -195, -195, -195, -195, -195,   55, -195, -195,
+     -195, -195, -195,   58, -195, -195, -195, -195, -195,   58,
+       58,   58,   58,   58,  201,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -195
+
+    },
+
+    {
+        9, -196, -196, -196, -196, -196, -196,   55, -196, -196,
+     -196, -196, -196,   58, -196, -196, -196, -196, -196,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -196
+    },
+
+    {
+        9, -197, -197, -197, -197, -197, -197,   55, -197, -197,
+     -197, -197, -197,   58, -197, -197, -197, -197, -197,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  202,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -197
+
+    },
+
+    {
+        9, -198, -198, -198, -198, -198, -198,   55, -198, -198,
+     -198, -198, -198,   58, -198, -198, -198, -198, -198,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -198
+    },
+
+    {
+        9, -199, -199, -199, -199, -199, -199,   55, -199, -199,
+     -199, -199, -199,   58, -199, -199, -199, -199, -199,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -199
+
+    },
+
+    {
+        9, -200, -200, -200, -200, -200, -200,   55, -200, -200,
+     -200, -200, -200,   58, -200, -200, -200, -200, -200,   58,
+      203,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -200
+    },
+
+    {
+        9, -201, -201, -201, -201, -201, -201,   55, -201, -201,
+     -201, -201, -201,   58, -201, -201, -201, -201, -201,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -201
+
+    },
+
+    {
+        9, -202, -202, -202, -202, -202, -202,   55, -202, -202,
+     -202, -202, -202,   58, -202, -202, -202, -202, -202,   58,
+       58,   58,   58,   58,   58,   58,  204,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -202
+    },
+
+    {
+        9, -203, -203, -203, -203, -203, -203,   55, -203, -203,
+     -203, -203, -203,   58, -203, -203, -203, -203, -203,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  205,   58,   58,   58,
+       58, -203
+
+    },
+
+    {
+        9, -204, -204, -204, -204, -204, -204,   55, -204, -204,
+     -204, -204, -204,   58, -204, -204, -204, -204, -204,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -204
+    },
+
+    {
+        9, -205, -205, -205, -205, -205, -205,   55, -205, -205,
+     -205, -205, -205,   58, -205, -205, -205, -205, -205,   58,
+       58,   58,   58,   58,  206,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -205
+
+    },
+
+    {
+        9, -206, -206, -206, -206, -206, -206,   55, -206, -206,
+     -206, -206, -206,   58, -206, -206, -206, -206, -206,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58, -206
+    },
+
+    } ;
+
+static yy_state_type yy_get_previous_state ( void );
+static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
+static int yy_get_next_buffer ( void );
+static void yynoreturn yy_fatal_error ( const char* msg  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (yy_size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+#define YY_NUM_RULES 63
+#define YY_END_OF_BUFFER 64
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static const flex_int16_t yy_accept[207] =
+    {   0,
+        2,    2,    0,    0,    0,    0,    0,    0,   64,   50,
+        2,    4,   42,   47,    1,   49,   50,   43,   44,   50,
+       48,   50,   38,   36,   40,   50,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48,   48,   48,   50,
+       51,   53,   52,   62,   59,   61,   55,   58,   57,   54,
+       56,    2,   37,    1,   49,   35,   46,   48,   45,   39,
+       41,    3,   48,   48,   48,   48,   48,   48,   18,   48,
+       48,   48,   48,   48,   25,   48,   48,   48,   48,   48,
+       48,   48,   48,   34,   51,   51,   62,   59,   61,   60,
+       55,   54,   56,   48,   48,   48,   48,   48,   48,   48,
+
+       48,   17,   48,   20,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,    5,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   16,   48,   48,   22,   48,
+       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   14,   48,   19,   48,
+       48,   48,   48,   48,   28,   48,   48,   48,   48,   48,
+        6,   48,    8,   48,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   27,   29,   30,   31,   48,   48,    7,
+       48,   48,   11,   12,   48,   15,   48,   48,   24,   48,
+       48,   33,    9,   48,   48,   21,   48,   26,   32,   48,
+
+       13,   48,   48,   23,   48,   10
+    } ;
+
+static const YY_CHAR yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    7,    1,    8,    9,   10,
+       11,    1,   12,    1,   13,    1,    1,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   14,    1,   15,
+       16,   17,    1,    1,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        1,   18,    1,    1,   19,    1,   20,   21,   22,   23,
+
+       24,   25,   26,   27,   28,   13,   13,   29,   30,   31,
+       32,   33,   13,   34,   35,   36,   37,   38,   13,   39,
+       40,   13,    1,   41,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+/* Table of booleans, true if rule could match eol. */
+static const flex_int32_t yy_rule_can_match_eol[64] =
+    {   0,
+0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 
+    1, 1, 0, 0,     };
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ */
+
+#include <assert.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "lkc.h"
+#include "parser.tab.h"
+
+#define YY_DECL		static int yylex1(void)
+
+#define START_STRSIZE	16
+
+static struct {
+	struct file *file;
+	int lineno;
+} current_pos;
+
+static int prev_prev_token = T_EOL;
+static int prev_token = T_EOL;
+static char *text;
+static int text_size, text_asize;
+
+struct buffer {
+	struct buffer *parent;
+	YY_BUFFER_STATE state;
+};
+
+static struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static char *expand_token(const char *in, size_t n);
+static void append_expanded_string(const char *in);
+static void zconf_endhelp(void);
+static void zconf_endfile(void);
+
+static void new_string(void)
+{
+	text = xmalloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_size = 0;
+	*text = 0;
+}
+
+static void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		new_size += START_STRSIZE - 1;
+		new_size &= -START_STRSIZE;
+		text = xrealloc(text, new_size);
+		text_asize = new_size;
+	}
+	memcpy(text + text_size, str, size);
+	text_size += size;
+	text[text_size] = 0;
+}
+
+static void alloc_string(const char *str, int size)
+{
+	text = xmalloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+
+static void warn_ignored_character(char chr)
+{
+	fprintf(stderr,
+	        "%s:%d:warning: ignoring unsupported character '%c'\n",
+	        current_file->name, yylineno, chr);
+}
+
+#define INITIAL 0
+#define ASSIGN_VAL 1
+#define HELP 2
+#define STRING 3
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals ( void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy ( void );
+
+int yyget_debug ( void );
+
+void yyset_debug ( int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra ( void );
+
+void yyset_extra ( YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in ( void );
+
+void yyset_in  ( FILE * _in_str  );
+
+FILE *yyget_out ( void );
+
+void yyset_out  ( FILE * _out_str  );
+
+			yy_size_t yyget_leng ( void );
+
+char *yyget_text ( void );
+
+int yyget_lineno ( void );
+
+void yyset_lineno ( int _line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap ( void );
+#else
+extern int yywrap ( void );
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+    
+    static void yyunput ( int c, char *buf_ptr  );
+    
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy ( char *, const char *, int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen ( const char * );
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+static int yyinput ( void );
+#else
+static int input ( void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	errno=0; \
+	while ( (result = (int) read( fileno(yyin), buf, (yy_size_t) max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(yyin); \
+	}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK /*LINTED*/break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	yy_state_type yy_current_state;
+	char *yy_cp, *yy_bp;
+	int yy_act;
+    
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer( yyin, YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state(  );
+		}
+
+	{
+
+	char open_quote = 0;
+
+	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][ yy_ec[YY_SC_TO_UI(*yy_cp)]  ]) > 0 )
+			++yy_cp;
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
+			{
+			yy_size_t yyl;
+			for ( yyl = 0; yyl < yyleng; ++yyl )
+				if ( yytext[yyl] == '\n' )
+					
+    yylineno++;
+;
+			}
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+YY_RULE_SETUP
+/* ignore comment */
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+/* whitespaces */
+	YY_BREAK
+case 3:
+/* rule 3 can match eol */
+YY_RULE_SETUP
+/* escaped new line */
+	YY_BREAK
+case 4:
+/* rule 4 can match eol */
+YY_RULE_SETUP
+return T_EOL;
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+return T_BOOL;
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+return T_CHOICE;
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+return T_COMMENT;
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+return T_CONFIG;
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+return T_DEF_BOOL;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+return T_DEF_TRISTATE;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+return T_DEFAULT;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+return T_DEPENDS;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+return T_ENDCHOICE;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+return T_ENDIF;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+return T_ENDMENU;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+return T_HELP;
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+return T_HEX;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+return T_IF;
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+return T_IMPLY;
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+return T_INT;
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+return T_MAINMENU;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+return T_MENU;
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+return T_MENUCONFIG;
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+return T_MODULES;
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+return T_ON;
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+return T_OPTIONAL;
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+return T_PROMPT;
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+return T_RANGE;
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+return T_SELECT;
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+return T_SOURCE;
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+return T_STRING;
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+return T_TRISTATE;
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+return T_VISIBLE;
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+return T_OR;
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+return T_AND;
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+return T_EQUAL;
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+return T_UNEQUAL;
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+return T_LESS;
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+return T_LESS_EQUAL;
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+return T_GREATER;
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+return T_GREATER_EQUAL;
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+return T_NOT;
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+return T_OPEN_PAREN;
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+return T_CLOSE_PAREN;
+	YY_BREAK
+case 45:
+YY_RULE_SETUP
+return T_COLON_EQUAL;
+	YY_BREAK
+case 46:
+YY_RULE_SETUP
+return T_PLUS_EQUAL;
+	YY_BREAK
+case 47:
+YY_RULE_SETUP
+{
+				open_quote = yytext[0];
+				new_string();
+				BEGIN(STRING);
+			}
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+{
+				alloc_string(yytext, yyleng);
+				yylval.string = text;
+				return T_WORD;
+			}
+	YY_BREAK
+case 49:
+YY_RULE_SETUP
+{
+				/* this token includes at least one '$' */
+				yylval.string = expand_token(yytext, yyleng);
+				if (strlen(yylval.string))
+					return T_WORD;
+				free(yylval.string);
+			}
+	YY_BREAK
+case 50:
+YY_RULE_SETUP
+warn_ignored_character(*yytext);
+	YY_BREAK
+
+case 51:
+YY_RULE_SETUP
+{
+		alloc_string(yytext, yyleng);
+		yylval.string = text;
+		return T_ASSIGN_VAL;
+	}
+	YY_BREAK
+case 52:
+/* rule 52 can match eol */
+YY_RULE_SETUP
+{ BEGIN(INITIAL); return T_EOL; }
+	YY_BREAK
+case 53:
+YY_RULE_SETUP
+
+	YY_BREAK
+
+case 54:
+YY_RULE_SETUP
+append_expanded_string(yytext);
+	YY_BREAK
+case 55:
+YY_RULE_SETUP
+{
+		append_string(yytext, yyleng);
+	}
+	YY_BREAK
+case 56:
+YY_RULE_SETUP
+{
+		append_string(yytext + 1, yyleng - 1);
+	}
+	YY_BREAK
+case 57:
+YY_RULE_SETUP
+{
+		if (open_quote == yytext[0]) {
+			BEGIN(INITIAL);
+			yylval.string = text;
+			return T_WORD_QUOTE;
+		} else
+			append_string(yytext, 1);
+	}
+	YY_BREAK
+case 58:
+/* rule 58 can match eol */
+YY_RULE_SETUP
+{
+		fprintf(stderr,
+			"%s:%d:warning: multi-line strings not supported\n",
+			zconf_curname(), zconf_lineno());
+		unput('\n');
+		BEGIN(INITIAL);
+		yylval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case YY_STATE_EOF(STRING):
+{
+		BEGIN(INITIAL);
+		yylval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+
+case 59:
+YY_RULE_SETUP
+{
+		int ts, i;
+
+		ts = 0;
+		for (i = 0; i < yyleng; i++) {
+			if (yytext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+	}
+	YY_BREAK
+case 60:
+/* rule 60 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
+YY_LINENO_REWIND_TO(yy_cp - 1);
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up yytext again */
+YY_RULE_SETUP
+{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+case 61:
+/* rule 61 can match eol */
+YY_RULE_SETUP
+{
+		append_string("\n", 1);
+	}
+	YY_BREAK
+case 62:
+YY_RULE_SETUP
+{
+		while (yyleng) {
+			if ((yytext[yyleng-1] != ' ') && (yytext[yyleng-1] != '\t'))
+				break;
+			yyleng--;
+		}
+		append_string(yytext, yyleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	YY_BREAK
+case YY_STATE_EOF(HELP):
+{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(ASSIGN_VAL):
+{
+	BEGIN(INITIAL);
+
+	if (prev_token != T_EOL && prev_token != T_HELPTEXT)
+		fprintf(stderr, "%s:%d:warning: no new line at end of file\n",
+			current_file->name, yylineno);
+
+	if (current_file) {
+		zconf_endfile();
+		return T_EOL;
+	}
+	fclose(yyin);
+	yyterminate();
+}
+	YY_BREAK
+case 63:
+YY_RULE_SETUP
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap(  ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of user's declarations */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	char *source = (yytext_ptr);
+	int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			yy_size_t num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				yy_size_t new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc( (void *) b->yy_ch_buf,
+							 (yy_size_t) (b->yy_buf_size + 2)  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = NULL;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart( yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
+			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+		/* "- 2" to take care of EOB's */
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	yy_state_type yy_current_state;
+	char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	int yy_is_jam;
+    
+	yy_current_state = yy_nxt[yy_current_state][1];
+	yy_is_jam = (yy_current_state <= 0);
+
+		return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_UNPUT
+
+    static void yyunput (int c, char * yy_bp )
+{
+	char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		yy_size_t number_to_move = (yy_n_chars) + 2;
+		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+    if ( c == '\n' ){
+        --yylineno;
+    }
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart( yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap(  ) )
+						return 0;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	if ( c == '\n' )
+		
+    yylineno++;
+;
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer( yyin, YY_BUF_SIZE );
+	}
+
+	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
+	yy_load_buffer_state(  );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state(  );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer( b, file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree( (void *) b->yy_ch_buf  );
+
+	yyfree( (void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer( b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state(  );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state(  );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state(  );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	yy_size_t num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		yy_size_t grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return NULL;
+
+	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = NULL;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer( b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (const char * yystr )
+{
+    
+	return yy_scan_bytes( yystr, (int) strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, yy_size_t  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	yy_size_t i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = (yy_size_t) (_yybytes_len + 2);
+	buf = (char *) yyalloc( n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer( buf, n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yynoreturn yy_fatal_error (const char* msg )
+{
+			fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        yy_size_t yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+    
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+yy_size_t yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param _line_number line number
+ * 
+ */
+void yyset_lineno (int  _line_number )
+{
+    
+    yylineno = _line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param _in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  _in_str )
+{
+        yyin = _in_str ;
+}
+
+void yyset_out (FILE *  _out_str )
+{
+        yyout = _out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  _bdebug )
+{
+        yy_flex_debug = _bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    /* We do not touch yylineno unless the option is enabled. */
+    yylineno =  1;
+    
+    (yy_buffer_stack) = NULL;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = NULL;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = NULL;
+    yyout = NULL;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer( YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, const char * s2, int n )
+{
+		
+	int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (const char * s )
+{
+	int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+			return malloc(size);
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+		
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return realloc(ptr, size);
+}
+
+void yyfree (void * ptr )
+{
+			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+/* second stage lexer */
+int yylex(void)
+{
+	int token;
+
+repeat:
+	token = yylex1();
+
+	if (prev_token == T_EOL || prev_token == T_HELPTEXT) {
+		if (token == T_EOL) {
+			/* Do not pass unneeded T_EOL to the parser. */
+			goto repeat;
+		} else {
+			/*
+			 * For the parser, update file/lineno at the first token
+			 * of each statement. Generally, \n is a statement
+			 * terminator in Kconfig, but it is not always true
+			 * because \n could be escaped by a backslash.
+			 */
+			current_pos.file = current_file;
+			current_pos.lineno = yylineno;
+		}
+	}
+
+	if (prev_prev_token == T_EOL && prev_token == T_WORD &&
+	    (token == T_EQUAL || token == T_COLON_EQUAL || token == T_PLUS_EQUAL))
+		BEGIN(ASSIGN_VAL);
+
+	prev_prev_token = prev_token;
+	prev_token = token;
+
+	return token;
+}
+
+static char *expand_token(const char *in, size_t n)
+{
+	char *out;
+	int c;
+	char c2;
+	const char *rest, *end;
+
+	new_string();
+	append_string(in, n);
+
+	/*
+	 * get the whole line because we do not know the end of token.
+	 * input() returns 0 (not EOF!) when it reachs the end of file.
+	 */
+	while ((c = input()) != 0) {
+		if (c == '\n') {
+			unput(c);
+			break;
+		}
+		c2 = c;
+		append_string(&c2, 1);
+	}
+
+	rest = text;
+	out = expand_one_token(&rest);
+
+	/* push back unused characters to the input stream */
+	end = rest + strlen(rest);
+	while (end > rest)
+		unput(*--end);
+
+	free(text);
+
+	return out;
+}
+
+static void append_expanded_string(const char *str)
+{
+	const char *end;
+	char *res;
+
+	str++;
+
+	res = expand_dollar(&str);
+
+	/* push back unused characters to the input stream */
+	end = str + strlen(str);
+	while (end > str)
+		unput(*--end);
+
+	append_string(res, strlen(res));
+
+	free(res);
+}
+
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	yylval.string = text;
+	BEGIN(INITIAL);
+}
+
+/*
+ * Try to open specified file with following names:
+ * ./name
+ * $(srctree)/name
+ * The latter is used when srctree is separate from objtree
+ * when compiling the kernel.
+ * Return NULL if file is not found.
+ */
+FILE *zconf_fopen(const char *name)
+{
+	char *env, fullname[PATH_MAX+1];
+	FILE *f;
+
+	f = fopen(name, "r");
+	if (!f && name != NULL && name[0] != '/') {
+		env = getenv(SRCTREE);
+		if (env) {
+			snprintf(fullname, sizeof(fullname),
+				 "%s/%s", env, name);
+			f = fopen(fullname, "r");
+		}
+	}
+	return f;
+}
+
+void zconf_initscan(const char *name)
+{
+	yyin = zconf_fopen(name);
+	if (!yyin) {
+		fprintf(stderr, "can't find file %s\n", name);
+		exit(1);
+	}
+
+	current_buf = xmalloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	yylineno = 1;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *iter;
+	struct file *file = file_lookup(name);
+	struct buffer *buf = xmalloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	yyin = zconf_fopen(file->name);
+	if (!yyin) {
+		fprintf(stderr, "%s:%d: can't open file \"%s\"\n",
+			zconf_curname(), zconf_lineno(), file->name);
+		exit(1);
+	}
+	yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	current_file->lineno = yylineno;
+	file->parent = current_file;
+
+	for (iter = current_file; iter; iter = iter->parent) {
+		if (!strcmp(iter->name, file->name)) {
+			fprintf(stderr,
+				"Recursive inclusion detected.\n"
+				"Inclusion path:\n"
+				"  current file : %s\n", file->name);
+			iter = file;
+			do {
+				iter = iter->parent;
+				fprintf(stderr, "  included from: %s:%d\n",
+					iter->name, iter->lineno - 1);
+			} while (strcmp(iter->name, file->name));
+			exit(1);
+		}
+	}
+
+	yylineno = 1;
+	current_file = file;
+}
+
+static void zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file = current_file->parent;
+	if (current_file)
+		yylineno = current_file->lineno;
+
+	parent = current_buf->parent;
+	if (parent) {
+		fclose(yyin);
+		yy_delete_buffer(YY_CURRENT_BUFFER);
+		yy_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+}
+
+int zconf_lineno(void)
+{
+	return current_pos.lineno;
+}
+
+const char *zconf_curname(void)
+{
+	return current_pos.file ? current_pos.file->name : "<none>";
+}
+
diff --git a/scripts/kconfig/lexer.lex.o b/scripts/kconfig/lexer.lex.o
new file mode 100644
index 000000000..458b80bda
Binary files /dev/null and b/scripts/kconfig/lexer.lex.o differ
diff --git a/scripts/kconfig/menu.o b/scripts/kconfig/menu.o
new file mode 100644
index 000000000..61cb11211
Binary files /dev/null and b/scripts/kconfig/menu.o differ
diff --git a/scripts/kconfig/parser.tab.c b/scripts/kconfig/parser.tab.c
new file mode 100644
index 000000000..bf4889740
--- /dev/null
+++ b/scripts/kconfig/parser.tab.c
@@ -0,0 +1,2564 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_HELPTEXT = 258,
+     T_WORD = 259,
+     T_WORD_QUOTE = 260,
+     T_BOOL = 261,
+     T_CHOICE = 262,
+     T_CLOSE_PAREN = 263,
+     T_COLON_EQUAL = 264,
+     T_COMMENT = 265,
+     T_CONFIG = 266,
+     T_DEFAULT = 267,
+     T_DEF_BOOL = 268,
+     T_DEF_TRISTATE = 269,
+     T_DEPENDS = 270,
+     T_ENDCHOICE = 271,
+     T_ENDIF = 272,
+     T_ENDMENU = 273,
+     T_HELP = 274,
+     T_HEX = 275,
+     T_IF = 276,
+     T_IMPLY = 277,
+     T_INT = 278,
+     T_MAINMENU = 279,
+     T_MENU = 280,
+     T_MENUCONFIG = 281,
+     T_MODULES = 282,
+     T_ON = 283,
+     T_OPEN_PAREN = 284,
+     T_OPTIONAL = 285,
+     T_PLUS_EQUAL = 286,
+     T_PROMPT = 287,
+     T_RANGE = 288,
+     T_SELECT = 289,
+     T_SOURCE = 290,
+     T_STRING = 291,
+     T_TRISTATE = 292,
+     T_VISIBLE = 293,
+     T_EOL = 294,
+     T_ASSIGN_VAL = 295,
+     T_OR = 296,
+     T_AND = 297,
+     T_UNEQUAL = 298,
+     T_EQUAL = 299,
+     T_GREATER_EQUAL = 300,
+     T_GREATER = 301,
+     T_LESS_EQUAL = 302,
+     T_LESS = 303,
+     T_NOT = 304
+   };
+#endif
+/* Tokens.  */
+#define T_HELPTEXT 258
+#define T_WORD 259
+#define T_WORD_QUOTE 260
+#define T_BOOL 261
+#define T_CHOICE 262
+#define T_CLOSE_PAREN 263
+#define T_COLON_EQUAL 264
+#define T_COMMENT 265
+#define T_CONFIG 266
+#define T_DEFAULT 267
+#define T_DEF_BOOL 268
+#define T_DEF_TRISTATE 269
+#define T_DEPENDS 270
+#define T_ENDCHOICE 271
+#define T_ENDIF 272
+#define T_ENDMENU 273
+#define T_HELP 274
+#define T_HEX 275
+#define T_IF 276
+#define T_IMPLY 277
+#define T_INT 278
+#define T_MAINMENU 279
+#define T_MENU 280
+#define T_MENUCONFIG 281
+#define T_MODULES 282
+#define T_ON 283
+#define T_OPEN_PAREN 284
+#define T_OPTIONAL 285
+#define T_PLUS_EQUAL 286
+#define T_PROMPT 287
+#define T_RANGE 288
+#define T_SELECT 289
+#define T_SOURCE 290
+#define T_STRING 291
+#define T_TRISTATE 292
+#define T_VISIBLE 293
+#define T_EOL 294
+#define T_ASSIGN_VAL 295
+#define T_OR 296
+#define T_AND 297
+#define T_UNEQUAL 298
+#define T_EQUAL 299
+#define T_GREATER_EQUAL 300
+#define T_GREATER 301
+#define T_LESS_EQUAL 302
+#define T_LESS 303
+#define T_NOT 304
+
+
+
+
+/* Copy the first part of user declarations.  */
+
+
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#include "lkc.h"
+#include "internal.h"
+
+#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+
+#define PRINTD		0x0001
+#define DEBUG_PARSE	0x0002
+
+int cdebug = PRINTD;
+
+static void yyerror(const char *err);
+static void zconfprint(const char *err, ...);
+static void zconf_error(const char *err, ...);
+static bool zconf_endtoken(const char *tokenname,
+			   const char *expected_tokenname);
+
+struct symbol *symbol_hash[SYMBOL_HASHSIZE];
+
+struct menu *current_menu, *current_entry;
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+
+{
+	char *string;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+	enum symbol_type type;
+	enum variable_flavor flavor;
+}
+/* Line 193 of yacc.c.  */
+
+	YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 216 of yacc.c.  */
+
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss;
+  YYSTYPE yyvs;
+  };
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  6
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   186
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  50
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  47
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  105
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  184
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   304
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     6,     8,    12,    13,    16,    19,    22,
+      25,    28,    31,    34,    37,    42,    46,    47,    50,    53,
+      56,    60,    64,    67,    71,    74,    75,    78,    81,    84,
+      88,    93,    98,   103,   108,   114,   117,   121,   124,   126,
+     130,   131,   134,   137,   140,   145,   149,   152,   157,   159,
+     161,   163,   165,   167,   169,   171,   173,   175,   179,   181,
+     185,   189,   193,   196,   198,   202,   203,   206,   209,   213,
+     217,   220,   221,   224,   227,   230,   235,   239,   240,   243,
+     246,   249,   252,   253,   256,   258,   262,   266,   270,   274,
+     278,   282,   286,   289,   293,   297,   299,   301,   303,   304,
+     306,   311,   313,   315,   317,   318
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      51,     0,    -1,    52,    53,    -1,    53,    -1,    24,     5,
+      39,    -1,    -1,    53,    94,    -1,    53,    64,    -1,    53,
+      81,    -1,    53,    56,    -1,    53,    72,    -1,    53,    77,
+      -1,    53,    58,    -1,    53,    79,    -1,    53,     4,     1,
+      39,    -1,    53,     1,    39,    -1,    -1,    54,    81,    -1,
+      54,    56,    -1,    54,    73,    -1,    54,     1,    39,    -1,
+      11,    91,    39,    -1,    55,    59,    -1,    26,    91,    39,
+      -1,    57,    59,    -1,    -1,    59,    60,    -1,    59,    85,
+      -1,    59,    84,    -1,    67,    87,    39,    -1,    32,     5,
+      89,    39,    -1,    69,    90,    89,    39,    -1,    34,    91,
+      89,    39,    -1,    22,    91,    89,    39,    -1,    33,    92,
+      92,    89,    39,    -1,    27,    39,    -1,     7,    93,    39,
+      -1,    61,    65,    -1,    88,    -1,    62,    54,    63,    -1,
+      -1,    65,    66,    -1,    65,    85,    -1,    65,    84,    -1,
+      32,     5,    89,    39,    -1,    68,    87,    39,    -1,    30,
+      39,    -1,    12,    91,    89,    39,    -1,    68,    -1,    23,
+      -1,    20,    -1,    36,    -1,     6,    -1,    37,    -1,    12,
+      -1,    13,    -1,    14,    -1,    21,    90,    39,    -1,    88,
+      -1,    70,    53,    71,    -1,    70,    54,    71,    -1,    25,
+       5,    39,    -1,    74,    78,    -1,    88,    -1,    75,    53,
+      76,    -1,    -1,    78,    86,    -1,    78,    85,    -1,    35,
+       5,    39,    -1,    10,     5,    39,    -1,    80,    82,    -1,
+      -1,    82,    85,    -1,    19,    39,    -1,    83,     3,    -1,
+      15,    28,    90,    39,    -1,    38,    89,    39,    -1,    -1,
+       5,    89,    -1,    18,    39,    -1,    16,    39,    -1,    17,
+      39,    -1,    -1,    21,    90,    -1,    92,    -1,    92,    48,
+      92,    -1,    92,    47,    92,    -1,    92,    46,    92,    -1,
+      92,    45,    92,    -1,    92,    44,    92,    -1,    92,    43,
+      92,    -1,    29,    90,     8,    -1,    49,    90,    -1,    90,
+      41,    90,    -1,    90,    42,    90,    -1,     4,    -1,    91,
+      -1,     5,    -1,    -1,     4,    -1,     4,    95,    96,    39,
+      -1,    44,    -1,     9,    -1,    31,    -1,    -1,    40,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   109,   109,   109,   113,   118,   120,   121,   122,   123,
+     124,   125,   126,   127,   128,   129,   132,   134,   135,   136,
+     137,   142,   149,   154,   161,   170,   172,   173,   174,   177,
+     185,   191,   201,   207,   213,   219,   229,   239,   244,   252,
+     255,   257,   258,   259,   262,   268,   275,   281,   289,   290,
+     291,   292,   295,   296,   299,   300,   301,   305,   313,   321,
+     324,   329,   336,   341,   349,   352,   354,   355,   358,   367,
+     374,   377,   379,   384,   390,   408,   415,   422,   424,   429,
+     430,   431,   434,   435,   438,   439,   440,   441,   442,   443,
+     444,   445,   446,   447,   448,   452,   454,   455,   458,   459,
+     463,   466,   467,   468,   472,   473
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "T_HELPTEXT", "T_WORD", "T_WORD_QUOTE",
+  "T_BOOL", "T_CHOICE", "T_CLOSE_PAREN", "T_COLON_EQUAL", "T_COMMENT",
+  "T_CONFIG", "T_DEFAULT", "T_DEF_BOOL", "T_DEF_TRISTATE", "T_DEPENDS",
+  "T_ENDCHOICE", "T_ENDIF", "T_ENDMENU", "T_HELP", "T_HEX", "T_IF",
+  "T_IMPLY", "T_INT", "T_MAINMENU", "T_MENU", "T_MENUCONFIG", "T_MODULES",
+  "T_ON", "T_OPEN_PAREN", "T_OPTIONAL", "T_PLUS_EQUAL", "T_PROMPT",
+  "T_RANGE", "T_SELECT", "T_SOURCE", "T_STRING", "T_TRISTATE", "T_VISIBLE",
+  "T_EOL", "T_ASSIGN_VAL", "T_OR", "T_AND", "T_UNEQUAL", "T_EQUAL",
+  "T_GREATER_EQUAL", "T_GREATER", "T_LESS_EQUAL", "T_LESS", "T_NOT",
+  "$accept", "input", "mainmenu_stmt", "stmt_list", "stmt_list_in_choice",
+  "config_entry_start", "config_stmt", "menuconfig_entry_start",
+  "menuconfig_stmt", "config_option_list", "config_option", "choice",
+  "choice_entry", "choice_end", "choice_stmt", "choice_option_list",
+  "choice_option", "type", "logic_type", "default", "if_entry", "if_end",
+  "if_stmt", "if_stmt_in_choice", "menu", "menu_entry", "menu_end",
+  "menu_stmt", "menu_option_list", "source_stmt", "comment",
+  "comment_stmt", "comment_option_list", "help_start", "help", "depends",
+  "visible", "prompt_stmt_opt", "end", "if_expr", "expr",
+  "nonconst_symbol", "symbol", "word_opt", "assignment_stmt", "assign_op",
+  "assign_val", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   304
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    50,    51,    51,    52,    53,    53,    53,    53,    53,
+      53,    53,    53,    53,    53,    53,    54,    54,    54,    54,
+      54,    55,    56,    57,    58,    59,    59,    59,    59,    60,
+      60,    60,    60,    60,    60,    60,    61,    62,    63,    64,
+      65,    65,    65,    65,    66,    66,    66,    66,    67,    67,
+      67,    67,    68,    68,    69,    69,    69,    70,    71,    72,
+      73,    74,    75,    76,    77,    78,    78,    78,    79,    80,
+      81,    82,    82,    83,    84,    85,    86,    87,    87,    88,
+      88,    88,    89,    89,    90,    90,    90,    90,    90,    90,
+      90,    90,    90,    90,    90,    91,    92,    92,    93,    93,
+      94,    95,    95,    95,    96,    96
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     2,     1,     3,     0,     2,     2,     2,     2,
+       2,     2,     2,     2,     4,     3,     0,     2,     2,     2,
+       3,     3,     2,     3,     2,     0,     2,     2,     2,     3,
+       4,     4,     4,     4,     5,     2,     3,     2,     1,     3,
+       0,     2,     2,     2,     4,     3,     2,     4,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     3,     1,     3,
+       3,     3,     2,     1,     3,     0,     2,     2,     3,     3,
+       2,     0,     2,     2,     2,     4,     3,     0,     2,     2,
+       2,     2,     0,     2,     1,     3,     3,     3,     3,     3,
+       3,     3,     2,     3,     3,     1,     1,     1,     0,     1,
+       4,     1,     1,     1,     0,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       5,     0,     0,     5,     0,     0,     1,     0,     0,     0,
+      98,     0,     0,     0,     0,     0,     0,    25,     9,    25,
+      12,    40,    16,     7,     5,    10,    65,     5,    11,    13,
+      71,     8,     6,     4,    15,     0,   102,   103,   101,   104,
+      99,     0,     0,    95,     0,    97,     0,     0,     0,    96,
+      84,     0,     0,     0,    22,    24,    37,     0,     0,    62,
+       0,    70,    14,   105,     0,    36,    69,    21,     0,    92,
+      57,     0,     0,     0,     0,     0,     0,     0,     0,    61,
+      23,    68,    52,    54,    55,    56,     0,     0,    50,     0,
+      49,     0,     0,     0,     0,    51,    53,    26,    77,    48,
+       0,     0,    28,    27,     0,     0,     0,    41,    77,    43,
+      42,     0,     0,     0,     0,    18,    39,    16,    19,    17,
+      38,    59,    58,    82,    67,    66,    64,    63,    72,   100,
+      91,    93,    94,    90,    89,    88,    87,    86,    85,     0,
+      73,    82,    35,    82,     0,    82,    82,     0,    82,    74,
+      82,    46,    82,     0,    20,    80,    81,    79,     0,     0,
+       0,     0,     0,     0,    82,     0,    78,    29,     0,     0,
+       0,    45,    60,    83,    76,    75,    33,    30,     0,    32,
+      31,    47,    44,    34
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     2,     3,     4,    57,    17,    18,    19,    20,    54,
+      97,    21,    22,   116,    23,    56,   107,    98,    99,   100,
+      24,   121,    25,   118,    26,    27,   126,    28,    59,    29,
+      30,    31,    61,   101,   102,   103,   125,   147,   122,   160,
+      48,    49,    50,    41,    32,    39,    64
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -65
+static const yytype_int16 yypact[] =
+{
+      -4,    31,    55,   -65,    17,    -5,   -65,    46,    21,    14,
+      61,    69,    75,     2,    85,    75,    89,   -65,   -65,   -65,
+     -65,   -65,   -65,   -65,   -65,   -65,   -65,   -65,   -65,   -65,
+     -65,   -65,   -65,   -65,   -65,    57,   -65,   -65,   -65,    59,
+     -65,    76,    79,   -65,    80,   -65,     2,     2,    34,   -65,
+     115,    86,    90,    93,   108,   108,    29,    67,    91,    24,
+      91,   109,   -65,   -65,    94,   -65,   -65,   -65,    22,   -65,
+     -65,     2,     2,   106,   106,   106,   106,   106,   106,   -65,
+     -65,   -65,   -65,   -65,   -65,   -65,    72,    99,   -65,    75,
+     -65,   100,   101,   106,    75,   -65,   -65,   -65,   138,   -65,
+       2,   144,   -65,   -65,    75,   110,   147,   -65,   138,   -65,
+     -65,   117,   125,   126,   127,   -65,   -65,   -65,   -65,   -65,
+     -65,   -65,   -65,   133,   -65,   -65,   -65,   -65,   -65,   -65,
+     -65,   128,   -65,   -65,   -65,   -65,   -65,   -65,   -65,     2,
+     -65,   133,   -65,   133,   106,   133,   133,   129,    28,   -65,
+     133,   -65,   133,   132,   -65,   -65,   -65,   -65,    67,     2,
+     134,    95,   135,   136,   133,   137,   -65,   -65,   139,   140,
+     141,   -65,   -65,    -9,   -65,   -65,   -65,   -65,   142,   -65,
+     -65,   -65,   -65,   -65
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+     -65,   -65,   -65,    13,    50,   -65,   -55,   -65,   -65,   153,
+     -65,   -65,   -65,   -65,   -65,   -65,   -65,   -65,   121,   -65,
+     -54,    25,   -65,   -65,   -65,   -65,   -65,   -65,   -65,   -65,
+     -65,   -53,   -65,   -65,   130,    30,   -65,    74,   -38,     5,
+     -46,    -7,   -64,   -65,   -65,   -65,   -65
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -4
+static const yytype_int16 yytable[] =
+{
+      68,    69,   115,   117,   119,    44,    43,    45,    52,   133,
+     134,   135,   136,   137,   138,    35,     7,    -3,     8,   120,
+       1,     9,   127,    36,    10,   131,   132,    11,    12,   144,
+     130,    46,    71,    72,    33,    82,     5,    58,    13,    86,
+      60,   104,    14,    15,    86,    37,    -2,     8,    87,   159,
+       9,    47,    16,    10,   148,     6,    11,    12,    38,   105,
+      34,   106,   123,    71,    72,    40,    96,    13,   111,    71,
+      72,    14,    15,    70,    42,    71,    72,    11,    12,    43,
+     164,    16,   141,   112,   113,   114,   110,   145,    13,   124,
+      51,   128,     8,   161,    53,     9,    62,   150,    10,    63,
+     139,    11,    12,   115,   117,   119,   143,   112,   113,   114,
+      43,    45,    13,   173,    82,    65,    14,    15,    66,    67,
+      83,    84,    85,    86,    86,    79,    16,    87,    88,    80,
+      89,    90,    81,   129,   175,    91,    71,    72,   140,   142,
+      92,    93,    94,   146,    95,    96,   162,   149,   163,   151,
+     165,   166,   152,   168,   159,   169,   154,   170,    73,    74,
+      75,    76,    77,    78,   155,   156,   157,   158,   167,   178,
+      72,   171,    55,   174,   176,   177,   179,   108,   180,   181,
+     182,   183,   153,   172,     0,     0,   109
+};
+
+static const yytype_int16 yycheck[] =
+{
+      46,    47,    57,    57,    57,    12,     4,     5,    15,    73,
+      74,    75,    76,    77,    78,     1,     3,     0,     1,    57,
+      24,     4,    60,     9,     7,    71,    72,    10,    11,    93,
+       8,    29,    41,    42,    39,     6,     5,    24,    21,    15,
+      27,    12,    25,    26,    15,    31,     0,     1,    19,    21,
+       4,    49,    35,     7,   100,     0,    10,    11,    44,    30,
+      39,    32,    38,    41,    42,     4,    37,    21,     1,    41,
+      42,    25,    26,    39,     5,    41,    42,    10,    11,     4,
+     144,    35,    89,    16,    17,    18,    56,    94,    21,    59,
+       5,    61,     1,   139,     5,     4,    39,   104,     7,    40,
+      28,    10,    11,   158,   158,   158,     5,    16,    17,    18,
+       4,     5,    21,   159,     6,    39,    25,    26,    39,    39,
+      12,    13,    14,    15,    15,    39,    35,    19,    20,    39,
+      22,    23,    39,    39,    39,    27,    41,    42,    39,    39,
+      32,    33,    34,     5,    36,    37,   141,     3,   143,    39,
+     145,   146,     5,   148,    21,   150,    39,   152,    43,    44,
+      45,    46,    47,    48,    39,    39,    39,   117,    39,   164,
+      42,    39,    19,    39,    39,    39,    39,    56,    39,    39,
+      39,    39,   108,   158,    -1,    -1,    56
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    24,    51,    52,    53,     5,     0,    53,     1,     4,
+       7,    10,    11,    21,    25,    26,    35,    55,    56,    57,
+      58,    61,    62,    64,    70,    72,    74,    75,    77,    79,
+      80,    81,    94,    39,    39,     1,     9,    31,    44,    95,
+       4,    93,     5,     4,    91,     5,    29,    49,    90,    91,
+      92,     5,    91,     5,    59,    59,    65,    54,    53,    78,
+      53,    82,    39,    40,    96,    39,    39,    39,    90,    90,
+      39,    41,    42,    43,    44,    45,    46,    47,    48,    39,
+      39,    39,     6,    12,    13,    14,    15,    19,    20,    22,
+      23,    27,    32,    33,    34,    36,    37,    60,    67,    68,
+      69,    83,    84,    85,    12,    30,    32,    66,    68,    84,
+      85,     1,    16,    17,    18,    56,    63,    70,    73,    81,
+      88,    71,    88,    38,    85,    86,    76,    88,    85,    39,
+       8,    90,    90,    92,    92,    92,    92,    92,    92,    28,
+      39,    91,    39,     5,    92,    91,     5,    87,    90,     3,
+      91,    39,     5,    87,    39,    39,    39,    39,    54,    21,
+      89,    90,    89,    89,    92,    89,    89,    39,    89,    89,
+      89,    39,    71,    90,    39,    39,    39,    39,    89,    39,
+      39,    39,    39,    39
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
+#else
+static void
+yy_stack_print (bottom, top)
+    yytype_int16 *bottom;
+    yytype_int16 *top;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+      case 62: /* "choice_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 70: /* "if_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 75: /* "menu_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+
+      default:
+	break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+
+/* The look-ahead symbol.  */
+int yychar;
+
+/* The semantic value of the look-ahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+  
+  int yystate;
+  int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  YYSTYPE *yyvsp;
+
+
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to look-ahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a look-ahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 4:
+
+    {
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+;}
+    break;
+
+  case 14:
+
+    { zconf_error("unknown statement \"%s\"", (yyvsp[(2) - (4)].string)); ;}
+    break;
+
+  case 15:
+
+    { zconf_error("invalid statement"); ;}
+    break;
+
+  case 20:
+
+    { zconf_error("invalid statement"); ;}
+    break;
+
+  case 21:
+
+    {
+	(yyvsp[(2) - (3)].symbol)->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry((yyvsp[(2) - (3)].symbol));
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].symbol)->name);
+;}
+    break;
+
+  case 22:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 23:
+
+    {
+	(yyvsp[(2) - (3)].symbol)->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry((yyvsp[(2) - (3)].symbol));
+	printd(DEBUG_PARSE, "%s:%d:menuconfig %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].symbol)->name);
+;}
+    break;
+
+  case 24:
+
+    {
+	if (current_entry->prompt)
+		current_entry->prompt->type = P_MENU;
+	else
+		zconfprint("warning: menuconfig statement without prompt");
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 29:
+
+    {
+	menu_set_type((yyvsp[(1) - (3)].type));
+	printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (3)].type));
+;}
+    break;
+
+  case 30:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 31:
+
+    {
+	menu_add_expr(P_DEFAULT, (yyvsp[(2) - (4)].expr), (yyvsp[(3) - (4)].expr));
+	if ((yyvsp[(1) - (4)].type) != S_UNKNOWN)
+		menu_set_type((yyvsp[(1) - (4)].type));
+	printd(DEBUG_PARSE, "%s:%d:default(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (4)].type));
+;}
+    break;
+
+  case 32:
+
+    {
+	menu_add_symbol(P_SELECT, (yyvsp[(2) - (4)].symbol), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:select\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 33:
+
+    {
+	menu_add_symbol(P_IMPLY, (yyvsp[(2) - (4)].symbol), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:imply\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 34:
+
+    {
+	menu_add_expr(P_RANGE, expr_alloc_comp(E_RANGE,(yyvsp[(2) - (5)].symbol), (yyvsp[(3) - (5)].symbol)), (yyvsp[(4) - (5)].expr));
+	printd(DEBUG_PARSE, "%s:%d:range\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 35:
+
+    {
+	if (modules_sym)
+		zconf_error("symbol '%s' redefines option 'modules' already defined by symbol '%s'",
+			    current_entry->sym->name, modules_sym->name);
+	modules_sym = current_entry->sym;
+;}
+    break;
+
+  case 36:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), SYMBOL_CHOICE);
+	sym->flags |= SYMBOL_NO_WRITE;
+	menu_add_entry(sym);
+	menu_add_expr(P_CHOICE, NULL, NULL);
+	free((yyvsp[(2) - (3)].string));
+	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 37:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 38:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].string), "choice")) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 44:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 45:
+
+    {
+	menu_set_type((yyvsp[(1) - (3)].type));
+	printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+	       zconf_curname(), zconf_lineno(), (yyvsp[(1) - (3)].type));
+;}
+    break;
+
+  case 46:
+
+    {
+	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 47:
+
+    {
+	menu_add_symbol(P_DEFAULT, (yyvsp[(2) - (4)].symbol), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:default\n",
+	       zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 49:
+
+    { (yyval.type) = S_INT; ;}
+    break;
+
+  case 50:
+
+    { (yyval.type) = S_HEX; ;}
+    break;
+
+  case 51:
+
+    { (yyval.type) = S_STRING; ;}
+    break;
+
+  case 52:
+
+    { (yyval.type) = S_BOOLEAN; ;}
+    break;
+
+  case 53:
+
+    { (yyval.type) = S_TRISTATE; ;}
+    break;
+
+  case 54:
+
+    { (yyval.type) = S_UNKNOWN; ;}
+    break;
+
+  case 55:
+
+    { (yyval.type) = S_BOOLEAN; ;}
+    break;
+
+  case 56:
+
+    { (yyval.type) = S_TRISTATE; ;}
+    break;
+
+  case 57:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+	menu_add_entry(NULL);
+	menu_add_dep((yyvsp[(2) - (3)].expr));
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 58:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].string), "if")) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 61:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 62:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 63:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].string), "menu")) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 68:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+	zconf_nextfile((yyvsp[(2) - (3)].string));
+	free((yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 69:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_COMMENT, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 73:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+	zconf_starthelp();
+;}
+    break;
+
+  case 74:
+
+    {
+	if (current_entry->help) {
+		free(current_entry->help);
+		zconfprint("warning: '%s' defined with more than one help text -- only the last one will be used",
+			   current_entry->sym->name ?: "<choice>");
+	}
+
+	/* Is the help text empty or all whitespace? */
+	if ((yyvsp[(2) - (2)].string)[strspn((yyvsp[(2) - (2)].string), " \f\n\r\t\v")] == '\0')
+		zconfprint("warning: '%s' defined with blank help text",
+			   current_entry->sym->name ?: "<choice>");
+
+	current_entry->help = (yyvsp[(2) - (2)].string);
+;}
+    break;
+
+  case 75:
+
+    {
+	menu_add_dep((yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 76:
+
+    {
+	menu_add_visibility((yyvsp[(2) - (3)].expr));
+;}
+    break;
+
+  case 78:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(1) - (2)].string), (yyvsp[(2) - (2)].expr));
+;}
+    break;
+
+  case 79:
+
+    { (yyval.string) = "menu"; ;}
+    break;
+
+  case 80:
+
+    { (yyval.string) = "choice"; ;}
+    break;
+
+  case 81:
+
+    { (yyval.string) = "if"; ;}
+    break;
+
+  case 82:
+
+    { (yyval.expr) = NULL; ;}
+    break;
+
+  case 83:
+
+    { (yyval.expr) = (yyvsp[(2) - (2)].expr); ;}
+    break;
+
+  case 84:
+
+    { (yyval.expr) = expr_alloc_symbol((yyvsp[(1) - (1)].symbol)); ;}
+    break;
+
+  case 85:
+
+    { (yyval.expr) = expr_alloc_comp(E_LTH, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 86:
+
+    { (yyval.expr) = expr_alloc_comp(E_LEQ, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 87:
+
+    { (yyval.expr) = expr_alloc_comp(E_GTH, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 88:
+
+    { (yyval.expr) = expr_alloc_comp(E_GEQ, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 89:
+
+    { (yyval.expr) = expr_alloc_comp(E_EQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 90:
+
+    { (yyval.expr) = expr_alloc_comp(E_UNEQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 91:
+
+    { (yyval.expr) = (yyvsp[(2) - (3)].expr); ;}
+    break;
+
+  case 92:
+
+    { (yyval.expr) = expr_alloc_one(E_NOT, (yyvsp[(2) - (2)].expr)); ;}
+    break;
+
+  case 93:
+
+    { (yyval.expr) = expr_alloc_two(E_OR, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 94:
+
+    { (yyval.expr) = expr_alloc_two(E_AND, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 95:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), 0); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 97:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), SYMBOL_CONST); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 98:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+  case 100:
+
+    { variable_add((yyvsp[(1) - (4)].string), (yyvsp[(3) - (4)].string), (yyvsp[(2) - (4)].flavor)); free((yyvsp[(1) - (4)].string)); free((yyvsp[(3) - (4)].string)); ;}
+    break;
+
+  case 101:
+
+    { (yyval.flavor) = VAR_RECURSIVE; ;}
+    break;
+
+  case 102:
+
+    { (yyval.flavor) = VAR_SIMPLE; ;}
+    break;
+
+  case 103:
+
+    { (yyval.flavor) = VAR_APPEND; ;}
+    break;
+
+  case 104:
+
+    { (yyval.string) = xstrdup(""); ;}
+    break;
+
+
+/* Line 1267 of yacc.c.  */
+
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse look-ahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse look-ahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+
+
+void conf_parse(const char *name)
+{
+	struct symbol *sym;
+	int i;
+
+	zconf_initscan(name);
+
+	_menu_init();
+
+	if (getenv("ZCONF_DEBUG"))
+		yydebug = 1;
+	yyparse();
+
+	/* Variables are expanded in the parse phase. We can free them here. */
+	variable_all_del();
+
+	if (yynerrs)
+		exit(1);
+	if (!modules_sym)
+		modules_sym = sym_find( "n" );
+
+	if (!menu_has_prompt(&rootmenu)) {
+		current_entry = &rootmenu;
+		menu_add_prompt(P_MENU, "Main menu", NULL);
+	}
+
+	menu_finalize(&rootmenu);
+	for_all_symbols(i, sym) {
+		if (sym_check_deps(sym))
+			yynerrs++;
+	}
+	if (yynerrs)
+		exit(1);
+	conf_set_changed(true);
+}
+
+static bool zconf_endtoken(const char *tokenname,
+			   const char *expected_tokenname)
+{
+	if (strcmp(tokenname, expected_tokenname)) {
+		zconf_error("unexpected '%s' within %s block",
+			    tokenname, expected_tokenname);
+		yynerrs++;
+		return false;
+	}
+	if (current_menu->file != current_file) {
+		zconf_error("'%s' in different file than '%s'",
+			    tokenname, expected_tokenname);
+		fprintf(stderr, "%s:%d: location of the '%s'\n",
+			current_menu->file->name, current_menu->lineno,
+			expected_tokenname);
+		yynerrs++;
+		return false;
+	}
+	return true;
+}
+
+static void zconfprint(const char *err, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconf_error(const char *err, ...)
+{
+	va_list ap;
+
+	yynerrs++;
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void yyerror(const char *err)
+{
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
+}
+
+static void print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	fputs(str, out);
+	putc('"', out);
+}
+
+static void print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+
+	if (sym_is_choice(sym))
+		fprintf(out, "\nchoice\n");
+	else
+		fprintf(out, "\nconfig %s\n", sym->name);
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("  bool\n", out);
+		break;
+	case S_TRISTATE:
+		fputs("  tristate\n", out);
+		break;
+	case S_STRING:
+		fputs("  string\n", out);
+		break;
+	case S_INT:
+		fputs("  integer\n", out);
+		break;
+	case S_HEX:
+		fputs("  hex\n", out);
+		break;
+	default:
+		fputs("  ???\n", out);
+		break;
+	}
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fputs("  prompt ", out);
+			print_quoted_string(out, prop->text);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_DEFAULT:
+			fputs( "  default ", out);
+			expr_fprint(prop->expr, out);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_CHOICE:
+			fputs("  #choice value\n", out);
+			break;
+		case P_SELECT:
+			fputs( "  select ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
+		case P_IMPLY:
+			fputs( "  imply ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
+		case P_RANGE:
+			fputs( "  range ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
+		case P_MENU:
+			fputs( "  menu ", out);
+			print_quoted_string(out, prop->text);
+			fputc('\n', out);
+			break;
+		case P_SYMBOL:
+			fputs( "  symbol ", out);
+			fprintf(out, "%s\n", prop->menu->sym->name);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+	if (menu->help) {
+		int len = strlen(menu->help);
+		while (menu->help[--len] == '\n')
+			menu->help[len] = 0;
+		fprintf(out, "  help\n%s\n", menu->help);
+	}
+}
+
+void zconfdump(FILE *out)
+{
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			case P_COMMENT:
+				fputs("\ncomment ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			case P_MENU:
+				fputs("\nmenu ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			default:
+				;
+			}
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs("  depends ", out);
+				expr_fprint(prop->visible.expr, out);
+				fputc('\n', out);
+			}
+		}
+
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU)
+				fputs("\nendmenu\n", out);
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
diff --git a/scripts/kconfig/parser.tab.h b/scripts/kconfig/parser.tab.h
new file mode 100644
index 000000000..117a89677
--- /dev/null
+++ b/scripts/kconfig/parser.tab.h
@@ -0,0 +1,163 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_HELPTEXT = 258,
+     T_WORD = 259,
+     T_WORD_QUOTE = 260,
+     T_BOOL = 261,
+     T_CHOICE = 262,
+     T_CLOSE_PAREN = 263,
+     T_COLON_EQUAL = 264,
+     T_COMMENT = 265,
+     T_CONFIG = 266,
+     T_DEFAULT = 267,
+     T_DEF_BOOL = 268,
+     T_DEF_TRISTATE = 269,
+     T_DEPENDS = 270,
+     T_ENDCHOICE = 271,
+     T_ENDIF = 272,
+     T_ENDMENU = 273,
+     T_HELP = 274,
+     T_HEX = 275,
+     T_IF = 276,
+     T_IMPLY = 277,
+     T_INT = 278,
+     T_MAINMENU = 279,
+     T_MENU = 280,
+     T_MENUCONFIG = 281,
+     T_MODULES = 282,
+     T_ON = 283,
+     T_OPEN_PAREN = 284,
+     T_OPTIONAL = 285,
+     T_PLUS_EQUAL = 286,
+     T_PROMPT = 287,
+     T_RANGE = 288,
+     T_SELECT = 289,
+     T_SOURCE = 290,
+     T_STRING = 291,
+     T_TRISTATE = 292,
+     T_VISIBLE = 293,
+     T_EOL = 294,
+     T_ASSIGN_VAL = 295,
+     T_OR = 296,
+     T_AND = 297,
+     T_UNEQUAL = 298,
+     T_EQUAL = 299,
+     T_GREATER_EQUAL = 300,
+     T_GREATER = 301,
+     T_LESS_EQUAL = 302,
+     T_LESS = 303,
+     T_NOT = 304
+   };
+#endif
+/* Tokens.  */
+#define T_HELPTEXT 258
+#define T_WORD 259
+#define T_WORD_QUOTE 260
+#define T_BOOL 261
+#define T_CHOICE 262
+#define T_CLOSE_PAREN 263
+#define T_COLON_EQUAL 264
+#define T_COMMENT 265
+#define T_CONFIG 266
+#define T_DEFAULT 267
+#define T_DEF_BOOL 268
+#define T_DEF_TRISTATE 269
+#define T_DEPENDS 270
+#define T_ENDCHOICE 271
+#define T_ENDIF 272
+#define T_ENDMENU 273
+#define T_HELP 274
+#define T_HEX 275
+#define T_IF 276
+#define T_IMPLY 277
+#define T_INT 278
+#define T_MAINMENU 279
+#define T_MENU 280
+#define T_MENUCONFIG 281
+#define T_MODULES 282
+#define T_ON 283
+#define T_OPEN_PAREN 284
+#define T_OPTIONAL 285
+#define T_PLUS_EQUAL 286
+#define T_PROMPT 287
+#define T_RANGE 288
+#define T_SELECT 289
+#define T_SOURCE 290
+#define T_STRING 291
+#define T_TRISTATE 292
+#define T_VISIBLE 293
+#define T_EOL 294
+#define T_ASSIGN_VAL 295
+#define T_OR 296
+#define T_AND 297
+#define T_UNEQUAL 298
+#define T_EQUAL 299
+#define T_GREATER_EQUAL 300
+#define T_GREATER 301
+#define T_LESS_EQUAL 302
+#define T_LESS 303
+#define T_NOT 304
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+
+{
+	char *string;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+	enum symbol_type type;
+	enum variable_flavor flavor;
+}
+/* Line 1529 of yacc.c.  */
+
+	YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+extern YYSTYPE yylval;
+
diff --git a/scripts/kconfig/parser.tab.o b/scripts/kconfig/parser.tab.o
new file mode 100644
index 000000000..e89980855
Binary files /dev/null and b/scripts/kconfig/parser.tab.o differ
diff --git a/scripts/kconfig/preprocess.o b/scripts/kconfig/preprocess.o
new file mode 100644
index 000000000..e47f18f63
Binary files /dev/null and b/scripts/kconfig/preprocess.o differ
diff --git a/scripts/kconfig/symbol.o b/scripts/kconfig/symbol.o
new file mode 100644
index 000000000..199786791
Binary files /dev/null and b/scripts/kconfig/symbol.o differ
diff --git a/scripts/kconfig/util.o b/scripts/kconfig/util.o
new file mode 100644
index 000000000..b8c3754f5
Binary files /dev/null and b/scripts/kconfig/util.o differ
